{"version":3,"file":"structive.min.js","sources":["../src/WebComponents/getGlobalConfig.ts","../src/Filter/errorMessages.ts","../src/Filter/builtinFilters.ts","../src/GlobalId/generateId.ts","../src/utils.ts","../src/StateClass/registerStateClass.ts","../src/StyleSheet/registerStyleSheet.ts","../src/StyleSheet/regsiterCss.ts","../src/BindingBuilder/createFilters.ts","../src/DataBinding/BindingNode/BindingNode.ts","../src/DataBinding/BindingNode/BindingNodeAttribute.ts","../src/DataBinding/BindingNode/BindingNodeCheckbox.ts","../src/DataBinding/BindingNode/BindingNodeClassList.ts","../src/DataBinding/BindingNode/BindingNodeClassName.ts","../src/DataBinding/BindingNode/BindingNodeEvent.ts","../src/constants.ts","../src/DataBinding/BindingNode/BindingNodeBlock.ts","../src/DataBinding/BindingNode/BindingNodeIf.ts","../src/DataBinding/BindingNode/BindingNodeFor.ts","../src/BindingBuilder/getDefaultName.ts","../src/StateClass/symbols.ts","../src/DataBinding/BindingNode/BindingNodeProperty.ts","../src/DataBinding/BindingNode/BindingNodeRadio.ts","../src/DataBinding/BindingNode/BindingNodeStyle.ts","../src/BindingBuilder/getBindingNodeCreator.ts","../src/StateProperty/getStructuredPathInfo.ts","../src/DataBinding/BindingState/BindingState.ts","../src/DataBinding/BindingState/BindingStateIndex.ts","../src/BindingBuilder/getBindingStateCreator.ts","../src/BindingBuilder/getDataBindText.ts","../src/BindingBuilder/getNodeType.ts","../src/BindingBuilder/parseBindText.ts","../src/BindingBuilder/removeDataBindAttribute.ts","../src/BindingBuilder/replaceTextNodeFromComment.ts","../src/BindingBuilder/createDataBindAttributes.ts","../src/BindingBuilder/getAbsoluteNodePath.ts","../src/BindingBuilder/getNodesHavingDataBind.ts","../src/BindingBuilder/registerDataBindAttributes.ts","../src/Template/registerTemplate.ts","../src/Template/removeEmptyTextNodes.ts","../src/DataBinding/Binding.ts","../src/LoopContext/createLoopContext.ts","../src/Render/render.ts","../src/DataBinding/BindContent.ts","../src/BindingBuilder/resolveNodeFromPath.ts","../src/StateProperty/getResolvedPathInfo.ts","../src/ListIndex/createListIndex.ts","../src/StatePropertyRef/getStatePropertyRefId.ts","../src/StateClass/createStateProxy.ts","../src/StateClass/buildListIndexTree.ts","../src/Updater/collectAffectedGetters.ts","../src/Updater/updater.ts","../src/ComponentEngine/attachShadow.ts","../src/ComponentEngine/canHaveShadowRoot.ts","../src/ComponentEngine/ComponentEngine.ts","../src/Template/replaceMustacheWithTemplateTag.ts","../src/Template/replaceTemplateTagWithComment.ts","../src/Template/registerHtml.ts","../src/WebComponents/createComponentClass.ts","../src/WebComponents/getComponentConfig.ts","../src/WebComponents/getBaseClass.ts","../src/WebComponents/createSingleFileComponent.ts","../src/WebComponents/loadSingleFileComponent.ts","../src/exports.ts","../src/WebComponents/registerSingleFIleComponents.ts","../src/WebComponents/registerComponentClass.ts"],"sourcesContent":["import { IConfig } from \"./types\";\r\n\r\nconst globalConfig: IConfig = {\r\n  debug          : false,\r\n  locale         : \"en-US\", // The locale of the component, ex. \"en-US\", default is \"en-US\"\r\n  enableShadowDom: true,\r\n};\r\n\r\nexport function getGlobalConfig():IConfig {\r\n  return globalConfig;\r\n}","\r\nexport function optionsRequired(fnName:string): never {\r\n  throw new Error(`${fnName} requires at least one option`);\r\n}\r\n\r\nexport function optionMustBeNumber(fnName:string): never {\r\n  throw new Error(`${fnName} requires a number as option`);\r\n}\r\n\r\nexport function valueMustBeNumber(fnName:string): never {\r\n  throw new Error(`${fnName} requires a number value`);\r\n}\r\n\r\nexport function valueMustBeBoolean(fnName:string): never {\r\n  throw new Error(`${fnName} requires a boolean value`);\r\n}\r\n\r\nexport function valueMustBeDate(fnName:string): never {\r\n  throw new Error(`${fnName} requires a date value`);\r\n}","import { getGlobalConfig } from \"../WebComponents/getGlobalConfig\";\r\nimport { optionMustBeNumber, optionsRequired, valueMustBeBoolean, valueMustBeDate, valueMustBeNumber } from \"./errorMessages\";\r\nimport { FilterWithOptions } from \"./types\";\r\n\r\nconst config = getGlobalConfig();\r\n\r\nconst eq = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('eq');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('eq');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('eq');\r\n    return value === optValue;\r\n  }\r\n}\r\n\r\nconst ne = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('ne');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('ne');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ne');\r\n    return value !== optValue;\r\n  }\r\n}\r\n\r\nconst not = (options?:string[]) => {\r\n  return (value: any) => {\r\n    if (typeof value !== 'boolean') valueMustBeBoolean('not');\r\n    return !value;\r\n  }\r\n}\r\n\r\nconst lt = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('lt');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('lt');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('lt');\r\n    return value < optValue;\r\n  }\r\n}\r\n\r\nconst le = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('le');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('le');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('le');\r\n    return value <= optValue;\r\n  }\r\n}\r\n\r\nconst gt = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('gt');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('gt');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('gt');\r\n    return value > optValue;\r\n  }\r\n}\r\n\r\nconst ge = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('ge');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('ge');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ge');\r\n    return value >= optValue;\r\n  }\r\n}\r\n\r\nconst inc = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('inc');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('inc');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('inc');\r\n    return value + optValue;\r\n  }\r\n}\r\n\r\nconst dec = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('dec');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('dec');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('dec');\r\n    return value - optValue;\r\n  }\r\n}\r\n\r\nconst mul = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('mul');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('mul');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('mul');\r\n    return value * optValue;\r\n  }\r\n}\r\n\r\nconst div = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('div');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('div');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('div');\r\n    return value / optValue;\r\n  }\r\n}\r\n\r\nconst fix = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('div');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('div');\r\n    return value.toFixed(optValue);\r\n  }\r\n}\r\n\r\nconst locale = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('locale');\r\n    return value.toLocaleString(opt);\r\n  }\r\n}\r\n\r\nconst uc = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().toUpperCase();\r\n  }\r\n}\r\n\r\nconst lc = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().toLowerCase();\r\n  }\r\n}\r\n\r\nconst cap = (options?:string[]) => {\r\n  return (value: any) => {\r\n    const v = value.toString();\r\n    if (v.length === 0) return v;\r\n    if (v.length === 1) return v.toUpperCase();\r\n    return v.charAt(0).toUpperCase() + v.slice(1);\r\n  }\r\n}\r\n\r\nconst trim = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().trim();\r\n  }\r\n}\r\n\r\nconst slice = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('slice');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('slice');\r\n  return (value: any) => {\r\n    return value.toString().slice(optValue);\r\n  }\r\n}\r\n\r\nconst substr = (options?:string[]) => {\r\n  const opt1 = options?.[0] ?? optionsRequired('substr');\r\n  const opt1Value = Number(opt1);\r\n  if (isNaN(opt1Value)) optionMustBeNumber('substr');\r\n  const opt2 = options?.[1] ?? optionsRequired('substr');\r\n  const opt2Value = Number(opt2);\r\n  if (isNaN(opt2Value)) optionMustBeNumber('substr');\r\n  return (value: any) => {\r\n    return value.toString().substr(opt1Value, opt2Value);\r\n  }\r\n}\r\n\r\nconst pad = (options?:string[]) => {\r\n  const opt1 = options?.[0] ?? optionsRequired('pad');\r\n  const opt1Value = Number(opt1);\r\n  if (isNaN(opt1Value)) optionMustBeNumber('pad');\r\n  const opt2 = options?.[1] ?? '0';\r\n  const opt2Value = opt2;\r\n  return (value: any) => {\r\n    return value.toString().padStart(opt1Value, opt2Value);\r\n  }\r\n}\r\n\r\nconst rep = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('rep');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('rep');\r\n  return (value: any) => {\r\n    return value.toString().repeat(optValue);\r\n  }\r\n}\r\n\r\nconst rev = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().split('').reverse().join('');\r\n  }\r\n}\r\n\r\nconst int = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return parseInt(value, 10);\r\n  }\r\n}\r\n\r\nconst float = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return parseFloat(value);\r\n  }\r\n}\r\n\r\nconst round = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('round');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('round');\r\n    return Math.round(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst floor = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('floor');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('floor');\r\n    return Math.floor(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst ceil = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('ceil');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ceil');\r\n    return Math.ceil(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst percent = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('percent');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('percent');\r\n    return value.toFixed(optValue) + '%';\r\n  }\r\n}\r\n\r\nconst date = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date))  valueMustBeDate('date');\r\n    return value.toLocaleDateString(config.locale);\r\n  }\r\n}\r\n\r\nconst time = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('time');\r\n    return value.toLocaleTimeString(config.locale);\r\n  }\r\n}\r\n\r\nconst datetime = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('datetime');\r\n    return value.toLocaleString(config.locale);\r\n  }\r\n}\r\n\r\nconst ymd = (options?:string[]) => {\r\n  const opt = options?.[0] ?? '-';\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('ymd');\r\n    const year = value.getFullYear().toString();\r\n    const month = (value.getMonth() + 1).toString().padStart(2, '0');\r\n    const day = value.getDate().toString().padStart(2, '0');\r\n    return `${year}${opt}${month}${opt}${day}`;\r\n  }\r\n}\r\n\r\nconst falsy = (options?:string[]) => {\r\n  return (value: any) => value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value);\r\n}\r\n\r\nconst truthy = (options?:string[]) => {\r\n  return (value: any) =>value !== false && value !== null && value !== undefined && value !== 0 && value !== '' && !Number.isNaN(value);\r\n}\r\n\r\nconst defaults = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('defaults');\r\n  return (value: any) => {\r\n    if (value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value)) return opt;\r\n    return value;\r\n  }\r\n}\r\n\r\nconst boolean = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return Boolean(value);\r\n  }\r\n}\r\n\r\nconst number = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return Number(value);\r\n  }\r\n}\r\n\r\nconst string = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return String(value);\r\n  }\r\n}\r\n\r\nconst _null = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return (value === \"\") ? null : value;\r\n  } \r\n}\r\n\r\nconst builtinFilters: FilterWithOptions = {\r\n  eq,\r\n  ne,\r\n  not,\r\n  \r\n  lt,\r\n  le,\r\n  gt,\r\n  ge,\r\n\r\n  inc,\r\n  dec,\r\n  mul,\r\n  div,\r\n\r\n  fix,\r\n  locale,\r\n  uc,\r\n  lc,\r\n  cap,\r\n  trim,\r\n  slice,\r\n  substr,\r\n  pad,\r\n  rep,\r\n  rev,\r\n\r\n  int,\r\n  float,\r\n  round,\r\n  floor,\r\n  ceil,\r\n  percent,\r\n\r\n  date,\r\n  time,\r\n  datetime,\r\n  ymd,\r\n\r\n  falsy,\r\n  truthy,\r\n  defaults,\r\n\r\n  boolean,\r\n  number,\r\n  string,\r\n  \"null\": _null,\r\n};\r\n\r\nexport const outputBuiltinFilters = builtinFilters;\r\nexport const inputBuiltinFilters = builtinFilters;\r\n\r\nexport const builtinFilterFn = (name:string, options: string[]) => (filters: FilterWithOptions) => {\r\n  const filter = filters[name];\r\n  if (!filter) throw new Error(`outputBuiltinFiltersFn: filter not found: ${name}`);\r\n  return filter(options);\r\n}\r\n\r\n","\r\nlet id = 0;\r\n\r\nexport function generateId(): number {\r\n  return ++id;\r\n}","\r\nexport function raiseError(message: string): never {\r\n  throw new Error(message);\r\n}\r\n","import { raiseError } from \"../utils\";\r\n\r\nconst stateClassById: Record<number,typeof Object> = {};\r\n\r\nexport function registerStateClass(id: number, stateClass: typeof Object) {\r\n  stateClassById[id] = stateClass;\r\n}\r\n\r\nexport function getStateClassById(id: number): typeof Object {\r\n  return stateClassById[id] ?? raiseError(`getStateClassById: stateClass not found: ${id}`);\r\n}\r\n","import { raiseError } from \"../utils\";\r\n\r\nconst styleSheetById: Record<number,CSSStyleSheet> = {};\r\n\r\nexport function registerStyleSheet(id: number, css: CSSStyleSheet) {\r\n  styleSheetById[id] = css;\r\n}\r\n\r\nexport function getStyleSheetById(id: number): CSSStyleSheet {\r\n  return styleSheetById[id] ?? raiseError(`getStyleSheetById: stylesheet not found: ${id}`);\r\n}","import { registerStyleSheet } from \"./registerStyleSheet\";\r\n\r\nexport function registerCss(id: number, css: string) {\r\n  const styleSheet = new CSSStyleSheet();\r\n  styleSheet.replaceSync(css);\r\n  registerStyleSheet(id, styleSheet);\r\n}","import { FilterFn, Filters, FilterWithOptions } from \"../Filter/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IFilterText } from \"./types\";\r\n\r\nfunction textToFilter(filters:FilterWithOptions, text: IFilterText): FilterFn {\r\n  const filter = filters[text.name];\r\n  if (!filter) raiseError(`outputBuiltinFiltersFn: filter not found: ${name}`);\r\n  return filter(text.options);\r\n}\r\n\r\nconst cache : Map<IFilterText[], Filters> = new Map();\r\n\r\nexport function createFilters(filters:FilterWithOptions, texts: IFilterText[]): Filters {\r\n  let result = cache.get(texts);\r\n  if (typeof result === \"undefined\") {\r\n    result = [];\r\n    for(let i = 0; i < texts.length; i++) {\r\n      result.push(textToFilter(filters, texts[i]));\r\n    }\r\n    cache.set(texts, result);\r\n  }\r\n  return result;\r\n}\r\n","import { Filters } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { IBindingNode } from \"./types\";\r\n\r\nexport class BindingNode implements IBindingNode {\r\n  #binding: IBinding;\r\n  #node: Node;\r\n  #name: string;\r\n  #filters: Filters;\r\n  #event: string | null;\r\n  #bindContents: Set<IBindContent> = new Set<IBindContent>();\r\n  get node(): Node {\r\n    return this.#node;\r\n  }\r\n  get name(): string {\r\n    return this.#name;\r\n  }\r\n  get binding(): IBinding {\r\n    return this.#binding;\r\n  }\r\n  get event(): string | null {\r\n    return this.#event;\r\n  }\r\n  get filters(): Filters {\r\n    return this.#filters;\r\n  }\r\n  get bindContents(): Set<IBindContent> {\r\n    return this.#bindContents;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node  : Node, \r\n    name  : string,\r\n    filters: Filters,\r\n    event : string | null\r\n  ) {\r\n    this.#binding = binding;\r\n    this.#node = node;\r\n    this.#name = name;\r\n    this.#filters = filters;\r\n    this.#event = event;\r\n  }\r\n  init():void {\r\n  }\r\n  update(): void {\r\n    this.assignValue(this.binding.bindingState.filteredValue);\r\n  }\r\n  assignValue(value: any): void {\r\n    raiseError(`BindingNode: assignValue not implemented`);\r\n  }\r\n  updateElements(listIndexes: IListIndex[], values: any[]) {\r\n    raiseError(`BindingNode: updateElements not implemented`);\r\n  }\r\n  get isSelectElement(): boolean {\r\n    return this.node instanceof HTMLSelectElement;\r\n  }\r\n}","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeAttribute extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as Element;\r\n    element.setAttribute(this.subName, value.toString());\r\n  }\r\n}\r\n\r\nexport const createBindingNodeAttribute: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeAttribute(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeCheckbox extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError(`BindingNodeCheckbox.update: value is not array`, );\r\n    }\r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value.map(_val => _val.toString()).includes(element.value);\r\n  }\r\n}\r\n\r\nexport const createBindingNodeCheckbox: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeCheckbox(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeClassList extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError(`BindingNodeClassList.update: value is not array`);\r\n    }\r\n    const element = this.node as Element;\r\n    element.className = value.join(\" \");\r\n  }\r\n}\r\n\r\nexport const createBindingNodeClassList: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeClassList(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeClassName extends BindingNode {\r\n  #subName: string;\r\n  get subName(): string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (typeof value !== \"boolean\") {\r\n      raiseError(`BindingNodeClassName.update: value is not boolean`);\r\n    }\r\n    const element = this.node as Element;\r\n    if (value) {\r\n      element.classList.add(this.subName);\r\n    } else {\r\n      element.classList.remove(this.subName);\r\n    }\r\n  }\r\n}\r\n\r\nexport const createBindingNodeClassName: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeClassName(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeEvent extends BindingNode {\r\n  #subName    : string;\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    this.#subName = this.name.slice(2); // on～\r\n    const element = node as HTMLElement;\r\n    element.addEventListener(this.subName, (e:Event) => this.handler(e));\r\n  }\r\n  get subName(): string {\r\n    return this.#subName;\r\n  }\r\n  update() {\r\n    // 何もしない\r\n  }\r\n\r\n  handler(e: Event) {\r\n    const bindingState = this.binding.bindingState;\r\n    const engine = this.binding.engine;\r\n    const stateProxy = engine.stateProxy;\r\n    const updater = engine.updater;\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n    const indexes = loopContext?.serialize().map((context) => context.listIndex.index) ?? [];\r\n    const option = this.event;\r\n    if (option === \"preventDefault\") {\r\n      e.preventDefault();\r\n    }\r\n    this.binding.engine.updater.addProcess(async () => {\r\n      const value = bindingState.value;\r\n      const typeOfValue = typeof value;\r\n      updater.addProcess(async () => {\r\n        if (loopContext) {\r\n          await engine.setLoopContext(loopContext, async () => {\r\n            if (typeOfValue === \"function\") {\r\n              await Reflect.apply(value, stateProxy, [e, ...indexes]);\r\n            } else {\r\n              // ToDo:error\r\n            }\r\n          });\r\n        } else {\r\n          if (typeOfValue === \"function\") {\r\n            await Reflect.apply(value, stateProxy, [e, ...indexes]);\r\n          } else {\r\n            // ToDo:error\r\n          }\r\n        }\r\n      });\r\n    });\r\n  } \r\n}\r\n\r\nexport const createBindingNodeEvent: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeEvent(binding, node, name, filterFns, event);\r\n  }\r\n","export const DATA_BIND_ATTRIBUTE = \"data-bind\";\r\nexport const COMMENT_EMBED_MARK = \"@@:\"; // 埋め込み変数のマーク\r\nexport const COMMENT_TEMPLATE_MARK = \"@@|\"; // テンプレートのマーク\r\n","import { COMMENT_TEMPLATE_MARK } from \"../../constants\";\r\nimport { Filters } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode\";\r\n\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\nexport class BindingNodeBlock extends BindingNode {\r\n  #id: number;\r\n  get id(): number {\r\n    return this.#id;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    const id = this.node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN) ?? raiseError(\"BindingNodeBlock.id: invalid node\");\r\n    this.#id = Number(id);\r\n  }\r\n    \r\n}","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { createBindContent } from \"../BindContent\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeIf extends BindingNodeBlock {\r\n  #bindContent: IBindContent;\r\n  #trueBindContents: Set<IBindContent>;\r\n  #falseBindContents: Set<IBindContent> = new Set();\r\n  #bindContents: Set<IBindContent>;\r\n\r\n  get bindContents(): Set<IBindContent> {\r\n    return this.#bindContents;\r\n  }\r\n\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    this.#bindContent = createBindContent(\r\n      this.binding, \r\n      this.id, \r\n      this.binding.engine, \r\n      \"\", \r\n      null\r\n    );\r\n    this.#trueBindContents = this.#bindContents = new Set([this.#bindContent]);\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (typeof value !== \"boolean\") {\r\n      raiseError(`BindingNodeIf.update: value is not boolean`);\r\n    }\r\n    const parentNode = this.node.parentNode;\r\n    if (parentNode == null) {\r\n      raiseError(`BindingNodeIf.update: parentNode is null`);\r\n    }\r\n    if (value) {\r\n      this.#bindContent.render();\r\n      this.#bindContent.mountBefore(parentNode, this.node.nextSibling);\r\n      this.#bindContents = this.#trueBindContents;\r\n    } else {\r\n      this.#bindContent.unmount();\r\n      this.#bindContents = this.#falseBindContents;\r\n    }\r\n  }\r\n}\r\n\r\nexport const createBindingNodeIf: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeIf(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { createBindContent } from \"../BindContent\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeFor extends BindingNodeBlock {\r\n  #bindContentsSet       : Set<IBindContent> = new Set<IBindContent>();\r\n  #bindContentByListIndex: WeakMap<IListIndex, IBindContent> = new WeakMap();\r\n  #bindContentPool       : IBindContent[] = [];\r\n  #bindContentLastIndex  : number = 0;\r\n\r\n  get bindContents(): Set<IBindContent> {\r\n    return this.#bindContentsSet;\r\n  }\r\n\r\n  init() {\r\n  }\r\n\r\n  createBindContent(listIndex: IListIndex): IBindContent {\r\n    let bindContent: IBindContent;\r\n    if (this.#bindContentLastIndex >= 0) {\r\n      // プールの最後の要素を取得して、プールの長さをあとで縮減する\r\n      // 作るたびにプールを縮減すると、パフォーマンスが悪化するため\r\n      // プールの長さを縮減するのは、全ての要素を作った後に行う\r\n      bindContent = this.#bindContentPool[this.#bindContentLastIndex];\r\n      this.#bindContentLastIndex--;\r\n      bindContent.assignListIndex(listIndex);\r\n    } else {\r\n      bindContent = createBindContent(\r\n        this.binding, \r\n        this.id, \r\n        this.binding.engine, \r\n        this.binding.bindingState.pattern + \".*\", \r\n        listIndex);\r\n    }\r\n    // 登録\r\n    this.#bindContentByListIndex.set(listIndex, bindContent);\r\n    return bindContent;\r\n  }\r\n\r\n  deleteBindContent(bindContent: IBindContent): void {\r\n    bindContent.unmount();\r\n    bindContent.loopContext?.clearListIndex();\r\n  }\r\n\r\n  get bindContentLastIndex():number {\r\n    return this.#bindContentLastIndex;\r\n  }\r\n  set bindContentLastIndex(value:number) {\r\n    this.#bindContentLastIndex = value;\r\n  }\r\n\r\n  get poolLength():number {\r\n    return this.#bindContentPool.length;\r\n  }\r\n  set poolLength(length: number) {\r\n    if (length < 0) {\r\n      raiseError(`BindingNodeFor.setPoolLength: length is negative`);\r\n    }\r\n    this.#bindContentPool.length = length;\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError(`BindingNodeFor.assignValue: value is not array`);\r\n    }\r\n    const listIndexesSet = this.binding.engine.getListIndexesSet(\r\n      this.binding.bindingState.info, \r\n      this.binding.bindingState.listIndex\r\n    );\r\n    if (listIndexesSet === null) {\r\n      raiseError(`BindingNodeFor.assignValue: listIndexes is not found`);\r\n    }\r\n    this.bindContentLastIndex = this.poolLength - 1;\r\n    const newBindContensSet = new Set<IBindContent>();\r\n    let lastBindContent = null;\r\n    const parentNode = this.node.parentNode;\r\n    if (parentNode == null) {\r\n      raiseError(`BindingNodeFor.update: parentNode is null`);\r\n    }\r\n    for(const listIndex of listIndexesSet) {\r\n      const lastNode = lastBindContent?.getLastNode(parentNode) ?? this.node;\r\n      let bindContent = this.#bindContentByListIndex.get(listIndex);\r\n      if (typeof bindContent === \"undefined\") {\r\n        bindContent = this.createBindContent(listIndex);\r\n        bindContent.render();\r\n        bindContent.mountAfter(parentNode, lastNode);\r\n      } else {\r\n        if (lastNode.nextSibling !== bindContent.firstChildNode) {\r\n          bindContent.mountAfter(parentNode, lastNode);\r\n        }\r\n      }\r\n      newBindContensSet.add(bindContent);\r\n      lastBindContent = bindContent;\r\n    }\r\n    // プールの長さを更新する\r\n    // プールの長さは、プールの最後の要素のインデックス+1であるため、\r\n    this.poolLength = this.bindContentLastIndex + 1;\r\n    // 削除\r\n    const removeBindContentsSet = this.#bindContentsSet.difference(newBindContensSet);\r\n    for(const bindContent of removeBindContentsSet) {\r\n      this.deleteBindContent(bindContent);\r\n    }\r\n    this.#bindContentPool.push(...removeBindContentsSet);\r\n    this.#bindContentsSet = newBindContensSet;\r\n  }\r\n\r\n  /**\r\n   * SWAP処理を想定\r\n   * \r\n   * @param listIndexes \r\n   * @param values \r\n   * @returns \r\n   */\r\n  updateElements(listIndexes: IListIndex[], values: any[]) {\r\n    if (typeof values[0] !== \"object\") return;\r\n    const engine = this.binding.engine;\r\n    const oldListValues = \r\n      engine.getList(\r\n        this.binding.bindingState.info, \r\n        this.binding.bindingState.listIndex\r\n      ) ?? raiseError(`BindingNodeFor.updateElements: oldValues is not found`); \r\n    const parentNode = this.node.parentNode ?? raiseError(`BindingNodeFor.update: parentNode is null`);\r\n\r\n    // DOMから削除\r\n    const currentBindContents = Array.from(this.#bindContentsSet);\r\n    const targetBindContents: IBindContent[] = [];\r\n    for(let i = 0; i < listIndexes.length; i++) {\r\n      const listIndex = listIndexes[i];\r\n      const bindContent = currentBindContents[listIndex.index];\r\n      bindContent.unmount();\r\n      targetBindContents.push(bindContent);\r\n    }\r\n\r\n    // DOMに追加、listIndexを更新\r\n    for(let i = 0; i < listIndexes.length; i++) {\r\n      const listIndex = listIndexes[i];\r\n      const index = listIndex.index;\r\n\r\n      const lastBindContent = currentBindContents[index - 1] ?? null;\r\n      const lastNode = lastBindContent?.lastChildNode ?? this.node;\r\n\r\n      const oldValue = oldListValues[index];\r\n      const targetIndex = values.indexOf(oldValue);\r\n      const prevBindContent = targetBindContents[targetIndex];\r\n\r\n      if (typeof prevBindContent === \"undefined\") {\r\n        // 入れ替えるBindContentがない場合は再描画\r\n        const bindContent = targetBindContents[index];\r\n        bindContent.render();\r\n        bindContent.mountAfter(parentNode, lastNode);\r\n      } else {\r\n        prevBindContent.assignListIndex(listIndex);\r\n        prevBindContent.mountAfter(parentNode, lastNode);\r\n        this.#bindContentByListIndex.set(listIndex, prevBindContent);\r\n        currentBindContents[index] = prevBindContent;\r\n      }\r\n      if (targetIndex >= 0) {\r\n        values[targetIndex] = -1;\r\n      }\r\n    }\r\n    this.#bindContentsSet = new Set<IBindContent>(currentBindContents);\r\n    engine.saveList(\r\n      this.binding.bindingState.info, \r\n      this.binding.bindingState.listIndex, \r\n      this.binding.bindingState.value.slice(0)\r\n    );\r\n  }\r\n}\r\n\r\nexport const createBindingNodeFor: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeFor(binding, node, name, filterFns, event);\r\n  }\r\n","import { NodeType } from \"./types\";\r\n\r\nconst DEFAULT_PROPERTY = \"textContent\";\r\n\r\ntype DefaultPropertyByElementType = {\r\n  [key:string]: string;\r\n}\r\n\r\nconst defaultPropertyByElementType:DefaultPropertyByElementType = {\r\n  \"radio\"   : \"checked\",\r\n  \"checkbox\": \"checked\",\r\n  \"button\"  : \"onclick\",\r\n}\r\n\r\n/**\r\n * HTML要素のデフォルトプロパティを取得\r\n */\r\nconst getDefaultPropertyHTMLElement = (node:Node):string => \r\n  node instanceof HTMLSelectElement || node instanceof HTMLTextAreaElement || node instanceof HTMLOptionElement ? \"value\" : \r\n  node instanceof HTMLButtonElement ? \"onclick\" : \r\n  node instanceof HTMLAnchorElement ? \"onclick\" : \r\n  node instanceof HTMLFormElement ? \"onsubmit\" : \r\n  node instanceof HTMLInputElement ? (defaultPropertyByElementType[node.type] ?? \"value\") :\r\n  DEFAULT_PROPERTY;\r\n\r\ntype DefaultPropertyByKey = {\r\n  [key:string]: string | undefined;\r\n}\r\n\r\nconst _cache: DefaultPropertyByKey = {};\r\n\r\nconst textContentProperty = (node:Node):string => DEFAULT_PROPERTY;\r\n\r\ntype GetDefaultPropertyByNodeType = {\r\n  [key in NodeType]: ((node:Node)=>string) | undefined;\r\n}\r\n\r\nconst getDefaultPropertyByNodeType: GetDefaultPropertyByNodeType = {\r\n  HTMLElement: getDefaultPropertyHTMLElement,\r\n  SVGElement : undefined,\r\n  Text       : textContentProperty,\r\n  Template   : undefined,\r\n}\r\n\r\n/**\r\n * バインド情報でノードプロパティを省略された場合のデフォルトのプロパティ名を取得\r\n * @param node ノード\r\n * @param nodeType ノードタイプ\r\n * @returns {string | undefined} デフォルトのプロパティ名\r\n */\r\nexport function getDefaultName(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n): string | undefined {\r\n  const key = node.constructor.name + \"\\t\" + ((node as HTMLInputElement).type ?? \"\"); // type attribute\r\n  return _cache[key] ?? (_cache[key] = getDefaultPropertyByNodeType[nodeType]?.(node));\r\n}\r\n  ","\r\nconst symbolName = \"state\";\r\n\r\nexport const GetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.GetByRef`);\r\nexport const SetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.SetByRef`);\r\nexport const SetCacheableSymbol        : unique symbol = Symbol.for(`${symbolName}.SetCacheable`);\r\nexport const ConnectedCallbackSymbol   : unique symbol = Symbol.for(`${symbolName}.ConnectedCallback`);\r\nexport const DisconnectedCallbackSymbol: unique symbol = Symbol.for(`${symbolName}.DisconnectedCallback`);\r\nexport const ResolveSymbol             : unique symbol = Symbol.for(`${symbolName}.Resolve`);\r\nexport const GetAllSymbol              : unique symbol = Symbol.for(`${symbolName}.GetAll`);\r\n","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { getDefaultName } from \"../../BindingBuilder/getDefaultName\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { SetByRefSymbol } from \"../../StateClass/symbols\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nfunction isTwoWayBindable(element: HTMLElement): boolean {\r\n  return element instanceof HTMLInputElement || \r\n    element instanceof HTMLTextAreaElement || \r\n    element instanceof HTMLSelectElement;\r\n}\r\n\r\nconst defaultEventByName: {[key:string]: string} = {\r\n  \"value\"   : \"input\",\r\n  \"checked\" : \"change\",\r\n  \"selected\": \"change\",\r\n};\r\n\r\nclass BindingNodeProperty extends BindingNode {\r\n  get value(): any {\r\n    // @ts-ignore\r\n    return this.node[this.name];\r\n  }\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for(let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n\r\n    const isElement = this.node instanceof HTMLElement;\r\n    if (!isElement) return;\r\n    if (!isTwoWayBindable(this.node)) return;\r\n    const defaultName = getDefaultName(this.node, \"HTMLElement\");\r\n    if (defaultName !== this.name) return;\r\n    const eventName = this.event ?? defaultEventByName[this.name] ?? \"readonly\";\r\n    if (event === \"readonly\" || event === \"ro\") return;\r\n    this.node.addEventListener(eventName, () => {\r\n      const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n      const engine = this.binding.engine;\r\n      const stateProxy = engine.stateProxy;\r\n      const bindingState = this.binding.bindingState;\r\n      const value = this.filteredValue;\r\n      engine.updater.addProcess(() => {\r\n        if (loopContext) {\r\n          engine.setLoopContext(loopContext, async () => {\r\n            // @ts-ignore\r\n            stateProxy[SetByRefSymbol](bindingState.info, bindingState.listIndex, value);\r\n          });\r\n        } else {\r\n          // @ts-ignore\r\n          stateProxy[SetByRefSymbol](bindingState.info, bindingState.listIndex, value);\r\n        }\r\n\r\n      });\r\n    });\r\n\r\n  }\r\n\r\n  init() {\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    // @ts-ignore\r\n    this.node[this.name] = value;\r\n  }\r\n}\r\n\r\nexport const createBindingNodeProperty: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeProperty(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeRadio extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value.toString() === element.value.toString();\r\n  }\r\n}\r\n\r\nexport const createBindingNodeRadio: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeRadio(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode\";\r\nimport { CreateBindingNodeByNodeFn, CreateBindingNodeFn, IBindingNode } from \"./types\";\r\n\r\nclass BindingNodeStyle extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as HTMLElement;\r\n    element.style.setProperty(this.subName, value.toString());\r\n  }\r\n}\r\n\r\nexport const createBindingNodeStyle: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeStyle(binding, node, name, filterFns, event);\r\n  }\r\n","import { createBindingNodeAttribute } from \"../DataBinding/BindingNode/BindingNodeAttribute\";\r\nimport { createBindingNodeCheckbox } from \"../DataBinding/BindingNode/BindingNodeCheckbox\";\r\nimport { createBindingNodeClassList } from \"../DataBinding/BindingNode/BindingNodeClassList\";\r\nimport { createBindingNodeClassName } from \"../DataBinding/BindingNode/BindingNodeClassName\";\r\nimport { createBindingNodeEvent } from \"../DataBinding/BindingNode/BindingNodeEvent\";\r\nimport { createBindingNodeIf } from \"../DataBinding/BindingNode/BindingNodeIf\";\r\nimport { createBindingNodeFor } from \"../DataBinding/BindingNode/BindingNodeFor\";\r\nimport { createBindingNodeProperty } from \"../DataBinding/BindingNode/BindingNodeProperty\";\r\nimport { createBindingNodeRadio } from \"../DataBinding/BindingNode/BindingNodeRadio\";\r\nimport { createBindingNodeStyle } from \"../DataBinding/BindingNode/BindingNodeStyle\";\r\nimport { CreateBindingNodeByNodeFn, CreateBindingNodeFn } from \"../DataBinding/BindingNode/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IFilterText } from \"./types\";\r\n\r\ntype NodePropertyConstructorByName = {[key:string]:CreateBindingNodeFn};\r\ntype NodePropertyConstructorByNameByIsComment = {[key:number]:NodePropertyConstructorByName};\r\n\r\nconst nodePropertyConstructorByNameByIsComment:NodePropertyConstructorByNameByIsComment = {\r\n  0: {\r\n    \"class\"   : createBindingNodeClassList,\r\n    \"checkbox\": createBindingNodeCheckbox,\r\n    \"radio\"   : createBindingNodeRadio,\r\n  },\r\n  1: {\r\n    \"if\" : createBindingNodeIf,\r\n  },\r\n};\r\n\r\ntype NodePropertyConstructorByFirstName = {[key:string]:CreateBindingNodeFn};\r\n\r\nconst nodePropertyConstructorByFirstName:NodePropertyConstructorByFirstName = {\r\n  \"class\": createBindingNodeClassName,\r\n  \"attr\" : createBindingNodeAttribute,\r\n  \"style\": createBindingNodeStyle,\r\n//  \"props\": ComponentProperty,\r\n//  \"popover\": PopoverTarget,\r\n//  \"commandfor\": CommandForTarget,\r\n};\r\n\r\nfunction _getBindingNodeCreator(isComment:boolean, isElement: boolean, propertyName: string): CreateBindingNodeFn {\r\n  const bindingNodeCreatorByName = nodePropertyConstructorByNameByIsComment[isComment ? 1 : 0][propertyName];\r\n  if (typeof bindingNodeCreatorByName !== \"undefined\") {\r\n    return bindingNodeCreatorByName;\r\n  }\r\n  if (isComment && propertyName === \"for\") {\r\n    return createBindingNodeFor;\r\n  }\r\n  if (isComment) {\r\n    raiseError(`getBindingNodeCreator: unknown node property ${propertyName}`);\r\n  }\r\n  const nameElements = propertyName.split(\".\");\r\n  const bindingNodeCreatorByFirstName = nodePropertyConstructorByFirstName[nameElements[0]];\r\n  if (typeof bindingNodeCreatorByFirstName !== \"undefined\") {\r\n    return bindingNodeCreatorByFirstName;\r\n  }\r\n  if (isElement) {\r\n    if (propertyName.startsWith(\"on\")) {\r\n      return createBindingNodeEvent;\r\n    } else {\r\n      return createBindingNodeProperty;\r\n    }\r\n  } else {\r\n    return createBindingNodeProperty;\r\n  }\r\n}\r\n\r\nconst _cache: {[key:string]:CreateBindingNodeFn} = {};\r\n\r\n/**\r\n * バインドのノードプロパティの生成関数を取得する\r\n * @param node ノード\r\n * @param propertyName プロパティ名\r\n * @returns {CreateBindingNodeFn} ノードプロパティのコンストラクタ\r\n */\r\nexport function getBindingNodeCreator(\r\n  node        : Node, \r\n  propertyName: string,\r\n  filterTexts: IFilterText[],\r\n  event       : string | null\r\n): CreateBindingNodeByNodeFn {\r\n  const isComment = node instanceof Comment;\r\n  const isElement = node instanceof Element;\r\n  const key = isComment + \"\\t\" + isElement + \"\\t\" + propertyName;\r\n  const fn = _cache[key] ?? (_cache[key] = _getBindingNodeCreator(isComment, isElement, propertyName));\r\n  return fn(propertyName, filterTexts, event);\r\n}\r\n","import { raiseError } from '../utils';\r\nimport { getResolvedPathInfo } from './getResolvedPathInfo';\r\nimport { IResolvedPathInfo, IStructuredPathInfo } from './types';\r\n\r\n/**\r\n * プロパティ名に\"constructor\"や\"toString\"などの予約語やオブジェクトのプロパティ名を\r\n * 上書きするような名前も指定できるように、Mapを検討したが、そもそもそのような名前を\r\n * 指定することはないと考え、Mapを使わないことにした。\r\n */\r\nconst _cache: { [key:string]: IStructuredPathInfo } = {};\r\n//const _cache: Map<string, IStructuredPathInfo> = new Map();\r\n\r\n/**\r\n * パターン情報を取得します\r\n * @param pattern パターン\r\n * @returns {IPatternInfo} パターン情報\r\n */\r\nclass StructuredPathInfo implements IStructuredPathInfo {\r\n  static id = 0;\r\n  id = ++StructuredPathInfo.id;\r\n  pattern;\r\n  pathSegments;\r\n  lastSegment;\r\n  cumulativePaths;\r\n  cumulativeInfos;\r\n  wildcardPaths;\r\n  wildcardInfos;\r\n  wildcardParentPaths;\r\n  wildcardParentInfos;\r\n  lastWildcardPath;\r\n  lastWildcardInfo;\r\n  parentPath;\r\n  parentInfo;\r\n  wildcardCount;\r\n\r\n  constructor(pattern: string) {\r\n    const getPattern = (_pattern: string): IStructuredPathInfo => {\r\n      return (pattern === _pattern) ? this : getStructuredPathInfo(_pattern);\r\n    };\r\n    const pathSegments = pattern.split(\".\");\r\n    const cumulativePaths = [];\r\n    const cumulativeInfos: IStructuredPathInfo[] = [];\r\n    const wildcardPaths = [];\r\n    const wildcardInfos = [];\r\n    const wildcardParentPaths = [];\r\n    const wildcardParentInfos = [];\r\n    let currentPatternPath = \"\", prevPatternPath = \"\";\r\n    let wildcardCount = 0;\r\n    for(let i = 0; i < pathSegments.length; i++) {\r\n      currentPatternPath += pathSegments[i];\r\n      if (pathSegments[i] === \"*\") {\r\n        wildcardPaths.push(currentPatternPath);\r\n        wildcardInfos.push(getPattern(currentPatternPath));\r\n        wildcardParentPaths.push(prevPatternPath);\r\n        wildcardParentInfos.push(getPattern(prevPatternPath));\r\n        wildcardCount++;\r\n      }\r\n      cumulativePaths.push(currentPatternPath);\r\n      cumulativeInfos.push(getPattern(currentPatternPath));\r\n      prevPatternPath = currentPatternPath;\r\n      currentPatternPath += \".\";\r\n    }\r\n    const lastWildcardPath = wildcardPaths.length > 0 ? wildcardPaths[wildcardPaths.length - 1] : null;\r\n    const parentPath = cumulativePaths.length > 1 ? cumulativePaths[cumulativePaths.length - 2] : null;\r\n    this.pattern = pattern;\r\n    this.pathSegments = pathSegments;\r\n    this.lastSegment = pathSegments[pathSegments.length - 1];\r\n    this.cumulativePaths = cumulativePaths;\r\n    this.cumulativeInfos = cumulativeInfos;\r\n    this.wildcardPaths = wildcardPaths;\r\n    this.wildcardInfos = wildcardInfos;\r\n    this.wildcardParentPaths = wildcardParentPaths;\r\n    this.wildcardParentInfos = wildcardParentInfos;\r\n    this.lastWildcardPath = lastWildcardPath;\r\n    this.lastWildcardInfo = lastWildcardPath ? getPattern(lastWildcardPath) : null;\r\n    this.parentPath = parentPath;\r\n    this.parentInfo = parentPath ? getPattern(parentPath) : null;\r\n    this.wildcardCount = wildcardCount;\r\n  }\r\n}\r\n\r\nconst reservedWords = new Set([\r\n  \"constructor\", \"prototype\", \"__proto__\", \"toString\",\r\n  \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",\r\n  \"watch\", \"unwatch\", \"eval\", \"arguments\",\r\n  \"let\", \"var\", \"const\", \"class\", \"function\",\r\n  \"null\", \"true\", \"false\", \"new\", \"return\",\r\n]);\r\n\r\nexport function getStructuredPathInfo(structuredPath: string): IStructuredPathInfo {\r\n  let info: IStructuredPathInfo | undefined;\r\n  info = _cache[structuredPath];\r\n  if (typeof info !== \"undefined\") {\r\n    return info;\r\n  }\r\n  if (reservedWords.has(structuredPath)) {\r\n    raiseError(`getStructuredPathInfo: pattern is reserved word: ${structuredPath}`);\r\n  }\r\n  return (_cache[structuredPath] = new StructuredPathInfo(structuredPath));\r\n}\r\n","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { GetByRefSymbol } from \"../../StateClass/symbols\";\r\nimport { IStateProxy } from \"../../StateClass/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\nclass BindingState implements IBindingState {\r\n  #binding     : IBinding;\r\n  #pattern     : string;\r\n  #info        : IStructuredPathInfo;\r\n  #listIndexRef: WeakRef<IListIndex> | null = null;\r\n  #state       : IStateProxy;\r\n  #filters     : Filters;\r\n  get pattern(): string {\r\n    return this.#pattern;\r\n  }\r\n  get info() {\r\n    return this.#info;\r\n  }\r\n  get listIndex() {\r\n    if (this.#listIndexRef === null) return null;\r\n    return this.#listIndexRef.deref() ?? raiseError(\"listIndex is null\");\r\n  }\r\n  get state() {\r\n    return this.#state;\r\n  }\r\n  get filters() {\r\n    return this.#filters;\r\n  }\r\n  get binding() {\r\n    return this.#binding;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    state  : IStateProxy, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this.#binding = binding;\r\n    this.#pattern = pattern;\r\n    this.#info = getStructuredPathInfo(pattern);\r\n    this.#state = state;\r\n    this.#filters = filters;\r\n  }\r\n  get value(): any {\r\n    return this.#state[GetByRefSymbol](this.info, this.listIndex);\r\n  }\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for(let i = 0; i < this.#filters.length; i++) {\r\n      value = this.#filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  init(): void {\r\n    if (this.info.wildcardCount > 0) {\r\n      const lastWildcardPath = this.info.lastWildcardPath ?? \r\n        raiseError(`BindingState.init: wildcardLastParentPath is null`);\r\n      const loopContext = this.binding.parentBindContent.loopContext?.find(lastWildcardPath) ?? \r\n        raiseError(`BindingState.init: loopContext is null`);\r\n      this.#listIndexRef = loopContext.listIndexRef;\r\n    }\r\n    this.binding.engine.saveBinding(this.info, this.listIndex, this.binding);\r\n  }\r\n}\r\n\r\nexport const createBindingState: CreateBindingStateFn = \r\n(name: string, filterTexts: IFilterText[]) => \r\n  (binding:IBinding, state: IStateProxy, filters:FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts); // ToDo:ここは、メモ化できる\r\n    return new BindingState(binding, state, name, filterFns);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStateProxy } from \"../../StateClass/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\nclass BindingStateIndex implements IBindingState {\r\n  #binding     : IBinding;\r\n  #indexNumber : number;\r\n  #listIndexRef: WeakRef<IListIndex> | null = null;\r\n  #state       : IStateProxy;\r\n  #filters     : Filters;\r\n  get pattern(): string {\r\n    return raiseError(\"Not implemented\");\r\n  }\r\n  get info() {\r\n    return raiseError(\"Not implemented\");\r\n  }\r\n  get listIndex() {\r\n    if (this.#listIndexRef === null) return null;\r\n    return this.#listIndexRef.deref() ?? raiseError(\"listIndex is null\");\r\n  }\r\n  get state() {\r\n    return this.#state;\r\n  }\r\n  get filters() {\r\n    return this.#filters;\r\n  }\r\n  get binding() {\r\n    return this.#binding;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    state  : IStateProxy, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this.#binding = binding;\r\n    const indexNumber = Number(pattern.slice(1));\r\n    if (isNaN(indexNumber)) {\r\n      raiseError(\"BindingStateIndex: pattern is not a number\");\r\n    }\r\n    this.#indexNumber = indexNumber;\r\n    this.#state = state;\r\n    this.#filters = filters;\r\n  }\r\n  get value(): any {\r\n    return this.listIndex?.index ?? raiseError(\"listIndex is null\");\r\n  }\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for(let i = 0; i < this.#filters.length; i++) {\r\n      value = this.#filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  init(): void {\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext ??\r\n      raiseError(`BindingState.init: loopContext is null`);\r\n    const loopContexts = loopContext.serialize();\r\n    this.#listIndexRef = loopContexts[this.#indexNumber - 1].listIndexRef ??\r\n      raiseError(`BindingState.init: listIndexRef is null`);\r\n    const listIndex = this.listIndex ?? raiseError(\"listIndex is null\");\r\n    const bindings = this.binding.engine.bindingsByListIndex.get(listIndex);\r\n    if (bindings === undefined) {\r\n      this.binding.engine.bindingsByListIndex.set(listIndex, new Set([this.binding]));\r\n    } else {\r\n      bindings.add(this.binding);\r\n    }\r\n  }\r\n}\r\n\r\nexport const createBindingStateIndex: CreateBindingStateFn = \r\n(name: string, filterTexts: IFilterText[]) => \r\n  (binding:IBinding, state: IStateProxy, filters:FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts); // ToDo:ここは、メモ化できる\r\n\r\n    return new BindingStateIndex(binding, state, name, filterFns);\r\n  }\r\n","import { createBindingState } from \"../DataBinding/BindingState/BindingState\";\r\nimport { createBindingStateIndex } from \"../DataBinding/BindingState/BindingStateIndex\";\r\nimport { CreateBindingStateByStateFn } from \"../DataBinding/BindingState/types\";\r\nimport { IFilterText } from \"./types\";\r\n\r\nconst ereg = new RegExp(/^\\$\\d+$/);\r\n\r\nexport function getBindingStateCreator(\r\n  name       : string, \r\n  filterTexts: IFilterText[]\r\n): CreateBindingStateByStateFn {\r\n  if (ereg.test(name)) {\r\n    return createBindingStateIndex(name, filterTexts);\r\n  } else {\r\n    return createBindingState(name, filterTexts);\r\n  }\r\n}","import { COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants\";\r\nimport { getTemplateById } from \"../Template/registerTemplate\";\r\nimport { raiseError } from \"../utils\";\r\nimport { NodeType } from \"./types\";\r\n\r\nconst COMMENT_EMBED_MARK_LEN = COMMENT_EMBED_MARK.length;\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\nconst getTextFromContent   = (node:Node):string        => node.textContent?.slice(COMMENT_EMBED_MARK_LEN).trim() ?? \"\";\r\nconst getTextFromAttribute = (node:HTMLElement):string => node.getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\nconst getTextFromTemplate  = (node:Node):string        => {\r\n  const text = node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN).trim(); \r\n  const id = Number(text);\r\n  const template = getTemplateById(id) ?? raiseError(`Template not found: ${text}`);\r\n  return template.getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n};\r\nconst getTextFromSVGElement = (node:SVGElement):string => node.getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n\r\nconst getTextByNodeType = {\r\n  \"Text\":        getTextFromContent,\r\n  \"HTMLElement\": getTextFromAttribute,\r\n  \"Template\":    getTextFromTemplate,\r\n  \"SVGElement\":  getTextFromSVGElement\r\n};\r\n\r\nexport function getDataBindText(nodeType: NodeType, node: Node): string {\r\n  const bindText = getTextByNodeType[nodeType](node as any) ?? \"\";\r\n  if (nodeType === \"Text\") {\r\n    return \"textContent:\" + bindText;\r\n  } else {\r\n    return bindText;\r\n  }\r\n}\r\n","import { raiseError } from \"../utils\";\r\nimport { NodeType } from \"./types\";\r\n\r\nconst createNodeKey = (node:Node):string => node.constructor.name + \"\\t\" + ((node instanceof Comment) ? (node.textContent?.[2] ?? \"\") : \"\");\r\n\r\ntype NodeTypeByNodeKey = {\r\n  [nodeKey:string]:NodeType;\r\n};\r\n\r\nconst nodeTypeByNodeKey:NodeTypeByNodeKey = {};\r\n\r\nconst getNodeTypeByNode = (node:Node):NodeType =>\r\n  (node instanceof Comment && node.textContent?.[2] === \":\") ? \"Text\" : \r\n  (node instanceof HTMLElement) ? \"HTMLElement\" :\r\n  (node instanceof Comment && node.textContent?.[2] === \"|\") ? \"Template\" : \r\n  (node instanceof SVGElement) ? \"SVGElement\" : raiseError(`Unknown NodeType: ${node.nodeType}`);\r\n\r\n/**\r\n * ノードのタイプを取得\r\n * @param node ノード\r\n * @param nodeKey ノードキー\r\n * @returns {NodeType} ノードタイプ\r\n */\r\nexport function getNodeType(\r\n  node   : Node, \r\n  nodeKey: string = createNodeKey(node)\r\n): NodeType {\r\n  return nodeTypeByNodeKey[nodeKey] ?? (nodeTypeByNodeKey[nodeKey] = getNodeTypeByNode(node));\r\n}\r\n","import { IFilterText, IBindText } from \"./types\";\r\n\r\nconst trim = (s:string):string => s.trim();\r\n\r\nconst has = (s:string):boolean => s.length > 0; // check length\r\n\r\nconst re = new RegExp(/^#(.*)#$/);\r\nconst decode = (s:string):string => {\r\n  const m = re.exec(s);\r\n  return m ? decodeURIComponent(m[1]) : s;\r\n};\r\n\r\n/**\r\n * parse filter part\r\n * \"eq,100|falsey\" ---> [Filter(eq, [100]), Filter(falsey)]\r\n */\r\nconst parseFilter = (text:string): IFilterText => {\r\n  const [name, ...options] = text.split(\",\").map(trim);\r\n  return {name, options:options.map(decode)};\r\n};\r\n\r\ntype ReturnParseStateProperty = {property:string,filters:IFilterText[]};\r\n/**\r\n * parse expression\r\n * \"value|eq,100|falsey\" ---> [\"value\", Filter[]]\r\n */\r\nconst parseProperty = (text:string): ReturnParseStateProperty => {\r\n  const [property, ...filterTexts] = text.split(\"|\").map(trim);\r\n  return {property, filters:filterTexts.map(parseFilter)};\r\n};\r\n\r\n/**\r\n * parse expressions\r\n * \"textContent:value|eq,100|falsey\" ---> [\"textContent\", \"value\", Filter[eq, falsey]]\r\n */\r\nconst parseExpression = (expression:string): IBindText => {\r\n  const [ bindExpression, event = null ] = expression.split(\"@\").map(trim);\r\n  const [nodePropertyText, statePropertyText] = bindExpression.split(\":\").map(trim);\r\n  const { property:nodeProperty, filters:inputFilterTexts } = parseProperty(nodePropertyText);\r\n  const { property:stateProperty, filters:outputFilterTexts } = parseProperty(statePropertyText);\r\n  return { nodeProperty, stateProperty, inputFilterTexts, outputFilterTexts, event };\r\n};\r\n\r\n/**\r\n * parse bind text and return BindText[]\r\n */\r\nconst parseExpressions = (text:string): IBindText[] => {\r\n  return text.split(\";\").map(trim).filter(has).map(s => parseExpression(s));\r\n};\r\n\r\nconst cache:{[key:string]: IBindText[]} = {};\r\n\r\n/**\r\n * 取得したバインドテキスト(getBindTextByNodeType)を解析して、バインド情報を取得する\r\n * @param text バインドテキスト\r\n * @param defaultName デフォルト名\r\n * @returns {IBindText[]} バインド情報\r\n */\r\nexport function parseBindText(\r\n  text: string\r\n): IBindText[] {\r\n  if (text.trim() === \"\") {\r\n    return [];\r\n  }\r\n  return cache[text] ?? (cache[text] = parseExpressions(text));\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\nconst DATASET_BIND_PROPERTY = 'data-bind';\r\n\r\nconst removeAttributeFromElement = (node:Node):void => {\r\n  const element = node as Element;\r\n  element.removeAttribute(DATASET_BIND_PROPERTY);\r\n}\r\n\r\ntype RemoveAttributeByNodeType = {\r\n  [key in NodeType]: ((node:Node)=>void) | undefined;\r\n}\r\n\r\nconst removeAttributeByNodeType:RemoveAttributeByNodeType = {\r\n  HTMLElement: removeAttributeFromElement,\r\n  SVGElement : removeAttributeFromElement,\r\n  Text       : undefined,\r\n  Template   : undefined,\r\n}\r\n\r\n/**\r\n * ノードからdata-bind属性を削除\r\n * @param node ノード\r\n * @param nodeType ノードタイプ\r\n * @returns {Node} ノード\r\n */\r\nexport function removeDataBindAttribute(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n):void {\r\n  return removeAttributeByNodeType[nodeType]?.(node);\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\nconst replaceTextNodeText = (node:Node):Node => {\r\n  const textNode = document.createTextNode(\"\");\r\n  node.parentNode?.replaceChild(textNode, node);\r\n  return textNode;\r\n}\r\n\r\ntype ReplaceTextNodeFn = {\r\n  [key in NodeType]: ((node:Node)=>Node) | undefined;\r\n}\r\n\r\nconst replaceTextNodeFn:ReplaceTextNodeFn = {\r\n  Text       : replaceTextNodeText,\r\n  HTMLElement: undefined,\r\n  Template   : undefined,\r\n  SVGElement : undefined\r\n}\r\n\r\n/**\r\n * コメントノードをテキストノードに置き換える\r\n * @param node ノード\r\n * @param nodeType ノードタイプ\r\n * @returns {Node} ノード\r\n */\r\nexport function replaceTextNodeFromComment(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n): Node {\r\n  return replaceTextNodeFn[nodeType]?.(node) ?? node;\r\n}\r\n","import { getAbsoluteNodePath } from \"./getAbsoluteNodePath\";\r\nimport { getBindingNodeCreator } from \"./getBindingNodeCreator\";\r\nimport { getBindingStateCreator } from \"./getBindingStateCreator\";\r\nimport { getDataBindText } from \"./getDataBindText\";\r\nimport { getNodeType } from \"./getNodeType\";\r\nimport { parseBindText } from \"./parseBindText\";\r\nimport { removeDataBindAttribute } from \"./removeDataBindAttribute\";\r\nimport { replaceTextNodeFromComment } from \"./replaceTextNodeFromComment\";\r\nimport { IBindingCreator, IBindText, IDataBindAttributes, NodePath, NodeType } from \"./types\";\r\n\r\nclass DataBindAttributes implements IDataBindAttributes {\r\n  nodeType     : NodeType; // ノードの種別\r\n  nodePath     : NodePath; // ノードのルート\r\n  bindTexts    : IBindText[]; // BINDテキストの解析結果\r\n  creatorByText: Map<IBindText, IBindingCreator> = new Map(); // BINDテキストからバインディングクリエイターを取得\r\n  constructor(node: Node) {\r\n    this.nodeType = getNodeType(node);\r\n    const text = getDataBindText(this.nodeType, node);\r\n    // CommentNodeをTextに置換、template.contentの内容が書き換わることに注意\r\n    node = replaceTextNodeFromComment(node, this.nodeType);\r\n    // data-bind属性を削除する\r\n    removeDataBindAttribute(node, this.nodeType);\r\n\r\n    this.nodePath = getAbsoluteNodePath(node);\r\n    this.bindTexts = parseBindText(text);\r\n    for(let i = 0; i < this.bindTexts.length; i++) {\r\n      const bindText = this.bindTexts[i];\r\n      const creator: IBindingCreator = {\r\n        createBindingNode : getBindingNodeCreator(\r\n          node, \r\n          bindText.nodeProperty, \r\n          bindText.inputFilterTexts,\r\n          bindText.event\r\n        ),\r\n        createBindingState: getBindingStateCreator(\r\n          bindText.stateProperty, \r\n          bindText.outputFilterTexts\r\n        ),\r\n      }\r\n      this.creatorByText.set(bindText, creator);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport function createDataBindAttributes(node: Node): IDataBindAttributes {\r\n  return new DataBindAttributes(node);\r\n}","import { NodePath } from \"./types\";\r\n\r\nexport function getAbsoluteNodePath(node: Node): NodePath {\r\n  let routeIndexes: NodePath = [];\r\n  while(node.parentNode !== null) {\r\n    const childNodes = Array.from(node.parentNode.childNodes) as Node[];\r\n    routeIndexes = [ childNodes.indexOf(node), ...routeIndexes ];\r\n    node = node.parentNode;\r\n  }\r\n  return routeIndexes;\r\n}","import { DATA_BIND_ATTRIBUTE, COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK } from \"../constants\";\r\n\r\n/**\r\n * \"@@:\"もしくは\"@@|\"で始まるコメントノードを取得する\r\n */\r\nfunction isCommentNode(node: Node): boolean {\r\n  return node instanceof Comment && (\r\n    (node.textContent?.indexOf(COMMENT_EMBED_MARK) === 0) || (node.textContent?.indexOf(COMMENT_TEMPLATE_MARK) === 0)\r\n  );\r\n} \r\n\r\nexport function getNodesHavingDataBind(root: Node): Node[] {\r\n  const nodes: Node[] = [];\r\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, {\r\n    acceptNode(node:Node) {\r\n      return (node instanceof Element) ? \r\n        (node.hasAttribute(DATA_BIND_ATTRIBUTE) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP)\r\n        : (isCommentNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\r\n    }\r\n  });\r\n  while (walker.nextNode()) {\r\n    nodes.push(walker.currentNode);\r\n  }\r\n  return nodes;\r\n}\r\n\r\n","import { createDataBindAttributes } from \"./createDataBindAttributes\";\r\nimport { getNodesHavingDataBind } from \"./getNodesHavingDataBind\";\r\nimport { IDataBindAttributes } from \"./types\";\r\n\r\nconst listDataBindAttributesById: {[key:number]:IDataBindAttributes[]} = {};\r\n\r\nconst listPathsSetById: {[key:number]:Set<string>} = {};\r\n\r\nconst pathsSetById: {[key:number]:Set<string>} = {};\r\n\r\nfunction getDataBindAttributesFromTemplate(content: DocumentFragment): IDataBindAttributes[] {\r\n  const nodes = getNodesHavingDataBind(content);\r\n  return nodes.map(node => createDataBindAttributes(node));\r\n}\r\n\r\nexport function registerDataBindAttributes(\r\n  id     : number, \r\n  content: DocumentFragment,\r\n  rootId : number = id\r\n): IDataBindAttributes[] {\r\n  const dataBindAttributes = getDataBindAttributesFromTemplate(content);\r\n  const paths = pathsSetById[rootId] ?? (pathsSetById[rootId] = new Set<string>());\r\n  const listPaths = listPathsSetById[rootId] ?? (listPathsSetById[rootId] = new Set<string>());\r\n  for(let i = 0; i < dataBindAttributes.length; i++) {\r\n    const attribute = dataBindAttributes[i];\r\n    for(let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      paths.add(bindText.stateProperty);\r\n      if (bindText.nodeProperty === \"for\") {\r\n        listPaths.add(bindText.stateProperty);\r\n      }\r\n    }\r\n  }\r\n  return listDataBindAttributesById[id] = dataBindAttributes;\r\n}\r\n\r\nexport const getDataBindAttributesById = (id: number): IDataBindAttributes[] => {\r\n  return listDataBindAttributesById[id];\r\n}\r\n\r\nexport const getListPathsSetById = (id: number): Set<string> => {\r\n  return listPathsSetById[id] ?? [];\r\n};\r\n\r\nexport const getPathsSetById = (id: number): Set<string> => {\r\n  return pathsSetById[id] ?? [];\r\n};","import { registerDataBindAttributes } from \"../BindingBuilder/registerDataBindAttributes\";\r\nimport { raiseError } from \"../utils\";\r\nimport { removeEmptyTextNodes } from \"./removeEmptyTextNodes\";\r\n\r\nconst templateById:Record<number, HTMLTemplateElement> = {};\r\n\r\nexport function registerTemplate(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number\r\n): number {\r\n  removeEmptyTextNodes(template.content);\r\n  registerDataBindAttributes(id, template.content, rootId);  \r\n  templateById[id] = template;\r\n  return id;\r\n}\r\n\r\nexport function getTemplateById(id: number): HTMLTemplateElement {\r\n  return templateById[id] ?? raiseError(`getTemplateById: template not found: ${id}`);\r\n}","\r\nexport function removeEmptyTextNodes(content:DocumentFragment):void {\r\n  Array.from(content.childNodes).forEach(node => {\r\n    if (node.nodeType === Node.TEXT_NODE && !(node.nodeValue ?? \"\").trim()) {\r\n      content.removeChild(node);\r\n    }\r\n  });  \r\n}\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { CreateBindingNodeByNodeFn, IBindingNode } from \"./BindingNode/types\";\r\nimport { CreateBindingStateByStateFn, IBindingState } from \"./BindingState/types\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\n\r\nclass Binding implements IBinding {\r\n  parentBindContent: IBindContent;\r\n  node             : Node;\r\n  engine           : IComponentEngine;\r\n  bindingNode      : IBindingNode;\r\n  bindingState     : IBindingState;\r\n  constructor(\r\n    parentBindContent : IBindContent,\r\n    node              : Node,\r\n    engine            : IComponentEngine,\r\n    createBindingNode : CreateBindingNodeByNodeFn, \r\n    createBindingState: CreateBindingStateByStateFn,\r\n  ) {\r\n    this.parentBindContent = parentBindContent\r\n    this.node = node;\r\n    this.engine = engine\r\n    this.bindingNode = createBindingNode(this, node, engine.inputFilters);\r\n    this.bindingState = createBindingState(this, engine.stateProxy, engine.outputFilters);\r\n  }\r\n\r\n  get bindContents() {\r\n    return this.bindingNode.bindContents;\r\n  }\r\n\r\n  init() {\r\n    this.bindingNode.init();\r\n    this.bindingState.init();\r\n  }\r\n\r\n  render() {\r\n    this.bindingNode.update();\r\n  }\r\n}\r\n\r\nexport function createBinding(\r\n  parentBindContent : IBindContent,\r\n  node              : Node, \r\n  engine            : IComponentEngine, \r\n  createBindingNode : CreateBindingNodeByNodeFn, \r\n  createBindingState: CreateBindingStateByStateFn\r\n): IBinding {\r\n  return new Binding(\r\n    parentBindContent, \r\n    node, \r\n    engine, \r\n    createBindingNode, \r\n    createBindingState\r\n  );\r\n}","import { IBindContent } from \"../DataBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { ILoopContext } from \"./types\";\r\n\r\nclass LoopContext implements ILoopContext {\r\n  #path     : string;\r\n  #info        : IStructuredPathInfo;\r\n  #listIndexRef: WeakRef<IListIndex> | null;\r\n  #bindContent : IBindContent;\r\n  constructor(\r\n    path    : string | null,\r\n    listIndex  : IListIndex,\r\n    bindContent: IBindContent\r\n  ) {\r\n    this.#path = path ?? raiseError(\"name is required\");\r\n    this.#info = getStructuredPathInfo(this.#path);\r\n    this.#listIndexRef = new WeakRef(listIndex);\r\n    this.#bindContent = bindContent;\r\n  }\r\n  get path(): string {\r\n    return this.#path;\r\n  }\r\n  get info(): IStructuredPathInfo {\r\n    return this.#info;\r\n  }\r\n  get listIndex(): IListIndex {\r\n    return this.#listIndexRef?.deref() ?? raiseError(\"listIndex is null\");\r\n  }\r\n  get listIndexRef(): WeakRef<IListIndex> {\r\n    return this.#listIndexRef ?? raiseError(\"listIndexRef is null\");\r\n  }\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    this.#listIndexRef = new WeakRef(listIndex);\r\n    // 構造は変わらないので、#parentLoopContext、#cacheはクリアする必要はない\r\n  }\r\n  clearListIndex():void {\r\n    this.#listIndexRef = null;\r\n  }\r\n  get bindContent(): IBindContent {\r\n    return this.#bindContent;\r\n  }\r\n\r\n  #parentLoopContext: ILoopContext | null | undefined;\r\n  get parentLoopContext(): ILoopContext | null {\r\n    if (typeof this.#parentLoopContext === \"undefined\") {\r\n      let currentBinding: IBindContent | null = this.bindContent;\r\n      while(currentBinding !== null) {\r\n        if (currentBinding.loopContext !== null && currentBinding.loopContext !== this) {\r\n          this.#parentLoopContext = currentBinding.loopContext;\r\n          break;\r\n        }\r\n        currentBinding = currentBinding.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      if (typeof this.#parentLoopContext === \"undefined\") this.#parentLoopContext = null;\r\n    }\r\n    return this.#parentLoopContext;\r\n  }\r\n\r\n  #cache:Record<string, ILoopContext | null> = {};\r\n  find(name: string): ILoopContext | null {\r\n    let loopContext = this.#cache[name];\r\n    if (typeof loopContext === \"undefined\") {\r\n      let currentLoopContext: ILoopContext | null = this;\r\n      while(currentLoopContext !== null) {\r\n        if (currentLoopContext.path === name) break;\r\n        currentLoopContext = currentLoopContext.parentLoopContext;\r\n      }\r\n      loopContext = this.#cache[name] = currentLoopContext;\r\n    }\r\n    return loopContext;\r\n  }\r\n\r\n  walk(callback: (loopContext: ILoopContext) => void): void {\r\n    let currentLoopContext: ILoopContext | null = this;\r\n    while(currentLoopContext !== null) {\r\n      callback(currentLoopContext);\r\n      currentLoopContext = currentLoopContext.parentLoopContext;\r\n    }\r\n  }\r\n\r\n  serialize(): ILoopContext[] {\r\n    const results: ILoopContext[] = [];\r\n    this.walk((loopContext) => {\r\n      results.unshift(loopContext);\r\n    });\r\n    return results;\r\n  }\r\n\r\n}\r\n\r\n// 生成されたあと、IBindContentのloopContextに登録される\r\n// IBindContentにずっと保持される\r\nexport function createLoopContext(\r\n  pattern: string | null,\r\n  listIndex: IListIndex,\r\n  bindContent: IBindContent\r\n): ILoopContext {\r\n  return new LoopContext(pattern, listIndex, bindContent);\r\n}","import { IBinding } from \"../DataBinding/types\";\r\n\r\nexport function render(bindings: IBinding[]) {\r\n  const bindingsWithSelectElement = [];\r\n  for(let i = 0; i < bindings.length; i++) {\r\n    const binding = bindings[i];\r\n    if (binding.bindingNode.isSelectElement) {\r\n      bindingsWithSelectElement.push(binding);\r\n    } else {\r\n      binding.render();\r\n    }\r\n  }\r\n  for(let i = 0; i < bindingsWithSelectElement.length; i++) {\r\n    bindingsWithSelectElement[i].render();\r\n  }\r\n}\r\n","import { resolveNodeFromPath } from \"../BindingBuilder/resolveNodeFromPath\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { getTemplateById } from \"../Template/registerTemplate\";\r\nimport { raiseError } from \"../utils\";\r\nimport { createBinding } from \"./Binding\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\nimport { createLoopContext } from \"../LoopContext/createLoopContext\";\r\nimport { render } from \"../Render/render\";\r\nimport { getDataBindAttributesById } from \"../BindingBuilder/registerDataBindAttributes\";\r\n\r\nfunction createContent(id: number): DocumentFragment {\r\n  const template = getTemplateById(id) ?? \r\n    raiseError(`BindContent: template is not found: ${id}`);\r\n  return document.importNode(template.content, true);\r\n}\r\n\r\nfunction createBindings(\r\n  bindContent: IBindContent, \r\n  id         : number, \r\n  engine     : IComponentEngine, \r\n  content    : DocumentFragment\r\n): IBinding[] {\r\n  const attributes = getDataBindAttributesById(id) ?? \r\n    raiseError(`BindContent: data-bind is not set`);\r\n  const bindings: IBinding[] = [];\r\n  for(let i = 0; i < attributes.length; i++) {\r\n    const attribute = attributes[i];\r\n    const node = resolveNodeFromPath(content, attribute.nodePath) ?? \r\n      raiseError(`BindContent: node is not found: ${attribute.nodePath}`);\r\n    for(let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      const creator = attribute.creatorByText.get(bindText) ?? \r\n        raiseError(`BindContent: creator is not found: ${bindText}`);\r\n      const binding = createBinding(\r\n        bindContent, \r\n        node, \r\n        engine, \r\n        creator.createBindingNode, \r\n        creator.createBindingState\r\n      );\r\n      bindings.push(binding);\r\n    }\r\n  }\r\n  return bindings;\r\n}\r\n\r\nclass BindContent implements IBindContent {\r\n  loopContext  : ILoopContext | null;\r\n  parentBinding: IBinding | null;\r\n  childNodes   : Node[];\r\n  fragment     : DocumentFragment;\r\n  engine       : IComponentEngine | undefined;\r\n  #id;\r\n  get id() {\r\n    return this.#id;\r\n  }\r\n  get isMounted() {\r\n    return this.childNodes.length > 0 && this.childNodes[0].parentNode !== this.fragment;\r\n  }\r\n  get firstChildNode() {\r\n    return this.childNodes[0] ?? null;\r\n  }\r\n  get lastChildNode() {\r\n    return this.childNodes[this.childNodes.length - 1] ?? null;\r\n  }\r\n  getLastNode(parentNode: Node): Node | null {\r\n    const lastBinding = this.bindings[this.bindings.length - 1];\r\n    const lastChildNode = this.lastChildNode;\r\n    if (lastBinding.node === lastChildNode) {\r\n      if (lastBinding.bindContents.size > 0) {\r\n        const childBindContent = Array.from(lastBinding.bindContents).at(-1) ?? raiseError(`BindContent: childBindContent is not found`);\r\n        const lastNode = childBindContent.getLastNode(parentNode);\r\n        if (lastNode !== null) {\r\n          return lastNode;\r\n        }\r\n      }\r\n    }\r\n    if (parentNode !== lastChildNode?.parentNode) {\r\n      return null;\r\n    }\r\n    return lastChildNode;\r\n  }\r\n  #currentLoopContext: ILoopContext | null | undefined;\r\n  get currentLoopContext(): ILoopContext | null {\r\n    if (typeof this.#currentLoopContext === \"undefined\") {\r\n      let bindContent: IBindContent | null = this;\r\n      while(bindContent !== null) {\r\n        if (bindContent.loopContext !== null) break; ;\r\n        bindContent = bindContent.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      this.#currentLoopContext = bindContent?.loopContext ?? null;\r\n    }\r\n    return this.#currentLoopContext;\r\n  }\r\n  constructor(\r\n    parentBinding: IBinding | null,\r\n    id           : number, \r\n    engine       : IComponentEngine, \r\n    loopContext  : string | null,\r\n    listIndex    : IListIndex | null\r\n  ) {\r\n    this.parentBinding = parentBinding;\r\n    this.#id = id;\r\n    this.fragment = createContent(id);\r\n    this.childNodes = Array.from(this.fragment.childNodes);\r\n    this.engine = engine;\r\n    this.loopContext = (listIndex !== null) ? createLoopContext(loopContext, listIndex, this) : null;\r\n    this.bindings = createBindings(\r\n      this, \r\n      id, \r\n      engine, \r\n      this.fragment\r\n    );\r\n  }\r\n  mount(parentNode: Node) {\r\n    parentNode.appendChild(this.fragment);\r\n  }\r\n  mountBefore(parentNode: Node, beforeNode: Node | null) {\r\n    parentNode.insertBefore(this.fragment, beforeNode);\r\n  }\r\n  mountAfter(parentNode: Node, afterNode: Node | null) {\r\n    parentNode.insertBefore(\r\n      this.fragment, \r\n      afterNode?.nextSibling ?? null\r\n    );\r\n  }\r\n  unmount() {\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      this.fragment.appendChild(this.childNodes[i]);\r\n    }\r\n  }\r\n  bindings: IBinding[] = [];\r\n  render() {\r\n    render(this.bindings);\r\n  }\r\n  init() {\r\n    this.bindings.forEach(binding => binding.init());\r\n  }\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    if (this.loopContext == null) raiseError(`BindContent: loopContext is null`);\r\n    this.loopContext.assignListIndex(listIndex);\r\n    this.init();\r\n  }\r\n}\r\n\r\nexport function createBindContent(\r\n  parentBinding: IBinding | null,\r\n  id           : number, \r\n  engine       :IComponentEngine, \r\n  loopContext  : string | null, \r\n  listIndex    :IListIndex | null\r\n):IBindContent {\r\n  const bindContent = new BindContent(\r\n    parentBinding, \r\n    id, \r\n    engine, \r\n    loopContext, \r\n    listIndex\r\n  );\r\n  bindContent.init();\r\n  return bindContent;\r\n}","import { NodePath } from \"./types\";\r\n\r\nexport function resolveNodeFromPath(root: Node, path: NodePath): Node | null {\r\n  return path.reduce((node, index) => node?.childNodes[index] ?? null, root);\r\n}","\r\nimport { IResolvedPathInfo, WildcardType } from './types';\r\nimport { getStructuredPathInfo } from './getStructuredPathInfo';\r\n\r\n/**\r\n * プロパティ名に\"constructor\"や\"toString\"などの予約語やオブジェクトのプロパティ名を\r\n * 上書きするような名前も指定できるように、Mapを検討したが、そもそもそのような名前を\r\n * 指定することはないと考え、Mapを使わないことにした。\r\n */\r\nconst _cache: { [key:string]: IResolvedPathInfo } = {};\r\n//const _cache: Map<string, IResolvedPathInfo> = new Map();\r\n\r\nclass ResolvedPathInfo implements IResolvedPathInfo {\r\n  static id = 0;\r\n  id = ++ResolvedPathInfo.id;\r\n  name;\r\n  elements;\r\n  paths;\r\n  wildcardCount;\r\n  wildcardType;\r\n  wildcardIndexes;\r\n  info;\r\n  constructor(name: string) {\r\n    const elements = name.split(\".\");\r\n    const tmpPatternElements = elements.slice();\r\n    const paths = [];\r\n    let incompleteCount = 0;\r\n    let completeCount = 0;\r\n    let lastPath = \"\";\r\n    let wildcardCount = 0;\r\n    let wildcardType: WildcardType = \"none\";\r\n    let wildcardIndexes: (number | null)[] = [];\r\n    for(let i = 0; i < elements.length; i++) {\r\n      const element = elements[i];\r\n      if (element === \"*\") {\r\n        tmpPatternElements[i] = \"*\";\r\n        wildcardIndexes.push(null);\r\n        incompleteCount++;\r\n        wildcardCount++;\r\n      } else {\r\n        const number = Number(element);\r\n        if (!Number.isNaN(number)) {\r\n          tmpPatternElements[i] = \"*\";\r\n          wildcardIndexes.push(number);\r\n          completeCount++;\r\n          wildcardCount++;\r\n        }\r\n      }\r\n      lastPath += element;\r\n      paths.push(lastPath);\r\n      lastPath += (i < elements.length - 1 ? \".\" : \"\");\r\n    }\r\n    const pattern = tmpPatternElements.join(\".\");\r\n    const info = getStructuredPathInfo(pattern);\r\n    if (incompleteCount > 0 || completeCount > 0) {\r\n      if (incompleteCount === wildcardCount) {\r\n        wildcardType = \"context\";\r\n      } else if (completeCount === wildcardCount) {\r\n        wildcardType = \"all\";\r\n      } else {\r\n        wildcardType = \"partial\";\r\n      }\r\n    }\r\n    this.name = name;\r\n    this.elements = elements;\r\n    this.paths = paths;\r\n    this.wildcardCount = wildcardCount;\r\n    this.wildcardType = wildcardType;\r\n    this.wildcardIndexes = wildcardIndexes;\r\n    this.info = info;\r\n  }\r\n}\r\n\r\nexport function getResolvedPathInfo(name:string):IResolvedPathInfo {\r\n  let nameInfo: IResolvedPathInfo | undefined;\r\n//  return _cache.get(name) ?? (_cache.set(name, nameInfo = new ResolvedPathInfo(name)), nameInfo);\r\n  return _cache[name] ?? (_cache[name] = new ResolvedPathInfo(name));\r\n}","import { IListIndex } from \"./types\";\r\n\r\nclass ListIndex implements IListIndex {\r\n  static id: number = 0;\r\n  id              : number = ++ListIndex.id;\r\n  #parentListIndex: IListIndex | null = null;\r\n  get parentListIndex(): IListIndex | null {\r\n    return this.#parentListIndex;\r\n  }\r\n  index: number;\r\n  get indexes(): number[] {\r\n    const indexes = this.parentListIndex?.indexes ?? [];\r\n    indexes.push(this.index);\r\n    return indexes;\r\n  }\r\n\r\n  get position(): number {\r\n    return (this.parentListIndex?.position ?? -1) + 1;\r\n  }\r\n\r\n  constructor(\r\n    parentListIndex: IListIndex | null,\r\n    index: number\r\n  ) {\r\n    this.#parentListIndex = parentListIndex;\r\n    this.index = index;\r\n  }\r\n  \r\n  truncate(length: number): IListIndex | null {\r\n    let listIndex: IListIndex | null = this;\r\n    while(listIndex !== null) {\r\n      if (listIndex.position < length) return listIndex;\r\n      listIndex = listIndex.parentListIndex;\r\n    }\r\n    return null;\r\n  }\r\n  add(value: number): IListIndex {\r\n    return new ListIndex(this, value);\r\n  }\r\n\r\n  *reverseIterator(): Generator<IListIndex> {\r\n    yield this;\r\n    if (this.parentListIndex !== null) {\r\n      yield* this.parentListIndex.reverseIterator();\r\n    }\r\n    return;\r\n  }\r\n\r\n  *iterator(): Generator<IListIndex> {\r\n    if (this.parentListIndex !== null) {\r\n      yield* this.parentListIndex.iterator();\r\n    }\r\n    yield this;\r\n    return;\r\n  }\r\n\r\n  toString(): string {\r\n    const parentListIndex = this.parentListIndex?.toString();\r\n    return (parentListIndex !== null) ? parentListIndex + \",\" + this.index.toString() : this.index.toString();\r\n  }\r\n\r\n  at(position: number): IListIndex | null {\r\n    let iterator;\r\n    if (position >= 0) {\r\n      iterator = this.iterator();\r\n    } else {\r\n      position = - position - 1 \r\n      iterator = this.reverseIterator();\r\n    }\r\n    let next;\r\n    while(position >= 0) {\r\n      next = iterator.next();\r\n      position--;\r\n    }\r\n    return next?.value ?? null;\r\n  }\r\n  \r\n}\r\n\r\nexport function createListIndex(\r\n  parentListIndex: IListIndex | null,\r\n  index          : number\r\n): IListIndex {\r\n  return new ListIndex(parentListIndex, index);\r\n}\r\n\r\nexport function getMaxListIndexId(): number {\r\n  return ListIndex.id;\r\n}\r\n","import { getMaxListIndexId } from \"../ListIndex/createListIndex\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\n\r\n/**\r\n * 参照用のIDを生成する\r\n * ListIndexのIDは最大値を取得してから計算するため、ListIndexの構築が完了していない場合、重複が発生する可能性がある\r\n */\r\n/**\r\n * ToDo:ListIndexの構築が完了していない状態で、IDを取得すると例外を発生させる仕組みが必要\r\n */\r\nexport function getStatePropertyRefId(info: IStructuredPathInfo, listIndex: IListIndex | null): number {\r\n  const listIndexMaxId = getMaxListIndexId();\r\n  return info.id * (listIndexMaxId + 1) + (listIndex?.id ?? 0);\r\n}","import { IListIndex } from \"../ListIndex/types\";\r\nimport { getResolvedPathInfo } from \"../StateProperty/getResolvedPathInfo\";\r\nimport { IResolvedPathInfo, IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRefId } from \"../StatePropertyRef/getStatePropertyRefId\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetAllSymbol, GetByRefSymbol, ResolveSymbol, SetByRefSymbol, SetCacheableSymbol } from \"./symbols\";\r\nimport { IState, IStateProxy } from \"./types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\n\r\nconst matchIndexPropertyName = new RegExp(/^\\$(\\d+)$/);\r\nconst CONNECTED_CALLBACK = \"$connectedCallback\";\r\nconst DISCONNECTED_CALLBACK = \"$disconnectedCallback\";\r\n\r\nfunction getListIndex(\r\n  info: IResolvedPathInfo, \r\n  engine: IComponentEngine\r\n): IListIndex | null {\r\n  if (info.info.wildcardCount === 0) {\r\n    return null;\r\n  }\r\n  let listIndex: IListIndex | null = null;\r\n  const lastWildcardPath = info.info.lastWildcardPath ?? \r\n    raiseError(`lastWildcardPath is null`);\r\n  if (info.wildcardType === \"context\") {\r\n    listIndex = engine.getContextListIndex(lastWildcardPath) ?? \r\n      raiseError(`ListIndex not found: ${info.info.pattern}`);\r\n  } else if (info.wildcardType === \"all\") {\r\n    let parentListIndex = null;\r\n    for(let i = 0; i < info.info.wildcardCount; i++) {\r\n      const wildcardParentPattern = info.info.wildcardParentInfos[i] ?? raiseError(`wildcardParentPattern is null`);\r\n      const listIndexes: IListIndex[] = Array.from(engine.getListIndexesSet(wildcardParentPattern, parentListIndex) ?? []);\r\n      const wildcardIndex = info.wildcardIndexes[i] ?? raiseError(`wildcardIndex is null`);\r\n      parentListIndex = listIndexes[wildcardIndex] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n    }\r\n    listIndex = parentListIndex;\r\n  } else if (info.wildcardType === \"partial\") {\r\n    // ToDo:listIndexを取得する必要がある\r\n  } else if (info.wildcardType === \"none\") {\r\n  }\r\n  return listIndex;\r\n}\r\n\r\nclass StateHandler {\r\n  engine   : IComponentEngine;\r\n  cacheable: boolean = false;\r\n  cache    : {[key:number]:any} = {};\r\n  constructor(engine: IComponentEngine) {\r\n    this.engine = engine;\r\n  }\r\n\r\n  _getByRef(\r\n    target   : Object, \r\n    info     : IStructuredPathInfo,\r\n    listIndex: IListIndex | null,\r\n    receiver : IStateProxy\r\n  ): any {\r\n    if (this.#lastTrackingStack != null && this.#lastTrackingStack !== info) {\r\n      const lastPattern = this.#lastTrackingStack;\r\n      if (lastPattern.parentInfo !== info) {\r\n        this.engine.addDependentProp(lastPattern, info);\r\n      }\r\n    }\r\n\r\n    let refId = 0;\r\n    if (this.cacheable) {\r\n      refId = getStatePropertyRefId(info, listIndex);\r\n      const value = this.cache[refId];\r\n      if (typeof value !== \"undefined\") {\r\n        return value;\r\n      }\r\n      if (refId in this.cache) {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    let value;\r\n    try {\r\n      if (info.pattern in target) {\r\n        if (info.wildcardCount > 0) {\r\n          if (listIndex === null) {\r\n            raiseError(`propRef.listIndex is null`);\r\n          }\r\n          return (value = this.engine.setStatePropertyRef(info, listIndex, () => {\r\n            return Reflect.get(target, info.pattern, receiver);\r\n          }));\r\n        } else {\r\n          return (value = Reflect.get(target, info.pattern, receiver));\r\n        }\r\n      } else {\r\n        const parentInfo = info.parentInfo ?? raiseError(`propRef.stateProp.parentInfo is undefined`);\r\n        const parentListIndex = parentInfo.wildcardCount < info.wildcardCount ? (listIndex?.parentListIndex ?? null) : listIndex;\r\n        const parentValue = this.getByRef(target, parentInfo, parentListIndex, receiver);\r\n        const lastSegment = info.lastSegment;\r\n        if (lastSegment === \"*\") {\r\n          const index = listIndex?.index ?? raiseError(`propRef.listIndex?.index is undefined`);\r\n          return (value = Reflect.get(parentValue, index));\r\n        } else {\r\n          return (value = Reflect.get(parentValue, lastSegment));\r\n        }\r\n      }\r\n    } finally {\r\n      if (this.cacheable && !(refId in this.cache)) {\r\n        this.cache[refId] = value;\r\n      }\r\n    }\r\n  }\r\n\r\n  #trackingStack: IStructuredPathInfo[] = [];\r\n  #lastTrackingStack: IStructuredPathInfo | null = null;\r\n  setTracking(info: IStructuredPathInfo, callback: () => any): any {\r\n    this.#trackingStack.push(info);\r\n    this.#lastTrackingStack = info;\r\n    try {\r\n      return callback();\r\n    } finally {\r\n      this.#trackingStack.pop();\r\n      this.#lastTrackingStack = this.#trackingStack[this.#trackingStack.length - 1] ?? null;\r\n    }\r\n  }\r\n\r\n  getByRef(\r\n    target   : Object, \r\n    info     : IStructuredPathInfo,\r\n    listIndex: IListIndex | null,\r\n    receiver : IStateProxy\r\n  ): any {\r\n    if (this.engine.trackedGetters.has(info.pattern)) {\r\n      return this.setTracking(info, () => {\r\n        return this._getByRef(target, info, listIndex, receiver);\r\n      });\r\n    } else {\r\n      return this._getByRef(target, info, listIndex, receiver);\r\n    }\r\n\r\n  }\r\n\r\n  setByRef(\r\n    target   : Object, \r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex | null, \r\n    value    : any, \r\n    receiver : IStateProxy\r\n  ): any {\r\n    try {\r\n      if (info.pattern in target) {\r\n        if (info.wildcardCount > 0) {\r\n          if (listIndex === null) {\r\n            raiseError(`propRef.listIndex is null`);\r\n          }\r\n          return this.engine.setStatePropertyRef(info, listIndex, () => {\r\n            return Reflect.set(target, info.pattern, value, receiver);\r\n          });\r\n        } else {\r\n          return Reflect.set(target, info.pattern, value, receiver);\r\n        }\r\n      } else {\r\n        const parentInfo = info.parentInfo ?? raiseError(`propRef.stateProp.parentInfo is undefined`);\r\n        const parentListIndex = parentInfo.wildcardCount < info.wildcardCount ? (listIndex?.parentListIndex ?? null) : listIndex;\r\n        const parentValue = this.getByRef(target, parentInfo, parentListIndex, receiver);\r\n        const lastSegment = info.lastSegment;\r\n        if (lastSegment === \"*\") {\r\n          const index = listIndex?.index ?? raiseError(`propRef.listIndex?.index is undefined`);\r\n          return Reflect.set(parentValue, index, value);\r\n        } else {\r\n          return Reflect.set(parentValue, lastSegment, value);\r\n        }\r\n      }\r\n    } finally {\r\n      this.engine.updater.addUpdatedStatePropertyRefValue(info, listIndex, value);\r\n    }\r\n  }\r\n\r\n  async setCacheable(callback: () => Promise<void>): Promise<void> {\r\n    this.cacheable = true;\r\n    this.cache = {}\r\n    try {\r\n      await callback();\r\n    } finally {\r\n      this.cacheable = false;\r\n    }\r\n  }\r\n\r\n  [GetByRefSymbol](\r\n    target: Object, \r\n    prop: PropertyKey, \r\n    receiver: IStateProxy\r\n  ):Function {\r\n    const self = this;\r\n    return (pattern: IStructuredPathInfo, listIndex: IListIndex) => \r\n      self.getByRef(target, pattern, listIndex, receiver);\r\n  } \r\n\r\n  [SetByRefSymbol](target: Object, prop: PropertyKey, receiver: IStateProxy):Function {\r\n    const self = this;\r\n    return (pattern: IStructuredPathInfo, listIndex: IListIndex, value: any) => \r\n      self.setByRef(target, pattern, listIndex, value, receiver);\r\n\r\n  }\r\n  [SetCacheableSymbol](target: Object, prop: PropertyKey, receiver: IStateProxy):Function {\r\n    const self = this;\r\n    return async (callback: () => Promise<void>) => {\r\n      await self.setCacheable(callback);\r\n    }\r\n  }\r\n  [ConnectedCallbackSymbol](target: Object, prop: PropertyKey, receiver: IStateProxy):Function {\r\n    return async () => {\r\n      const callback = Reflect.get(target, CONNECTED_CALLBACK);\r\n      if (typeof callback === \"function\") {\r\n        await callback.call(target, receiver);\r\n      }\r\n    };\r\n  }\r\n  [DisconnectedCallbackSymbol](target: Object, prop: PropertyKey, receiver: IStateProxy):Function {\r\n    return async () => {\r\n      const callback = Reflect.get(target, DISCONNECTED_CALLBACK);\r\n      if (typeof callback === \"function\") {\r\n        await callback.call(target, receiver);\r\n      }\r\n    };\r\n  }\r\n  [ResolveSymbol](target: Object, prop: PropertyKey, receiver: IStateProxy):Function {\r\n    const self = this;\r\n    return (path: string, indexes: number[], value?:any): any => {\r\n      const info = getStructuredPathInfo(path);\r\n      let listIndex: IListIndex | null = null;\r\n      for(let i = 0; i < info.wildcardParentInfos.length; i++) {\r\n        const wildcardParentPattern = info.wildcardParentInfos[i] ?? raiseError(`wildcardParentPath is null`);\r\n        const listIndexes: IListIndex[] = Array.from(self.engine.getListIndexesSet(wildcardParentPattern, listIndex) ?? []);\r\n        const index = indexes[i] ?? raiseError(`index is null`);\r\n        listIndex = listIndexes[index] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n      }\r\n      if (typeof value === \"undefined\") {\r\n        return self.getByRef(target, info, listIndex, receiver);\r\n      } else {\r\n        return self.setByRef(target, info, listIndex, value, receiver);\r\n      }\r\n    };\r\n  } \r\n  [GetAllSymbol](target: Object, prop: PropertyKey, receiver: IStateProxy):Function {\r\n    const self = this;\r\n    const resolve = this[ResolveSymbol](target, prop, receiver);\r\n    return (path: string, indexes?: number[]): any[] => {\r\n      const info = getStructuredPathInfo(path);\r\n      if (this.#lastTrackingStack != null && this.#lastTrackingStack !== info) {\r\n        const lastPattern = this.#lastTrackingStack;\r\n        if (lastPattern.parentInfo !== info) {\r\n          this.engine.addDependentProp(lastPattern, info);\r\n        }\r\n      }\r\n  \r\n      if (typeof indexes === \"undefined\") {\r\n        for(let i = 0; i < info.wildcardInfos.length; i++) {\r\n          const wildcardPattern = info.wildcardInfos[i] ?? raiseError(`wildcardPattern is null`);\r\n          const listIndex = this.engine.getContextListIndex(wildcardPattern.pattern);\r\n          if (listIndex) {\r\n            indexes = listIndex.indexes;\r\n            break;\r\n          }\r\n        }\r\n        if (typeof indexes === \"undefined\") {\r\n          indexes = [];\r\n        }\r\n      }\r\n      const walkWildcardPattern = (\r\n        wildcardParentInfos: IStructuredPathInfo[],\r\n        wildardIndexPos: number,\r\n        listIndex: IListIndex | null,\r\n        indexes: number[],\r\n        indexPos: number,\r\n        parentIndexes: number[],\r\n        results: number[][]\r\n      ) => {\r\n        const wildcardParentPattern = wildcardParentInfos[wildardIndexPos] ?? null;\r\n        if (wildcardParentPattern === null) {\r\n          results.push(parentIndexes);\r\n          return;\r\n        }\r\n        const listIndexSet = self.engine.getListIndexesSet(wildcardParentPattern, listIndex) ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n        const listIndexes = Array.from(listIndexSet);\r\n        const index = indexes[indexPos] ?? null;\r\n        if (index === null) {\r\n          for(let i = 0; i < listIndexes.length; i++) {\r\n            const listIndex = listIndexes[i];\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results);\r\n          }\r\n        } else {\r\n          const listIndex = listIndexes[index] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n          if ((wildardIndexPos + 1) < wildcardParentInfos.length) {\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results\r\n            );\r\n          }\r\n        }\r\n      }\r\n      const resultIndexes: number[][] = [];\r\n      walkWildcardPattern(\r\n        info.wildcardParentInfos, \r\n        0, \r\n        null, \r\n        indexes, \r\n        0, \r\n        [], \r\n        resultIndexes\r\n      );\r\n      const resultValues: any[] = [];\r\n      for(let i = 0; i < resultIndexes.length; i++) {\r\n        resultValues.push(resolve(\r\n          info.pattern,\r\n          resultIndexes[i]\r\n        ));\r\n      }\r\n      return resultValues;\r\n    }\r\n  }\r\n\r\n  callableSymbols = new Set([\r\n    GetByRefSymbol, \r\n    SetByRefSymbol, \r\n    SetCacheableSymbol, \r\n    ConnectedCallbackSymbol, \r\n    DisconnectedCallbackSymbol, \r\n    ResolveSymbol, \r\n    GetAllSymbol\r\n  ]);\r\n\r\n  get(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    receiver: IStateProxy\r\n  ): any {\r\n    let value;\r\n    if (typeof prop === \"string\") {\r\n      if (matchIndexPropertyName.test(prop)) {\r\n        const number = prop.slice(1);\r\n        const index = Number(number);\r\n        const ref = this.engine.getLastStatePropertyRef() ?? \r\n          raiseError(`get: this.engine.getLastStatePropertyRef() is null`);\r\n        return ref.listIndex?.at(index - 1)?.index ?? raiseError(`ListIndex not found: ${prop}`);\r\n      } else if (prop === \"$resolve\") {\r\n        return this[ResolveSymbol].apply(this, [target, prop, receiver]);\r\n      } else if (prop === \"$getAll\") {\r\n        return this[GetAllSymbol].apply(this, [target, prop, receiver]);\r\n      } else {\r\n        const resolvedInfo = getResolvedPathInfo(prop);\r\n        const listIndex = getListIndex(resolvedInfo, this.engine);\r\n        value = this.getByRef(\r\n          target, \r\n          resolvedInfo.info, \r\n          listIndex, \r\n          receiver\r\n        );\r\n      }\r\n    } else if (typeof prop === \"symbol\") {\r\n      if (this.callableSymbols.has(prop)) {\r\n        const func = Reflect.get(this, prop) as Function;\r\n        return func.apply(this, [target, prop, receiver]);\r\n      }\r\n      value = Reflect.get(\r\n        target, \r\n        prop, \r\n        receiver\r\n      );\r\n    }\r\n    return value;\r\n  }\r\n\r\n  set(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    value   : any, \r\n    receiver: IStateProxy\r\n  ): boolean {\r\n    if (typeof prop === \"string\") {\r\n      const resolvedInfo = getResolvedPathInfo(prop);\r\n      const listIndex = getListIndex(resolvedInfo, this.engine);\r\n      return this.setByRef(\r\n        target, \r\n        resolvedInfo.info, \r\n        listIndex, \r\n        value, \r\n        receiver\r\n      );\r\n    } else {\r\n      return Reflect.set(\r\n        target, \r\n        prop, \r\n        value, \r\n        receiver\r\n      );\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport function createStateProxy(\r\n  engine: IComponentEngine, \r\n  state: Object\r\n): IStateProxy {\r\n  return new Proxy<IState>(state, new StateHandler(engine)) as IStateProxy;\r\n}\r\n\r\n","import { createListIndex } from \"../ListIndex/createListIndex\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { GetByRefSymbol } from \"./symbols\";\r\n\r\nconst BLANK_LISTINDEXES_SET = new Set<IListIndex>();\r\n\r\nfunction buildListIndexTreeSub(\r\n  engine   : IComponentEngine, \r\n  listInfos: Set<IStructuredPathInfo>,\r\n  info     : IStructuredPathInfo,\r\n  listIndex: IListIndex | null, \r\n  value: any[]\r\n): void {\r\n  const oldValue = engine.getList(info, listIndex) ?? [];\r\n  if (oldValue === value) {\r\n    return;\r\n  }\r\n  const oldListIndexesSet = engine.getListIndexesSet(info, listIndex) ?? BLANK_LISTINDEXES_SET;\r\n  const oldListIndexesByItem = Map.groupBy(oldListIndexesSet, listIndex => oldValue[listIndex.index]);\r\n  const newListIndexesSet:Set<IListIndex> = new Set();\r\n  for(let i = 0; i < value.length; i++) {\r\n    const item = value[i];\r\n    const oldListIndexes = oldListIndexesByItem.get(item);\r\n    let curListIndex = oldListIndexes?.shift();\r\n    if (!curListIndex) {\r\n      curListIndex = createListIndex(listIndex, i);\r\n    } else {\r\n      if (curListIndex.index !== i) {\r\n        curListIndex.index = i;\r\n        engine.updater.addUpdatedListIndex(curListIndex);\r\n      }\r\n    }\r\n    newListIndexesSet.add(curListIndex);\r\n  }\r\n  engine.saveListIndexesSet(info, listIndex, newListIndexesSet);\r\n  engine.saveList(info, listIndex, value.slice(0));\r\n\r\n  const searchPath = info.pattern + \".*\";\r\n  for(const info of listInfos) {\r\n    if (searchPath !== info.lastWildcardPath) {\r\n      continue;\r\n    }\r\n    for(const subListIndex of newListIndexesSet) {\r\n      const subValue = engine.stateProxy[GetByRefSymbol](info, subListIndex);\r\n      buildListIndexTreeSub(\r\n        engine, \r\n        listInfos, \r\n        info, \r\n        subListIndex, \r\n        subValue ?? []\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport function buildListIndexTree(\r\n  engine   : IComponentEngine, \r\n  info     : IStructuredPathInfo,\r\n  listIndex: IListIndex | null, \r\n  value    : any\r\n): void {\r\n  const listInfos = engine.listInfoSet;\r\n  // 配列じゃなければ何もしない\r\n  if (!engine.listInfoSet.has(info)) {\r\n    return;\r\n  }\r\n  const values = (value ?? []) as any[];\r\n  buildListIndexTreeSub(\r\n    engine, \r\n    engine.listInfoSet, \r\n    info, \r\n    listIndex, \r\n    values\r\n  );\r\n}\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\n\r\nfunction extractListIndexes(\r\n  info: IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n  engine: IComponentEngine,\r\n): IListIndex[] {\r\n  const wildcardParentInfos: IStructuredPathInfo[] = info.wildcardParentInfos ?? [];\r\n  const _extractListIndexes = (pos:number, currentListIndex: IListIndex | null, resultListIndexes: IListIndex[]) => {\r\n    const wildcardParentInfo = wildcardParentInfos[pos];\r\n    if (!wildcardParentInfo) {\r\n      if (currentListIndex) {\r\n        resultListIndexes.push(currentListIndex);\r\n      }\r\n      return;\r\n    }\r\n    const subListIndex = listIndex?.at(pos) ?? null;\r\n    if (subListIndex) {\r\n      _extractListIndexes(pos + 1, subListIndex, resultListIndexes);\r\n    } else {\r\n      const listIndexes = engine.getListIndexesSet(wildcardParentInfo, currentListIndex);\r\n      for(const loopListIndex of listIndexes ?? []) {\r\n        _extractListIndexes(pos + 1, loopListIndex, resultListIndexes);\r\n      }\r\n    }\r\n  }\r\n  const resultListIndexes: IListIndex[] = [];\r\n  _extractListIndexes(0, listIndex, resultListIndexes);\r\n  return resultListIndexes;\r\n}\r\n\r\nfunction _collectAffectedGetters(\r\n  refInfo        : IStructuredPathInfo,\r\n  refListIndex   : IListIndex | null,\r\n  engine         : IComponentEngine,\r\n  resultPathInfos: Set<IStructuredPathInfo>,\r\n  resultRefs     : {info:IStructuredPathInfo, listIndex:IListIndex | null}[],\r\n) {\r\n//  if (engine.listInfoSet.has(refInfo)) return;\r\n  if (resultPathInfos.has(refInfo)) return;\r\n  const dependentPathInfos = engine.dependentTree.get(refInfo);\r\n  for(const dependentPathInfo of dependentPathInfos ?? []) {\r\n    if (engine.listInfoSet.has(refInfo) && dependentPathInfo.parentInfo === refInfo && dependentPathInfo.lastSegment === \"*\") {\r\n      continue;\r\n    }\r\n    let dependentListIndex = null;\r\n    let updateList = false;\r\n    for(let i = dependentPathInfo.wildcardParentInfos.length - 1; i >= 0; i--) {\r\n      const wildcardParentInfo = dependentPathInfo.wildcardParentInfos[i];\r\n      if (resultPathInfos.has(wildcardParentInfo)) {\r\n        updateList = true;\r\n        break;\r\n      }\r\n      const pos = refInfo.wildcardParentInfos.indexOf(wildcardParentInfo);\r\n      if (pos < 0) continue;\r\n      dependentListIndex = refListIndex?.at(pos) ?? null;\r\n      if (dependentListIndex !== null) break;\r\n    }\r\n    if (updateList) {\r\n      continue;\r\n    }\r\n    if (dependentPathInfo.wildcardParentInfos.length > 0) {\r\n      const extractlistIndexes = extractListIndexes(dependentPathInfo, dependentListIndex, engine);\r\n      for(const listIndex of extractlistIndexes) {\r\n        resultRefs.push({info: dependentPathInfo, listIndex});\r\n        _collectAffectedGetters(dependentPathInfo, listIndex, engine, resultPathInfos, resultRefs);\r\n      }\r\n    } else {\r\n      resultRefs.push({info: dependentPathInfo, listIndex: null});\r\n      _collectAffectedGetters(dependentPathInfo, null, engine, resultPathInfos, resultRefs);\r\n    }\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\nexport function collectAffectedGetters(\r\n  updateRefs: {info:IStructuredPathInfo, listIndex:IListIndex | null}[],\r\n  engine: IComponentEngine,\r\n): {info:IStructuredPathInfo, listIndex:IListIndex | null}[] {\r\n  const resultPathInfos = new Set<IStructuredPathInfo>();\r\n  const resultRefs: {info:IStructuredPathInfo, listIndex:IListIndex | null}[] = [];\r\n  for(const ref of updateRefs) {\r\n    const info = ref.info;\r\n    const listIndex = ref.listIndex;\r\n    if (resultPathInfos.has(info)) continue;\r\n    _collectAffectedGetters(info, listIndex, engine, resultPathInfos, resultRefs);\r\n    resultPathInfos.add(info);\r\n  }\r\n  return resultRefs;\r\n\r\n}\r\n\r\n","import { IBinding } from \"../DataBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { render } from \"../Render/render\";\r\nimport { buildListIndexTree } from \"../StateClass/buildListIndexTree\";\r\nimport { SetCacheableSymbol } from \"../StateClass/symbols\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRefId } from \"../StatePropertyRef/getStatePropertyRefId\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { getGlobalConfig } from \"../WebComponents/getGlobalConfig\";\r\nimport { IUpdater } from \"./types\";\r\nimport { collectAffectedGetters } from \"./collectAffectedGetters\";\r\n\r\ntype UpdatedArrayElementBinding = {\r\n  parentRef: {info: IStructuredPathInfo, listIndex: IListIndex | null};\r\n  binding: IBinding;\r\n  listIndexes: IListIndex[];\r\n  values: any[];\r\n};\r\n\r\nclass Updater implements IUpdater {\r\n  processList      : (() => Promise<void> | void)[] = [];\r\n  updatedProperties: Set<{info:IStructuredPathInfo, listIndex:IListIndex | null} | IListIndex> = \r\n    new Set<{info:IStructuredPathInfo, listIndex:IListIndex | null} | IListIndex>();\r\n  updatedValues    : {[key:number]: any} = {};\r\n  engine           : IComponentEngine;\r\n\r\n  constructor(engine: IComponentEngine) {\r\n    this.engine = engine;\r\n  }\r\n\r\n  addProcess(process: () => Promise<void> | void): void {\r\n    this.processList.push(process);\r\n    this.waitForQueueEntry.resolve();\r\n  }\r\n\r\n  addUpdatedStatePropertyRefValue(\r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex | null, \r\n    value    : any\r\n  ): void {\r\n    const refId = getStatePropertyRefId(info, listIndex);\r\n    this.updatedProperties.add({info, listIndex});\r\n    this.updatedValues[refId] = value;\r\n    this.waitForQueueEntry.resolve();\r\n  }\r\n\r\n  addUpdatedListIndex(listIndex: IListIndex): void {\r\n    this.updatedProperties.add(listIndex);\r\n    this.waitForQueueEntry.resolve();\r\n  }\r\n\r\n  terminate(): PromiseWithResolvers<void> {\r\n    const waitForMainLoopTerminate = Promise.withResolvers<void>();\r\n    this.waitForQueueEntry.resolve(waitForMainLoopTerminate);\r\n    return waitForMainLoopTerminate;\r\n  }\r\n\r\n  waitForQueueEntry: PromiseWithResolvers<PromiseWithResolvers<void> | void> = \r\n    Promise.withResolvers<PromiseWithResolvers<void> | void>();\r\n  async main(waitForComponentInit: PromiseWithResolvers<void>) {\r\n    await waitForComponentInit.promise;\r\n    const config = getGlobalConfig();\r\n    while (true) {\r\n      try {\r\n        const waitForMainLoopTerminate: (PromiseWithResolvers<void> | void) = \r\n          await this.waitForQueueEntry.promise;\r\n          config.debug && performance.mark(`start`);\r\n        Updater.updatingCount++;\r\n        try {\r\n          await this.exec();\r\n          if (config.debug) {\r\n            performance.mark(`end`);\r\n            performance.measure(`exec`, `start`, `end`);\r\n            console.log(performance.getEntriesByType(\"measure\"));    \r\n            performance.clearMeasures(`exec`);\r\n            performance.clearMarks(`start`);\r\n            performance.clearMarks(`end`);\r\n          }\r\n        } finally {\r\n          Updater.updatingCount--;\r\n          if (waitForMainLoopTerminate) {\r\n            waitForMainLoopTerminate.resolve();\r\n            break;\r\n          }\r\n        }\r\n      } catch(e) {\r\n        console.error(e);\r\n      } finally {\r\n        this.waitForQueueEntry = Promise.withResolvers<PromiseWithResolvers<void> | void>();\r\n      }\r\n    }\r\n  }\r\n\r\n  async updateState() {\r\n    while(this.processList.length > 0) {\r\n      const processList = this.processList;\r\n      this.processList = [];\r\n      for(let i = 0; i < processList.length; i++) {\r\n        const process = processList[i];\r\n        await process();\r\n      }\r\n    }\r\n  }\r\n\r\n  async rebuild(): Promise<{bindings: IBinding[], arrayElementBindings: UpdatedArrayElementBinding[]}> {\r\n    const retArrayElementBindings: UpdatedArrayElementBinding[] = [];\r\n    const retBindings: IBinding[] = [];\r\n    const engine = this.engine;\r\n    const processedListIndexes = new Set<IListIndex>();\r\n    const processedPropertyRefIdsSet = new Set<number>();\r\n    while(this.updatedProperties.size > 0) {\r\n      const updatedProiperties = Array.from(this.updatedProperties.values());\r\n\r\n      const updatedRefs = []; // 更新されたプロパティ参照のリスト\r\n      const arrayPropertyRefs = [];\r\n      const arrayElementPropertyRefs = [];\r\n      this.updatedProperties.clear();\r\n      for(let i = 0; i < updatedProiperties.length; i++) {\r\n        const item = updatedProiperties[i];\r\n        let bindings;\r\n        if (\"index\" in item) {\r\n          if (processedListIndexes.has(item)) continue;\r\n          const listIndex = item as IListIndex;\r\n          bindings = engine.bindingsByListIndex.get(listIndex);\r\n          processedListIndexes.add(listIndex);\r\n        } else {\r\n          const statePropertyRefId = getStatePropertyRefId(item.info, item.listIndex);\r\n          if (processedPropertyRefIdsSet.has(statePropertyRefId)) continue;\r\n          const statePropertyRef = item as {info:IStructuredPathInfo, listIndex:IListIndex | null};\r\n          if (engine.listInfoSet.has(statePropertyRef.info)) {\r\n            arrayPropertyRefs.push(statePropertyRef);\r\n          }\r\n          if (engine.elementInfoSet.has(statePropertyRef.info)) {\r\n            arrayElementPropertyRefs.push(statePropertyRef);\r\n          }\r\n          bindings = engine.getBindings(item.info, item.listIndex);\r\n          processedPropertyRefIdsSet.add(statePropertyRefId);\r\n          updatedRefs.push(statePropertyRef);\r\n        }\r\n        retBindings.push(...bindings ?? []);\r\n      }\r\n\r\n      // リストインデックスの構築\r\n      const builtStatePropertyRefIds = new Set<number>();\r\n      for(let i = 0; i < arrayPropertyRefs.length; i++) {\r\n        const arrayPropertyRef = arrayPropertyRefs[i];\r\n        const statePropertyRefId = getStatePropertyRefId(arrayPropertyRef.info, arrayPropertyRef.listIndex);\r\n        const value = this.updatedValues[statePropertyRefId] ?? null;\r\n        buildListIndexTree(engine, arrayPropertyRef.info, arrayPropertyRef.listIndex, value);\r\n        builtStatePropertyRefIds.add(statePropertyRefId);\r\n      }\r\n\r\n      const parentRefByRefId: {[parentRefId: number]: {info: IStructuredPathInfo, listIndex: IListIndex | null }} = {};\r\n      const statePropertyRefByStatePropertyRefId = Object.groupBy(arrayElementPropertyRefs, ref => {\r\n        if (ref.info.parentInfo === null) raiseError(`parentInfo is null`);\r\n        const parentInfo = ref.info.parentInfo;\r\n        const parentListIndex = (ref.info.wildcardCount === ref.info.parentInfo.wildcardCount) ?\r\n          ref.listIndex : (ref.listIndex?.parentListIndex ?? null);\r\n        const parentRefId = getStatePropertyRefId(parentInfo, parentListIndex);\r\n        if (!(parentRefId in parentRefByRefId)) {\r\n          parentRefByRefId[parentRefId] = {info: parentInfo, listIndex: parentListIndex};\r\n        }\r\n        return parentRefId;\r\n      });\r\n      for(const [parentRefIdKey, refs] of Object.entries(statePropertyRefByStatePropertyRefId)) {\r\n        const parentRefId = Number(parentRefIdKey);\r\n        if (builtStatePropertyRefIds.has(parentRefId)) continue;\r\n        if (typeof refs === \"undefined\") continue;\r\n        const parentRef = parentRefByRefId[parentRefId];\r\n        if (parentRef === null) continue;\r\n\r\n        const values = [];\r\n        const listIndexes = [];\r\n        for(let j = 0; j < refs.length; j++) {\r\n          const ref = refs[j];\r\n          const statePropertyRefId = getStatePropertyRefId(ref.info, ref.listIndex);\r\n          const value = this.updatedValues[statePropertyRefId] ?? null;\r\n          values.push(value);\r\n          const listIndex = ref.listIndex;\r\n          if (listIndex === null) {\r\n            throw new Error(\"listIndex is null\");\r\n          }\r\n          listIndexes.push(listIndex);\r\n        }\r\n        const bindings = engine.getBindings(parentRef.info, parentRef.listIndex);\r\n        for(const binding of bindings) {\r\n          const arrayElementBinding: UpdatedArrayElementBinding = {\r\n            parentRef,\r\n            binding,\r\n            listIndexes,\r\n            values\r\n          };\r\n          retArrayElementBindings.push(arrayElementBinding);\r\n        }\r\n      }\r\n      \r\n      const updatingRefs = collectAffectedGetters(updatedRefs, engine);\r\n      for(const updatingRef of updatingRefs) {\r\n        const bindings = engine.getBindings(updatingRef.info, updatingRef.listIndex);\r\n        retBindings.push(...bindings ?? []);\r\n      }\r\n      \r\n    }\r\n    this.updatedValues = {};\r\n    return {bindings: retBindings, arrayElementBindings: retArrayElementBindings};\r\n  }\r\n\r\n  async render(bindings: IBinding[]) {\r\n    await this.engine.stateProxy[SetCacheableSymbol](async () => {\r\n      return render(bindings);\r\n    });\r\n  }\r\n\r\n  async exec() {\r\n    while(this.processList.length !== 0 || this.updatedProperties.size !== 0) {\r\n      // update state\r\n      await this.updateState();\r\n      // rebuild\r\n      const { bindings, arrayElementBindings } = await this.rebuild();\r\n      // render\r\n      for(const arrayElementBinding of arrayElementBindings) {\r\n        arrayElementBinding.binding.bindingNode.updateElements(arrayElementBinding.listIndexes, arrayElementBinding.values);\r\n      }\r\n      if (bindings.length > 0) {\r\n        await this.render(bindings);\r\n      }\r\n    }\r\n  }\r\n\r\n  static updatingCount = 0;\r\n}\r\n\r\nexport function createUpdater(engine: IComponentEngine): IUpdater {\r\n  return new Updater(engine);\r\n}\r\n\r\nexport function getUpdatingCount(): number {\r\n  return Updater.updatingCount;\r\n}","import { raiseError } from \"../utils\";\r\nimport { IComponentConfig } from \"../WebComponents/types\";\r\nimport { canHaveShadowRoot } from \"./canHaveShadowRoot\";\r\n\r\nfunction getParentShadowRoot(parentNode: Node | null): ShadowRoot|undefined{\r\n  let node: Node | null = parentNode;\r\n  while(node) {\r\n    if (node instanceof ShadowRoot) {\r\n      return node;\r\n    }\r\n    node = node.parentNode;\r\n  }\r\n}\r\n\r\nexport function attachShadow(element: HTMLElement, config: IComponentConfig, styleSheet: CSSStyleSheet): void {\r\n    if (config.enableShadowDom) {\r\n      if (config.extends === null || canHaveShadowRoot(config.extends)) {\r\n        const shadowRoot = element.attachShadow({ mode: 'open' });\r\n        shadowRoot.adoptedStyleSheets = [styleSheet];\r\n      } else {\r\n        raiseError(`ComponentEngine: Shadow DOM not supported for builtin components that extend ${config.extends}`);\r\n      }\r\n    } else {\r\n      const shadowRootOrDocument = getParentShadowRoot(element.parentNode) || document;\r\n      const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n      if (!styleSheets.includes(styleSheet)) {\r\n        shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, styleSheet];\r\n      }\r\n    }\r\n\r\n}","export function canHaveShadowRoot(tagName: string): boolean {\r\n  try {\r\n    // 一時的に要素を作成\r\n    const element = document.createElement(tagName);\r\n    // `attachShadow` メソッドが存在し、実行可能かを確認\r\n    return typeof element.attachShadow === \"function\";\r\n  } catch {\r\n    // 無効なタグ名などが渡された場合は false を返す\r\n    return false;\r\n  }\r\n}","import { createBindContent } from \"../DataBinding/BindContent\";\r\nimport { IBindContent, IBinding } from \"../DataBinding/types\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { IState, IStateProxy } from \"../StateClass/types\";\r\nimport { createStateProxy } from \"../StateClass/createStateProxy\";\r\nimport { IUpdater } from \"../Updater/types\";\r\nimport { createUpdater } from \"../Updater/updater\";\r\nimport { ComponentType, IComponentConfig, IComponentStatic, QuelComponent } from \"../WebComponents/types\";\r\nimport { attachShadow } from \"./attachShadow\";\r\nimport { ISaveInfoByResolvedPathInfo, IComponentEngine } from \"./types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { buildListIndexTree } from \"../StateClass/buildListIndexTree\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, SetCacheableSymbol } from \"../StateClass/symbols\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\n\r\nexport class ComponentEngine implements IComponentEngine {\r\n  type          : ComponentType = 'autonomous';\r\n  config        : IComponentConfig;\r\n  template      : HTMLTemplateElement;\r\n  styleSheet    : CSSStyleSheet;\r\n  stateClass    : typeof Object;\r\n  state         : IState;\r\n  stateProxy    : IStateProxy;\r\n  updater       : IUpdater;\r\n  inputFilters  : FilterWithOptions;\r\n  outputFilters : FilterWithOptions;\r\n  bindContent   : IBindContent;\r\n  baseClass     : typeof HTMLElement = HTMLElement;\r\n  owner         : QuelComponent;\r\n  trackedGetters: Set<string>;\r\n\r\n  listInfoSet       : Set<IStructuredPathInfo> = new Set();\r\n  elementInfoSet: Set<IStructuredPathInfo> = new Set();\r\n  bindingsByListIndex                  : WeakMap<IListIndex, Set<IBinding>> = new WeakMap();\r\n  dependentTree                        : Map<IStructuredPathInfo, Set<IStructuredPathInfo>> = new Map();\r\n\r\n  #waitForInitialize : PromiseWithResolvers<void> = Promise.withResolvers<void>();\r\n  #loopContext       : ILoopContext | null = null;\r\n  #stackStructuredPathInfo  : IStructuredPathInfo[] = [];\r\n  #stackListIndex    : IListIndex[] = [];\r\n\r\n  constructor(config: IComponentConfig, owner: QuelComponent) {\r\n    this.config = config;\r\n    if (this.config.extends) {\r\n      this.type = 'builtin';\r\n    }\r\n    const componentClass = owner.constructor as IComponentStatic;\r\n    this.template = componentClass.template;\r\n    this.styleSheet = componentClass.styleSheet;\r\n    this.stateClass = componentClass.stateClass;\r\n    this.state = new this.stateClass();\r\n    this.stateProxy = createStateProxy(this, this.state);\r\n    this.updater = createUpdater(this);\r\n    this.inputFilters = componentClass.inputFilters;\r\n    this.outputFilters = componentClass.outputFilters;\r\n    this.owner = owner;\r\n    this.trackedGetters = componentClass.trackedGetters;\r\n    // 依存関係の木を作成する\r\n    const checkDependentProp = (info: IStructuredPathInfo) => {\r\n      const parentInfo = info.parentInfo;\r\n      if (parentInfo === null) return;\r\n      this.addDependentProp(info, parentInfo);\r\n      checkDependentProp(parentInfo);\r\n    }\r\n    for(const path of componentClass.paths) {\r\n      const info = getStructuredPathInfo(path);\r\n      checkDependentProp(info);\r\n    }\r\n    // 配列のプロパティ、配列要素のプロパティを登録する\r\n    for(const listPath of componentClass.listPaths) {\r\n      this.listInfoSet.add(getStructuredPathInfo(listPath));\r\n      this.elementInfoSet.add(getStructuredPathInfo(listPath + \".*\"));\r\n    }\r\n    this.bindContent = createBindContent(null, componentClass.id, this, null, null); // this.stateArrayPropertyNamePatternsが変更になる可能性がある\r\n    for(const info of this.listInfoSet) {\r\n      if (info.wildcardCount > 0) continue;\r\n      const value = this.stateProxy[GetByRefSymbol](info, null)\r\n      buildListIndexTree(this, info, null, value);\r\n    }\r\n  \r\n    this.updater.main(this.#waitForInitialize);\r\n  }\r\n\r\n  async connectedCallback(): Promise<void> {\r\n    attachShadow(this.owner, this.config, this.styleSheet);\r\n    await this.stateProxy[ConnectedCallbackSymbol]();\r\n    await this.stateProxy[SetCacheableSymbol](async () => {\r\n      this.bindContent.render();\r\n    });\r\n    this.bindContent.mount(this.owner.shadowRoot ?? this.owner);\r\n    this.#waitForInitialize.resolve();\r\n  }\r\n\r\n  async disconnectedCallback(): Promise<void> {\r\n    await this.stateProxy[DisconnectedCallbackSymbol]();\r\n  }\r\n\r\n  async setLoopContext(loopContext: ILoopContext, callback: ()=>Promise<void>): Promise<void> {\r\n    try {\r\n      if (this.#loopContext !== null) {\r\n        throw new Error(\"loopContext is already set\");\r\n      }\r\n      this.#loopContext = loopContext;\r\n      await this.asyncSetStatePropertyRef(loopContext.info, loopContext.listIndex, async () => {\r\n        await callback();\r\n      });\r\n    } finally {\r\n      this.#loopContext = null;\r\n    }\r\n  }\r\n\r\n  async asyncSetStatePropertyRef(\r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex, \r\n    callback : ()=>Promise<any>\r\n  ): Promise<any> {\r\n    this.#stackStructuredPathInfo.push(info);\r\n    this.#stackListIndex.push(listIndex);\r\n    try {\r\n      return await callback();\r\n    } finally {\r\n      this.#stackStructuredPathInfo.pop();\r\n      this.#stackListIndex.pop();\r\n    }\r\n  }\r\n\r\n  setStatePropertyRef(\r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex, \r\n    callback : ()=>any\r\n  ): any {\r\n    this.#stackStructuredPathInfo.push(info);\r\n    this.#stackListIndex.push(listIndex);\r\n    try {\r\n      return callback();\r\n    } finally {\r\n      this.#stackStructuredPathInfo.pop();\r\n      this.#stackListIndex.pop();\r\n    }\r\n  }\r\n\r\n  getLastStatePropertyRef(): {info:IStructuredPathInfo, listIndex:IListIndex} | null {\r\n    if (this.#stackStructuredPathInfo.length === 0) {\r\n      return null;\r\n    }\r\n    const info = this.#stackStructuredPathInfo[this.#stackStructuredPathInfo.length - 1];\r\n    if (typeof info === \"undefined\") {\r\n      return null;\r\n    }\r\n    const listIndex = this.#stackListIndex[this.#stackListIndex.length - 1];\r\n    if (typeof listIndex === \"undefined\") {\r\n      return null;\r\n    }\r\n    return {info, listIndex};\r\n  }\r\n\r\n  getContextListIndex(structuredPath: string): IListIndex | null{\r\n    const lastRef = this.getLastStatePropertyRef();\r\n    if (lastRef === null) {\r\n      return null;\r\n    }\r\n    const info = lastRef.info;\r\n    const index = info.wildcardPaths.indexOf(structuredPath);\r\n    if (index >= 0) {\r\n      return lastRef.listIndex.at(index) ?? null;\r\n    }\r\n    return null;\r\n  }\r\n  getLoopContexts():ILoopContext[] {\r\n    if (this.#loopContext === null) {\r\n      throw new Error(\"loopContext is null\");\r\n    }\r\n    return this.#loopContext.serialize();\r\n  }\r\n\r\n  #saveInfoByListIndexByResolvedPathInfoId: { [id:number]: WeakMap<IListIndex,ISaveInfoByResolvedPathInfo> } = {};\r\n  #saveInfoByStructuredPathId: { [id:number]: ISaveInfoByResolvedPathInfo } = {};\r\n\r\n  createSaveInfo():ISaveInfoByResolvedPathInfo {\r\n    return {\r\n      list          : null,\r\n      listIndexesSet: null,\r\n      bindings      : [],\r\n    }\r\n  }\r\n\r\n  getSaveInfoByStatePropertyRef(info:IStructuredPathInfo, listIndex:IListIndex | null): ISaveInfoByResolvedPathInfo {\r\n    if (listIndex === null) {\r\n      let saveInfo = this.#saveInfoByStructuredPathId[info.id];\r\n      if (typeof saveInfo === \"undefined\") {\r\n        saveInfo = this.createSaveInfo();\r\n        this.#saveInfoByStructuredPathId[info.id] = saveInfo;\r\n      }\r\n      return saveInfo;\r\n    } else {\r\n      let saveInfoByListIndex = this.#saveInfoByListIndexByResolvedPathInfoId[info.id];\r\n      if (typeof saveInfoByListIndex === \"undefined\") {\r\n        saveInfoByListIndex = new WeakMap<IListIndex, ISaveInfoByResolvedPathInfo>();\r\n        this.#saveInfoByListIndexByResolvedPathInfoId[info.id] = saveInfoByListIndex;\r\n      }\r\n      let saveInfo = saveInfoByListIndex.get(listIndex);\r\n      if (typeof saveInfo === \"undefined\") {\r\n        saveInfo = this.createSaveInfo();\r\n        saveInfoByListIndex.set(listIndex, saveInfo);\r\n      }\r\n      return saveInfo;\r\n    }\r\n  }\r\n  saveBinding(\r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex | null, \r\n    binding  : IBinding\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.bindings.push(binding);\r\n  }\r\n  saveListIndexesSet(\r\n    info              :IStructuredPathInfo, \r\n    listIndex         :IListIndex | null, \r\n    saveListIndexesSet:Set<IListIndex>\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.listIndexesSet = saveListIndexesSet;\r\n  }\r\n  saveList(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null, \r\n    list     :any[]\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.list = list;\r\n  }\r\n  getBindings(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null\r\n  ): IBinding[] {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return saveInfo.bindings;\r\n  }\r\n  getListIndexesSet(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null\r\n  ): Set<IListIndex> | null {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return saveInfo.listIndexesSet;\r\n  }\r\n  getList(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null\r\n  ): any[] | null {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return saveInfo.list;\r\n  }\r\n\r\n  addDependentProp(info: IStructuredPathInfo, refInfo: IStructuredPathInfo) {\r\n    let dependents = this.dependentTree.get(refInfo);\r\n    if (typeof dependents === \"undefined\") {\r\n      dependents = new Set<IStructuredPathInfo>();\r\n      this.dependentTree.set(refInfo, dependents);\r\n    }\r\n    dependents.add(info);\r\n  }\r\n}\r\n\r\nexport function createComponentEngine(config: IComponentConfig, component: QuelComponent): IComponentEngine {\r\n  return new ComponentEngine(config, component);\r\n}","import { COMMENT_EMBED_MARK } from \"../constants\";\r\nimport { raiseError } from \"../utils\";\r\n\r\nconst MUSTACHE_REGEXP = /\\{\\{([^\\}]+)\\}\\}/g;\r\nconst MUSTACHE_TYPES:Set<string> = new Set(['if', 'for', 'endif', 'endfor', 'elseif', 'else']);\r\n\r\ntype MustacheType = 'if' | 'for' | 'endif' | 'endfor' | 'elseif' | 'else';\r\ntype MustacheInfo = {\r\n  type: MustacheType;\r\n  remain: string; // after first ':'\r\n  expr: string;\r\n}\r\n\r\nexport function replaceMustacheWithTemplateTag(html: string): string {\r\n  const stack:MustacheInfo[] = [];\r\n  return html.replaceAll(MUSTACHE_REGEXP, (match, expr) => {\r\n    expr = expr.trim();\r\n    const [ type ] = expr.split(':');\r\n    if (!MUSTACHE_TYPES.has(type)) {\r\n      // embed\r\n      return `<!--${COMMENT_EMBED_MARK}${expr}-->`;\r\n    }\r\n    const remain = expr.slice(type.length + 1).trim();\r\n    const currentInfo:MustacheInfo = { type, expr, remain };\r\n    if (type === 'if' || type === 'for') {\r\n      stack.push(currentInfo);\r\n      return `<template data-bind=\"${expr}\">`;\r\n    } else if (type === 'endif') {\r\n      const endTags = [];\r\n      do {\r\n        const info = stack.pop() ?? raiseError('replaceMustacheToTemplateOrEmbed: endif without if');\r\n        if (info.type === 'if') {\r\n          endTags.push('</template>');\r\n          break;\r\n        } else if (info.type === 'elseif') {\r\n          endTags.push('</template>');\r\n        } else {\r\n          raiseError('replaceMustacheToTemplateOrEmbed: endif without if');\r\n        }\r\n      } while(true);\r\n      return endTags.join('');\r\n    } else if (type === 'endfor') {\r\n      const info = stack.pop() ?? raiseError('replaceMustacheToTemplateOrEmbed: endif without if');\r\n      if (info.type === 'for') {\r\n        return '</template>';\r\n      } else {\r\n        raiseError('replaceMustacheToTemplateOrEmbed: endfor without for');\r\n      }\r\n    } else if (type === 'elseif') {\r\n      const lastInfo = stack.at(-1) ?? raiseError('replaceMustacheToTemplateOrEmbed: elseif without if');\r\n      if (lastInfo.type === 'if' || lastInfo.type === 'elseif') {\r\n        stack.push(currentInfo);\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\"><template data-bind=\"if:${remain}\">`;\r\n      } else {\r\n        raiseError('replaceMustacheToTemplateOrEmbed: elseif without if');\r\n      }\r\n    } else if (type === 'else') {\r\n      const lastInfo = stack.at(-1) ?? raiseError('replaceMustacheToTemplateOrEmbed: else without if');\r\n      if (lastInfo.type === 'if') {\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\">`;\r\n      } else {\r\n        raiseError('replaceMustacheToTemplateOrEmbed: else without if');\r\n      }\r\n    } else {\r\n      raiseError('replaceMustacheToTemplateOrEmbed: unknown type');\r\n    }\r\n  });\r\n}\r\n\r\n\r\n\r\n","import { COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants\";\r\nimport { generateId } from \"../GlobalId/generateId\";\r\nimport { registerTemplate } from \"./registerTemplate\";\r\n\r\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\r\n\r\nexport function replaceTemplateTagWithComment(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number = id\r\n):number {\r\n  // テンプレートの親ノードが存在する場合は、テンプレートをコメントノードに置き換える\r\n  template.parentNode?.replaceChild(document.createComment(`${COMMENT_TEMPLATE_MARK}${id}`), template);\r\n  if (template.namespaceURI === SVG_NS) {\r\n    // SVGタグ内のtemplateタグを想定\r\n    const newTemplate = document.createElement(\"template\");\r\n    for(let childNode of Array.from(template.childNodes)) {\r\n      newTemplate.content.appendChild(childNode);\r\n    }\r\n    const bindText = template.getAttribute(DATA_BIND_ATTRIBUTE);\r\n    newTemplate.setAttribute(DATA_BIND_ATTRIBUTE, bindText ?? \"\");\r\n    template = newTemplate;\r\n  }\r\n  template.content.querySelectorAll(\"template\").forEach(template => {\r\n    replaceTemplateTagWithComment(generateId(), template, rootId);\r\n  });\r\n  registerTemplate(id, template, rootId);\r\n  return id;\r\n}\r\n","import { replaceMustacheWithTemplateTag } from \"./replaceMustacheWithTemplateTag\";\r\nimport { replaceTemplateTagWithComment } from \"./replaceTemplateTagWithComment\";\r\n\r\nexport function registerHtml(id: number, html:string) {\r\n  const template = document.createElement(\"template\");\r\n  template.dataset.id = id.toString();\r\n  template.innerHTML = replaceMustacheWithTemplateTag(html);\r\n  replaceTemplateTagWithComment(id, template);\r\n}","import { inputBuiltinFilters, outputBuiltinFilters } from \"../Filter/builtinFilters\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { generateId } from \"../GlobalId/generateId\";\r\nimport { getStateClassById, registerStateClass } from \"../StateClass/registerStateClass\";\r\nimport { getStyleSheetById } from \"../StyleSheet/registerStyleSheet\";\r\nimport { registerCss } from \"../StyleSheet/regsiterCss\";\r\nimport { createComponentEngine } from \"../ComponentEngine/ComponentEngine\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { registerHtml } from \"../Template/registerHtml\";\r\nimport { getTemplateById } from \"../Template/registerTemplate\";\r\nimport { getBaseClass } from \"./getBaseClass\";\r\nimport { getComponentConfig } from \"./getComponentConfig\";\r\nimport { IComponent, QuelComponent, IUserComponentData, IComponentStatic, QuelComponentClass } from \"./types\";\r\nimport { getListPathsSetById, getPathsSetById } from \"../BindingBuilder/registerDataBindAttributes\";\r\n\r\nexport function createComponentClass(componentData: IUserComponentData): QuelComponentClass {\r\n  const componentConfig = getComponentConfig(componentData.config);\r\n  const id = generateId();\r\n  const { html, css, stateClass } = componentData;\r\n  const inputFilters:FilterWithOptions = Object.assign({}, inputBuiltinFilters);\r\n  const outputFilters:FilterWithOptions = Object.assign({}, outputBuiltinFilters);\r\n  registerHtml(id, html);\r\n  registerCss(id, css);\r\n  registerStateClass(id, stateClass);\r\n  const baseClass = getBaseClass(componentConfig.extends);\r\n  const extendTagName = componentConfig.extends;\r\n  return class extends baseClass implements IComponent {\r\n    #engine: IComponentEngine;\r\n\r\n    constructor() {\r\n      super();\r\n      this.#engine = createComponentEngine(componentConfig, this as QuelComponent);\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.#engine.connectedCallback();\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.#engine.disconnectedCallback();\r\n    }\r\n\r\n    static define(tagName:string) {\r\n      if (extendTagName) {\r\n        customElements.define(tagName, this, { extends: extendTagName });\r\n      } else {\r\n        customElements.define(tagName, this);\r\n      }\r\n    }\r\n\r\n    static get id():number {\r\n      return id;\r\n    }\r\n    static #html:string = html;\r\n    static get html():string {\r\n      return this.#html;\r\n    }\r\n    static set html(value:string) {\r\n      this.#html = value;\r\n      registerHtml(this.id, value);\r\n      this.#template = null;\r\n    }\r\n\r\n    static #css:string = css;\r\n    static get css() {\r\n      return this.#css;\r\n    }\r\n    static set css(value:string) {\r\n      this.#css = value;\r\n      registerCss(this.id, value);\r\n      this.#styleSheet = null;\r\n    }\r\n    static #template: HTMLTemplateElement | null = null;\r\n    static get template():HTMLTemplateElement {\r\n      if (!this.#template) {\r\n        this.#template = getTemplateById(this.id);\r\n      }\r\n      return this.#template;\r\n    }\r\n    static #styleSheet: CSSStyleSheet | null = null;\r\n    static get styleSheet():CSSStyleSheet {\r\n      if (!this.#styleSheet) {\r\n        this.#styleSheet = getStyleSheetById(this.id);\r\n      }\r\n      return this.#styleSheet;\r\n    }\r\n    static #stateClass: typeof Object | null = null;\r\n    static get stateClass():typeof Object {\r\n      if (!this.#stateClass) {\r\n        this.#stateClass = getStateClassById(this.id);\r\n      }\r\n      return this.#stateClass;\r\n    }\r\n    static #inputFilters:FilterWithOptions = inputFilters;\r\n    static get inputFilters():FilterWithOptions {\r\n      return this.#inputFilters;\r\n    }\r\n    static #outputFilters:FilterWithOptions = outputFilters;\r\n    static get outputFilters():FilterWithOptions {\r\n      return this.#outputFilters;\r\n    }\r\n    static get listPaths(): Set<string> {\r\n      return getListPathsSetById(this.id);\r\n    }\r\n    static get paths(): Set<string> {\r\n      return getPathsSetById(this.id);\r\n    }\r\n    static #trackedGetters: Set<string> | null = null;\r\n    static get trackedGetters(): Set<string> {\r\n      if(this.#trackedGetters === null) {\r\n        this.#trackedGetters = new Set<string>();\r\n        let currentProto = this.stateClass.prototype;\r\n        while (currentProto && currentProto !== Object.prototype) {\r\n          const trackedGetters = Object.getOwnPropertyDescriptors(currentProto);\r\n          if (trackedGetters) {\r\n            for (const [key, desc] of Object.entries(trackedGetters)) {\r\n              if (desc.get) {\r\n                this.#trackedGetters.add(key);\r\n              }\r\n            }\r\n          }\r\n          currentProto = Object.getPrototypeOf(currentProto);\r\n        }\r\n      }\r\n      return this.#trackedGetters;\r\n\r\n    }\r\n  } as QuelComponentClass;\r\n}\r\n","import { getGlobalConfig } from \"./getGlobalConfig\";\r\nimport { IUserConfig, IComponentConfig } from \"./types\";\r\n\r\nexport function getComponentConfig(userConfig: IUserConfig): IComponentConfig {\r\n  const globalConfig = getGlobalConfig();\r\n  return {\r\n    enableShadowDom: userConfig.enableShadowDom ?? globalConfig.enableShadowDom,\r\n    extends        : userConfig.extends ?? null,\r\n  };\r\n}","import { Constructor } from \"./types\";\r\n\r\nexport function getBaseClass(extendTagName: string | null):Constructor<HTMLElement> {\r\n  return extendTagName ? (document.createElement(extendTagName).constructor as Constructor<HTMLElement>) : HTMLElement;\r\n}","import { IUserComponentData } from \"./types\";\r\n\r\nfunction escapeEmbed(html: string): string {\r\n  return html.replaceAll(/\\{\\{([^\\}]+)\\}\\}/g, (match, expr) => {\r\n    return `<!--{{${expr}}}-->`;\r\n  });\r\n}\r\n\r\nfunction unescapeEmbed(html:string):string {\r\n  return html.replaceAll(/<!--\\{\\{([^\\}]+)\\}\\}-->/g, (match, expr) => {\r\n    return `{{${expr}}}`;\r\n  });\r\n}\r\n\r\nexport async function createSingleFileComponent(text: string): Promise<IUserComponentData> {\r\n  const template = document.createElement(\"template\");\r\n  template.innerHTML = escapeEmbed(text);\r\n\r\n  const html = template.content.querySelector(\"template\");\r\n  html?.remove();\r\n\r\n  const script = template.content.querySelector(\"script\");\r\n  const scriptModule = script ? await import(\"data:text/javascript;charset=utf-8,\" + script.text) : {};\r\n  script?.remove();\r\n\r\n  const style = template.content.querySelector(\"style\");\r\n  style?.remove();\r\n\r\n  const stateClass = scriptModule.default ?? class {};\r\n  return {\r\n    text,\r\n    html      : unescapeEmbed(html?.innerHTML ?? \"\").trim(),\r\n    css       : style?.textContent ?? \"\",\r\n    stateClass,\r\n    config    : stateClass.$config ?? {}\r\n  }\r\n}","import { createSingleFileComponent } from \"./createSingleFileComponent\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nexport async function loadSingleFileComponent(path: string): Promise<IUserComponentData> {\r\n  const response = await fetch(import.meta.resolve(path));\r\n  const text = await response.text();\r\n  return createSingleFileComponent(text);\r\n}\r\n","import { registerSingleFileComponents as _registerSingleFileComponents } from \"./WebComponents/registerSingleFIleComponents\";\r\nimport { getGlobalConfig as _getGlobalConfig } from \"./WebComponents/getGlobalConfig\";\r\nimport { IConfig } from \"./WebComponents/types\";\r\n\r\nexport function registerSingleFileComponents(singleFileComponents: Record<string, string>) {\r\n  _registerSingleFileComponents(singleFileComponents);\r\n}\r\n\r\nexport const defineComponents = registerSingleFileComponents;\r\n\r\nexport function getGlobalConfig(): IConfig {\r\n  return _getGlobalConfig();\r\n}\r\n\r\n","import { createComponentClass } from \"./createComponentClass\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent\";\r\nimport { registerComponentClass } from \"./registerComponentClass\";\r\nimport { SingleFileComponents } from \"./types\";\r\n\r\nexport async function registerSingleFileComponents(singleFileComponents:SingleFileComponents):Promise<void> {\r\n  const promises = Promise.all(Object.entries(singleFileComponents).map(async ([tagName, path]) => {\r\n    const componentData = await loadSingleFileComponent(path);\r\n    const componentClass = createComponentClass(componentData);\r\n    registerComponentClass(tagName, componentClass);\r\n  }));\r\n  await promises;\r\n}","import { QuelComponentClass } from \"./types\";\r\n\r\nexport function registerComponentClass(tagName: string, componentClass: QuelComponentClass) {\r\n  componentClass.define(tagName);\r\n}"],"names":["globalConfig","debug","locale","enableShadowDom","getGlobalConfig","optionsRequired","fnName","Error","optionMustBeNumber","valueMustBeNumber","valueMustBeDate","config","builtinFilters","eq","options","opt","optValue","Number","isNaN","value","ne","not","valueMustBeBoolean","lt","le","gt","ge","inc","dec","mul","div","fix","toFixed","toLocaleString","uc","toString","toUpperCase","lc","toLowerCase","cap","v","length","charAt","slice","trim","substr","opt1","opt1Value","opt2","opt2Value","pad","padStart","rep","repeat","rev","split","reverse","join","int","parseInt","float","parseFloat","round","Math","pow","floor","ceil","percent","date","Date","toLocaleDateString","time","toLocaleTimeString","datetime","ymd","year","getFullYear","month","getMonth","day","getDate","falsy","truthy","defaults","boolean","Boolean","number","string","String","null","outputBuiltinFilters","inputBuiltinFilters","id","generateId","raiseError","message","stateClassById","styleSheetById","registerCss","css","styleSheet","CSSStyleSheet","replaceSync","registerStyleSheet","textToFilter","filters","text","filter","name","cache","Map","createFilters","texts","result","get","i","push","set","BindingNode","binding","node","event","bindContents","Set","this","constructor","init","update","assignValue","bindingState","filteredValue","updateElements","listIndexes","values","isSelectElement","HTMLSelectElement","BindingNodeAttribute","subName","super","setAttribute","BindingNodeCheckbox","Array","isArray","element","checked","map","_val","includes","BindingNodeClassList","className","BindingNodeClassName","classList","add","remove","BindingNodeEvent","addEventListener","e","handler","engine","stateProxy","updater","loopContext","parentBindContent","currentLoopContext","indexes","serialize","context","listIndex","index","preventDefault","addProcess","async","typeOfValue","setLoopContext","Reflect","apply","createBindingNodeEvent","filterTexts","filterFns","DATA_BIND_ATTRIBUTE","COMMENT_EMBED_MARK","COMMENT_TEMPLATE_MARK","BindingNodeBlock","textContent","BindingNodeIf","bindContent","trueBindContents","falseBindContents","createBindContent","parentNode","render","mountBefore","nextSibling","unmount","BindingNodeFor","bindContentsSet","bindContentByListIndex","WeakMap","bindContentPool","bindContentLastIndex","assignListIndex","pattern","deleteBindContent","clearListIndex","poolLength","listIndexesSet","getListIndexesSet","info","newBindContensSet","lastBindContent","lastNode","getLastNode","mountAfter","firstChildNode","removeBindContentsSet","difference","oldListValues","getList","currentBindContents","from","targetBindContents","lastChildNode","oldValue","targetIndex","indexOf","prevBindContent","saveList","createBindingNodeFor","DEFAULT_PROPERTY","defaultPropertyByElementType","xt","Nt","button","_cache","getDefaultPropertyByNodeType","HTMLElement","HTMLTextAreaElement","HTMLOptionElement","HTMLButtonElement","HTMLAnchorElement","HTMLFormElement","HTMLInputElement","type","SVGElement","undefined","Text","Template","symbolName","GetByRefSymbol","Symbol","for","SetByRefSymbol","SetCacheableSymbol","ConnectedCallbackSymbol","DisconnectedCallbackSymbol","ResolveSymbol","GetAllSymbol","defaultEventByName","selected","BindingNodeProperty","defaultName","nodeType","key","getDefaultName","eventName","createBindingNodeProperty","BindingNodeRadio","BindingNodeStyle","style","setProperty","nodePropertyConstructorByNameByIsComment","vt","It","nodePropertyConstructorByFirstName","Ct","getBindingNodeCreator","propertyName","isComment","Comment","isElement","Element","fn","bindingNodeCreatorByName","nameElements","bindingNodeCreatorByFirstName","startsWith","_getBindingNodeCreator","StructuredPathInfo","static","pathSegments","lastSegment","cumulativePaths","cumulativeInfos","wildcardPaths","wildcardInfos","wildcardParentPaths","wildcardParentInfos","lastWildcardPath","lastWildcardInfo","parentPath","parentInfo","wildcardCount","getPattern","_pattern","getStructuredPathInfo","currentPatternPath","prevPatternPath","reservedWords","structuredPath","has","BindingState","listIndexRef","state","deref","find","saveBinding","BindingStateIndex","indexNumber","loopContexts","bindings","bindingsByListIndex","ereg","RegExp","getBindingStateCreator","test","createBindingStateIndex","createBindingState","getTextByNodeType","getAttribute","St","getTemplateById","nodeTypeByNodeKey","getNodeType","nodeKey","createNodeKey","getNodeTypeByNode","s","re","decode","m","exec","decodeURIComponent","parseFilter","parseProperty","property","parseExpressions","expression","bindExpression","nodePropertyText","statePropertyText","nodeProperty","inputFilterTexts","stateProperty","outputFilterTexts","parseExpression","removeAttributeFromElement","removeAttribute","removeAttributeByNodeType","replaceTextNodeFn","textNode","document","createTextNode","replaceChild","DataBindAttributes","nodePath","bindTexts","creatorByText","bindText","getDataBindText","removeDataBindAttribute","replaceTextNodeFromComment","routeIndexes","childNodes","getAbsoluteNodePath","parseBindText","creator","createBindingNode","getNodesHavingDataBind","root","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","SHOW_COMMENT","acceptNode","hasAttribute","FILTER_ACCEPT","FILTER_SKIP","isCommentNode","nextNode","currentNode","listDataBindAttributesById","listPathsSetById","pathsSetById","getDataBindAttributesFromTemplate","content","createDataBindAttributes","templateById","registerTemplate","template","rootId","forEach","Node","TEXT_NODE","nodeValue","removeChild","dataBindAttributes","paths","listPaths","attribute","j","registerDataBindAttributes","Binding","bindingNode","inputFilters","outputFilters","createBinding","LoopContext","path","WeakRef","parentLoopContext","currentBinding","parentBinding","walk","callback","results","unshift","bindingsWithSelectElement","createBindings","attributes","getDataBindAttributesById","reduce","BindContent","fragment","isMounted","lastBinding","size","at","importNode","createContent","createLoopContext","mount","appendChild","beforeNode","insertBefore","afterNode","ResolvedPathInfo","elements","wildcardType","wildcardIndexes","tmpPatternElements","incompleteCount","completeCount","lastPath","getResolvedPathInfo","ListIndex","parentListIndex","position","truncate","reverseIterator","iterator","next","getStatePropertyRefId","listIndexMaxId","matchIndexPropertyName","getListIndex","getContextListIndex","wildcardParentPattern","StateHandler","cacheable","_getByRef","target","receiver","lastTrackingStack","lastPattern","addDependentProp","refId","setStatePropertyRef","parentValue","getByRef","trackingStack","setTracking","pop","trackedGetters","setByRef","addUpdatedStatePropertyRefValue","setCacheable","prop","self","call","resolve","wildcardPattern","walkWildcardPattern","wildardIndexPos","indexPos","parentIndexes","listIndexSet","concat","resultIndexes","resultValues","callableSymbols","ref","getLastStatePropertyRef","resolvedInfo","BLANK_LISTINDEXES_SET","buildListIndexTreeSub","listInfos","oldListIndexesSet","oldListIndexesByItem","groupBy","newListIndexesSet","item","oldListIndexes","curListIndex","shift","addUpdatedListIndex","saveListIndexesSet","searchPath","subListIndex","subValue","buildListIndexTree","listInfoSet","extractListIndexes","_extractListIndexes","pos","currentListIndex","resultListIndexes","wildcardParentInfo","loopListIndex","_collectAffectedGetters","refInfo","refListIndex","resultPathInfos","resultRefs","dependentPathInfos","dependentTree","dependentPathInfo","dependentListIndex","updateList","extractlistIndexes","collectAffectedGetters","updateRefs","Updater","processList","updatedProperties","updatedValues","process","waitForQueueEntry","terminate","waitForMainLoopTerminate","Promise","withResolvers","main","waitForComponentInit","promise","performance","mark","updatingCount","measure","console","log","getEntriesByType","clearMeasures","clearMarks","error","updateState","rebuild","retArrayElementBindings","retBindings","processedListIndexes","processedPropertyRefIdsSet","updatedProiperties","updatedRefs","arrayPropertyRefs","arrayElementPropertyRefs","clear","statePropertyRefId","statePropertyRef","elementInfoSet","getBindings","builtStatePropertyRefIds","arrayPropertyRef","parentRefByRefId","statePropertyRefByStatePropertyRefId","Object","parentRefId","parentRefIdKey","refs","entries","parentRef","arrayElementBinding","updatingRefs","updatingRef","arrayElementBindings","oe","qe","attachShadow","extends","tagName","createElement","canHaveShadowRoot","mode","adoptedStyleSheets","shadowRootOrDocument","ShadowRoot","getParentShadowRoot","styleSheets","ComponentEngine","stateClass","baseClass","owner","waitForInitialize","stackStructuredPathInfo","stackListIndex","componentClass","Proxy","createUpdater","checkDependentProp","listPath","connectedCallback","shadowRoot","disconnectedCallback","asyncSetStatePropertyRef","lastRef","getLoopContexts","saveInfoByListIndexByResolvedPathInfoId","saveInfoByStructuredPathId","createSaveInfo","list","getSaveInfoByStatePropertyRef","saveInfo","saveInfoByListIndex","dependents","MUSTACHE_REGEXP","MUSTACHE_TYPES","replaceTemplateTagWithComment","createComment","namespaceURI","newTemplate","childNode","querySelectorAll","registerHtml","html","dataset","innerHTML","stack","replaceAll","match","expr","remain","currentInfo","endTags","lastInfo","replaceMustacheWithTemplateTag","createComponentClass","componentData","componentConfig","userConfig","De","getComponentConfig","nn","sn","Ue","assign","registerStateClass","extendTagName","getBaseClass","component","createComponentEngine","define","customElements","getStyleSheetById","getStateClassById","getListPathsSetById","getPathsSetById","currentProto","prototype","getOwnPropertyDescriptors","desc","getPrototypeOf","unescapeEmbed","loadSingleFileComponent","response","fetch","escapeEmbed","querySelector","script","scriptModule","import","default","$config","createSingleFileComponent","registerSingleFileComponents","singleFileComponents","promises","all","registerComponentClass","_registerSingleFileComponents","defineComponents","_getGlobalConfig"],"mappings":"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"}