{"version":3,"file":"structive.min.js","sources":["../src/WebComponents/getGlobalConfig.ts","../src/Filter/errorMessages.ts","../src/Filter/builtinFilters.ts","../src/GlobalId/generateId.ts","../src/utils.ts","../src/StateClass/registerStateClass.ts","../src/StyleSheet/registerStyleSheet.ts","../src/StyleSheet/regsiterCss.ts","../src/BindingBuilder/resolveNodeFromPath.ts","../src/BindingBuilder/createFilters.ts","../src/DataBinding/BindingNode/BindingNode.ts","../src/DataBinding/BindingNode/BindingNodeAttribute.ts","../src/DataBinding/BindingNode/BindingNodeCheckbox.ts","../src/DataBinding/BindingNode/BindingNodeClassList.ts","../src/DataBinding/BindingNode/BindingNodeClassName.ts","../src/constants.ts","../src/StateProperty/getStructuredPathInfo.ts","../src/StateProperty/getResolvedPathInfo.ts","../src/StateClass/methods/getContextListIndex.ts","../src/StateClass/methods/getListIndex.ts","../src/StateClass/symbols.ts","../src/StatePropertyRef/StatepropertyRef.ts","../src/StateClass/methods/checkDependency.ts","../src/StateClass/methods/setStatePropertyRef.ts","../src/StateClass/methods/getByRefWritable.ts","../src/StateClass/methods/setByRef.ts","../src/StateClass/apis/resolveWritable.ts","../src/StateClass/apis/trackDependency.ts","../src/StateClass/traps/indexByIndexName.ts","../src/StateClass/traps/getWritable.ts","../src/StateClass/apis/getAllWritable.ts","../src/StateClass/apis/connectedCallback.ts","../src/StateClass/apis/disconnectedCallback.ts","../src/StateClass/useWritableStateProxy.ts","../src/StateClass/traps/set.ts","../src/StateClass/methods/setLoopContext.ts","../src/StateClass/methods/asyncSetStatePropertyRef.ts","../src/ListIndex/ListIndex.ts","../src/PathTree/PathNode.ts","../src/StateClass/methods/getByRefReadonly.ts","../src/StateClass/apis/resolveReadonly.ts","../src/StateClass/traps/getReadonly.ts","../src/StateClass/apis/getAllReadonly.ts","../src/StateClass/methods/setCacheable.ts","../src/StateClass/createReadonlyStateProxy.ts","../src/Updater/Renderer.ts","../src/ListDiff/ListDiff.ts","../src/Updater/Updater.ts","../src/DataBinding/BindingNode/BindingNodeEvent.ts","../src/DataBinding/BindingNode/BindingNodeBlock.ts","../src/DataBinding/BindingNode/BindingNodeIf.ts","../src/DataBinding/BindingNode/BindingNodeFor.ts","../src/BindingBuilder/getDefaultName.ts","../src/DataBinding/BindingNode/BindingNodeProperty.ts","../src/DataBinding/BindingNode/BindingNodeRadio.ts","../src/DataBinding/BindingNode/BindingNodeStyle.ts","../src/ComponentStateInput/symbols.ts","../src/WebComponents/findStructiveParent.ts","../src/DataBinding/BindingNode/BindingNodeComponent.ts","../src/BindingBuilder/getBindingNodeCreator.ts","../src/DataBinding/BindingState/BindingState.ts","../src/DataBinding/BindingState/BindingStateIndex.ts","../src/BindingBuilder/getBindingStateCreator.ts","../src/BindingBuilder/getNodeType.ts","../src/BindingBuilder/parseBindText.ts","../src/BindingBuilder/removeDataBindAttribute.ts","../src/BindingBuilder/replaceTextNodeFromComment.ts","../src/BindingBuilder/createDataBindAttributes.ts","../src/BindingBuilder/getDataBindText.ts","../src/BindingBuilder/getAbsoluteNodePath.ts","../src/BindingBuilder/getNodesHavingDataBind.ts","../src/BindingBuilder/registerDataBindAttributes.ts","../src/Template/registerTemplate.ts","../src/Template/removeEmptyTextNodes.ts","../src/DataBinding/Binding.ts","../src/LoopContext/createLoopContext.ts","../src/DataBinding/BindContent.ts","../src/WebComponents/loadFromImportMap.ts","../src/ComponentEngine/attachShadow.ts","../src/ComponentEngine/canHaveShadowRoot.ts","../src/ComponentStateBinding/createComponentStateBinding.ts","../src/ComponentStateInput/createComponentStateInput.ts","../src/ComponentStateOutput/createComponentStateOutput.ts","../src/ComponentEngine/ComponentEngine.ts","../src/Template/replaceMustacheWithTemplateTag.ts","../src/Template/replaceTemplateTagWithComment.ts","../src/Template/registerHtml.ts","../src/StateProperty/createAccessorFunctions.ts","../src/PathManager/PathManager.ts","../src/WebComponents/createComponentClass.ts","../src/WebComponents/getComponentConfig.ts","../src/WebComponents/getBaseClass.ts","../src/WebComponents/createSingleFileComponent.ts","../src/WebComponents/loadSingleFileComponent.ts","../src/WebComponents/registerComponentClass.ts","../src/WebComponents/loadImportmap.ts","../src/Router/Router.ts","../src/MainWrapper/MainWrapper.ts","../src/exports.ts","../src/WebComponents/registerSingleFIleComponents.ts","../src/bootstrap.ts"],"sourcesContent":["/**\r\n * getGlobalConfig.ts\r\n *\r\n * Structive全体で利用するグローバル設定（IConfig）を定義・取得するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - globalConfig: デフォルトのグローバル設定値（debug, locale, enableShadowDom等）を定義\r\n * - getGlobalConfig: グローバル設定オブジェクトを返す関数\r\n * - config: getGlobalConfig()のエイリアスとして即時取得用にエクスポート\r\n *\r\n * 設計ポイント:\r\n * - コンポーネント全体で共通利用する設定値を一元管理\r\n * - デフォルト値を明示し、拡張やカスタマイズにも対応しやすい設計\r\n */\r\nimport { IConfig } from \"./types\";\r\n\r\nconst globalConfig: IConfig = {\r\n  \"debug\"                : false,\r\n  \"locale\"               : \"en-US\", // The locale of the component, ex. \"en-US\", default is \"en-US\"\r\n  \"enableShadowDom\"      : true, // Whether to use Shadow DOM or not\r\n  \"enableMainWrapper\"    : true, // Whether to use the main wrapper or not\r\n  \"enableRouter\"         : true, // Whether to use the router or not\r\n  \"autoInsertMainWrapper\": false, // Whether to automatically insert the main wrapper or not\r\n  \"autoInit\"             : true, // Whether to automatically initialize the component or not\r\n  \"mainTagName\"          : \"app-main\", // The tag name of the main wrapper, default is \"app-main\"\r\n  \"routerTagName\"        : \"view-router\", // The tag name of the router, default is \"view-router\"\r\n  \"layoutPath\"           : \"\", // The path to the layout file, default is \"\"\r\n  \"autoLoadFromImportMap\": false, // Whether to automatically load the component from the import map or not\r\n  \"optimizeList\"         : true, // Whether to optimize the list or not\r\n  \"optimizeListElements\" : true, // Whether to optimize the list elements or not\r\n  \"optimizeAccessor\"     : true, // Whether to optimize the accessors or not\r\n};\r\n\r\n\r\nexport function getGlobalConfig():IConfig {\r\n  return globalConfig;\r\n}\r\n\r\nexport const config = getGlobalConfig();\r\n","/**\r\n * errorMessages.ts\r\n *\r\n * フィルタ関数などで利用するエラーメッセージ生成ユーティリティです。\r\n *\r\n * 主な役割:\r\n * - フィルタのオプションや値の型チェックで条件を満たさない場合に、分かりやすいエラーメッセージを投げる\r\n * - 関数名を引数に取り、どのフィルタでエラーが発生したかを明示\r\n *\r\n * 設計ポイント:\r\n * - optionsRequired: オプションが必須なフィルタで未指定時にエラー\r\n * - optionMustBeNumber: オプション値が数値でない場合にエラー\r\n * - valueMustBeNumber: 値が数値でない場合にエラー\r\n * - valueMustBeBoolean: 値がbooleanでない場合にエラー\r\n * - valueMustBeDate: 値がDateでない場合にエラー\r\n */\r\nexport function optionsRequired(fnName:string): never {\r\n  throw new Error(`${fnName} requires at least one option`);\r\n}\r\n\r\nexport function optionMustBeNumber(fnName:string): never {\r\n  throw new Error(`${fnName} requires a number as option`);\r\n}\r\n\r\nexport function valueMustBeNumber(fnName:string): never {\r\n  throw new Error(`${fnName} requires a number value`);\r\n}\r\n\r\nexport function valueMustBeBoolean(fnName:string): never {\r\n  throw new Error(`${fnName} requires a boolean value`);\r\n}\r\n\r\nexport function valueMustBeDate(fnName:string): never {\r\n  throw new Error(`${fnName} requires a date value`);\r\n}","/**\r\n * builtinFilters.ts\r\n *\r\n * Structiveで利用可能な組み込みフィルタ関数群の実装ファイルです。\r\n *\r\n * 主な役割:\r\n * - 数値・文字列・日付・真偽値などの変換・比較・整形・判定用フィルタを提供\r\n * - フィルタ名ごとにオプション付きの関数を定義し、バインディング時に柔軟に利用可能\r\n * - input/output両方のフィルタとして共通利用できる設計\r\n *\r\n * 設計ポイント:\r\n * - eq, ne, lt, gt, inc, fix, locale, uc, lc, cap, trim, slice, pad, int, float, round, date, time, ymd, falsy, truthy, defaults, boolean, number, string, null など多彩なフィルタを網羅\r\n * - オプション値の型チェックやエラーハンドリングも充実\r\n * - FilterWithOptions型でフィルタ関数群を一元管理し、拡張も容易\r\n * - builtinFilterFnでフィルタ名・オプションからフィルタ関数を動的に取得可能\r\n */\r\nimport { getGlobalConfig } from \"../WebComponents/getGlobalConfig.js\";\r\nimport { optionMustBeNumber, optionsRequired, valueMustBeBoolean, valueMustBeDate, valueMustBeNumber } from \"./errorMessages.js\";\r\nimport { FilterWithOptions } from \"./types\";\r\n\r\nconst config = getGlobalConfig();\r\n\r\nconst eq = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('eq');\r\n  return (value: any) => {\r\n    // 型を揃えて比較\r\n    if (typeof value === 'number') {\r\n      const optValue = Number(opt);\r\n      if (isNaN(optValue)) optionMustBeNumber('eq');\r\n      return value === optValue;\r\n    }\r\n    if (typeof value === 'string') {\r\n      return value === opt;\r\n    }\r\n    // その他は厳密等価\r\n    return value === opt;\r\n  }\r\n}\r\n\r\nconst ne = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('ne');\r\n  return (value: any) => {\r\n    // 型を揃えて比較\r\n    if (typeof value === 'number') {\r\n      const optValue = Number(opt);\r\n      if (isNaN(optValue)) optionMustBeNumber('eq');\r\n      return value !== optValue;\r\n    }\r\n    if (typeof value === 'string') {\r\n      return value !== opt;\r\n    }\r\n    // その他は厳密等価\r\n    return value !== opt;\r\n  }\r\n}\r\n\r\nconst not = (options?:string[]) => {\r\n  return (value: any) => {\r\n    if (typeof value !== 'boolean') valueMustBeBoolean('not');\r\n    return !value;\r\n  }\r\n}\r\n\r\nconst lt = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('lt');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('lt');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('lt');\r\n    return value < optValue;\r\n  }\r\n}\r\n\r\nconst le = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('le');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('le');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('le');\r\n    return value <= optValue;\r\n  }\r\n}\r\n\r\nconst gt = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('gt');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('gt');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('gt');\r\n    return value > optValue;\r\n  }\r\n}\r\n\r\nconst ge = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('ge');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('ge');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ge');\r\n    return value >= optValue;\r\n  }\r\n}\r\n\r\nconst inc = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('inc');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('inc');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('inc');\r\n    return value + optValue;\r\n  }\r\n}\r\n\r\nconst dec = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('dec');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('dec');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('dec');\r\n    return value - optValue;\r\n  }\r\n}\r\n\r\nconst mul = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('mul');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('mul');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('mul');\r\n    return value * optValue;\r\n  }\r\n}\r\n\r\nconst div = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('div');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('div');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('div');\r\n    return value / optValue;\r\n  }\r\n}\r\n\r\nconst fix = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('div');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('div');\r\n    return value.toFixed(optValue);\r\n  }\r\n}\r\n\r\nconst locale = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('locale');\r\n    return value.toLocaleString(opt);\r\n  }\r\n}\r\n\r\nconst uc = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().toUpperCase();\r\n  }\r\n}\r\n\r\nconst lc = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().toLowerCase();\r\n  }\r\n}\r\n\r\nconst cap = (options?:string[]) => {\r\n  return (value: any) => {\r\n    const v = value.toString();\r\n    if (v.length === 0) return v;\r\n    if (v.length === 1) return v.toUpperCase();\r\n    return v.charAt(0).toUpperCase() + v.slice(1);\r\n  }\r\n}\r\n\r\nconst trim = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().trim();\r\n  }\r\n}\r\n\r\nconst slice = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('slice');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('slice');\r\n  return (value: any) => {\r\n    return value.toString().slice(optValue);\r\n  }\r\n}\r\n\r\nconst substr = (options?:string[]) => {\r\n  const opt1 = options?.[0] ?? optionsRequired('substr');\r\n  const opt1Value = Number(opt1);\r\n  if (isNaN(opt1Value)) optionMustBeNumber('substr');\r\n  const opt2 = options?.[1] ?? optionsRequired('substr');\r\n  const opt2Value = Number(opt2);\r\n  if (isNaN(opt2Value)) optionMustBeNumber('substr');\r\n  return (value: any) => {\r\n    return value.toString().substr(opt1Value, opt2Value);\r\n  }\r\n}\r\n\r\nconst pad = (options?:string[]) => {\r\n  const opt1 = options?.[0] ?? optionsRequired('pad');\r\n  const opt1Value = Number(opt1);\r\n  if (isNaN(opt1Value)) optionMustBeNumber('pad');\r\n  const opt2 = options?.[1] ?? '0';\r\n  const opt2Value = opt2;\r\n  return (value: any) => {\r\n    return value.toString().padStart(opt1Value, opt2Value);\r\n  }\r\n}\r\n\r\nconst rep = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('rep');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('rep');\r\n  return (value: any) => {\r\n    return value.toString().repeat(optValue);\r\n  }\r\n}\r\n\r\nconst rev = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().split('').reverse().join('');\r\n  }\r\n}\r\n\r\nconst int = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return parseInt(value, 10);\r\n  }\r\n}\r\n\r\nconst float = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return parseFloat(value);\r\n  }\r\n}\r\n\r\nconst round = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('round');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('round');\r\n    return Math.round(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst floor = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('floor');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('floor');\r\n    return Math.floor(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst ceil = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('ceil');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ceil');\r\n    return Math.ceil(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst percent = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('percent');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('percent');\r\n    return value.toFixed(optValue) + '%';\r\n  }\r\n}\r\n\r\nconst date = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date))  valueMustBeDate('date');\r\n    return value.toLocaleDateString(opt);\r\n  }\r\n}\r\n\r\nconst time = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('time');\r\n    return value.toLocaleTimeString(opt);\r\n  }\r\n}\r\n\r\nconst datetime = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('datetime');\r\n    return value.toLocaleString(opt);\r\n  }\r\n}\r\n\r\nconst ymd = (options?:string[]) => {\r\n  const opt = options?.[0] ?? '-';\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('ymd');\r\n    const year = value.getFullYear().toString();\r\n    const month = (value.getMonth() + 1).toString().padStart(2, '0');\r\n    const day = value.getDate().toString().padStart(2, '0');\r\n    return `${year}${opt}${month}${opt}${day}`;\r\n  }\r\n}\r\n\r\nconst falsy = (options?:string[]) => {\r\n  return (value: any) => value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value);\r\n}\r\n\r\nconst truthy = (options?:string[]) => {\r\n  return (value: any) =>value !== false && value !== null && value !== undefined && value !== 0 && value !== '' && !Number.isNaN(value);\r\n}\r\n\r\nconst defaults = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('defaults');\r\n  return (value: any) => {\r\n    if (value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value)) return opt;\r\n    return value;\r\n  }\r\n}\r\n\r\nconst boolean = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return Boolean(value);\r\n  }\r\n}\r\n\r\nconst number = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return Number(value);\r\n  }\r\n}\r\n\r\nconst string = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return String(value);\r\n  }\r\n}\r\n\r\nconst _null = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return (value === \"\") ? null : value;\r\n  } \r\n}\r\n\r\nconst builtinFilters: FilterWithOptions = {\r\n  \"eq\": eq,\r\n  \"ne\": ne,\r\n  \"not\": not,\r\n\r\n  \"lt\": lt,\r\n  \"le\": le,\r\n  \"gt\": gt,\r\n  \"ge\": ge,\r\n\r\n  \"inc\": inc,\r\n  \"dec\": dec,\r\n  \"mul\": mul,\r\n  \"div\": div,\r\n\r\n  \"fix\": fix,\r\n  \"locale\": locale,\r\n  \"uc\": uc,\r\n  \"lc\": lc,\r\n  \"cap\": cap,\r\n  \"trim\": trim,\r\n  \"slice\": slice,\r\n  \"substr\": substr,\r\n  \"pad\": pad,\r\n  \"rep\": rep,\r\n  \"rev\": rev,\r\n\r\n  \"int\": int,\r\n  \"float\": float,\r\n  \"round\": round,\r\n  \"floor\": floor,\r\n  \"ceil\": ceil,\r\n  \"percent\": percent,\r\n\r\n  \"date\": date,\r\n  \"time\": time,\r\n  \"datetime\": datetime,\r\n  \"ymd\": ymd,\r\n\r\n  \"falsy\": falsy,\r\n  \"truthy\": truthy,\r\n  \"defaults\": defaults,\r\n\r\n  \"boolean\": boolean,\r\n  \"number\": number,\r\n  \"string\": string,\r\n  \"null\": _null,\r\n};\r\n\r\nexport const outputBuiltinFilters = builtinFilters;\r\nexport const inputBuiltinFilters = builtinFilters;\r\n\r\nexport const builtinFilterFn = (name:string, options: string[]) => (filters: FilterWithOptions) => {\r\n  const filter = filters[name];\r\n  if (!filter) throw new Error(`outputBuiltinFiltersFn: filter not found: ${name}`);\r\n  return filter(options);\r\n}\r\n\r\n","\r\nlet id = 0;\r\n\r\nexport function generateId(): number {\r\n  return ++id;\r\n}","\r\nexport function raiseError(message: string): never {\r\n  throw new Error(message);\r\n}\r\n","/**\r\n * registerStateClass.ts\r\n *\r\n * StateClassインスタンスをIDで登録・取得するための管理モジュールです。\r\n *\r\n * 主な役割:\r\n * - stateClassById: IDをキーにStateClassインスタンスを管理するレコード\r\n * - registerStateClass: 指定IDでStateClassインスタンスを登録\r\n * - getStateClassById: 指定IDのStateClassインスタンスを取得（未登録時はエラーを投げる）\r\n *\r\n * 設計ポイント:\r\n * - グローバルにStateClassインスタンスを一元管理し、ID経由で高速にアクセス可能\r\n * - 存在しないIDアクセス時はraiseErrorで明確な例外を発生\r\n */\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IStructiveState } from \"./types\";\r\n\r\nconst stateClassById: Record<number,IStructiveState> = {};\r\n\r\nexport function registerStateClass(id: number, stateClass: IStructiveState) {\r\n  stateClassById[id] = stateClass;\r\n}\r\n\r\nexport function getStateClassById(id: number): IStructiveState {\r\n  return stateClassById[id] ?? raiseError(`getStateClassById: stateClass not found: ${id}`);\r\n}\r\n","/**\r\n * registerStyleSheet.ts\r\n *\r\n * CSSStyleSheetインスタンスをIDで登録・取得するための管理モジュールです。\r\n *\r\n * 主な役割:\r\n * - styleSheetById: IDをキーにCSSStyleSheetインスタンスを管理するレコード\r\n * - registerStyleSheet: 指定IDでCSSStyleSheetインスタンスを登録\r\n * - getStyleSheetById: 指定IDのCSSStyleSheetインスタンスを取得（未登録時はエラーを投げる）\r\n *\r\n * 設計ポイント:\r\n * - グローバルにCSSStyleSheetインスタンスを一元管理し、ID経由で高速にアクセス可能\r\n * - 存在しないIDアクセス時はraiseErrorで明確な例外を発生\r\n */\r\nimport { raiseError } from \"../utils.js\";\r\n\r\nconst styleSheetById: Record<number,CSSStyleSheet> = {};\r\n\r\nexport function registerStyleSheet(id: number, css: CSSStyleSheet) {\r\n  styleSheetById[id] = css;\r\n}\r\n\r\nexport function getStyleSheetById(id: number): CSSStyleSheet {\r\n  return styleSheetById[id] ?? raiseError(`getStyleSheetById: stylesheet not found: ${id}`);\r\n}","/**\r\n * regsiterCss.ts\r\n *\r\n * CSS文字列をCSSStyleSheetとして生成し、IDで登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - CSS文字列からCSSStyleSheetインスタンスを生成\r\n * - registerStyleSheetを利用して、指定IDでCSSStyleSheetを登録\r\n *\r\n * 設計ポイント:\r\n * - styleSheet.replaceSyncで同期的にCSSを適用\r\n * - グローバルなスタイル管理や動的スタイル適用に利用可能\r\n */\r\nimport { registerStyleSheet } from \"./registerStyleSheet.js\";\r\n\r\nexport function registerCss(id: number, css: string) {\r\n  const styleSheet = new CSSStyleSheet();\r\n  styleSheet.replaceSync(css);\r\n  registerStyleSheet(id, styleSheet);\r\n}","import { NodePath } from \"./types\";\r\n\r\n/**\r\n * ルートノードとノードパス（インデックス配列）から、該当するノードを辿って取得するユーティリティ関数。\r\n *\r\n * - NodePathは各階層でのchildNodesのインデックスを表す配列\r\n * - ルートから順にchildNodes[index]を辿り、該当ノードを返す\r\n * - パスが不正な場合やノードが存在しない場合はnullを返す\r\n *\r\n * @param root  探索の起点となるルートノード\r\n * @param path  各階層のインデックス配列（NodePath）\r\n * @returns     パスで指定されたノード、またはnull\r\n */\r\nexport function resolveNodeFromPath(root: Node, path: NodePath): Node | null {\r\n  let node = root;\r\n  if (path.length === 0) return node;\r\n  // path.reduce()だと途中でnullになる可能性があるので、\r\n  for(let i = 0; i < path.length; i++) {\r\n    node = node?.childNodes[path[i]] ?? null;\r\n    if (node === null) break;\r\n  }\r\n  return node;\r\n}","import { FilterFn, Filters, FilterWithOptions } from \"../Filter/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IFilterText } from \"./types\";\r\n\r\n/**\r\n * フィルターテキスト（nameとoptionsを持つ）から、実際のフィルター関数（FilterFn）を生成する。\r\n * \r\n * - textToFilter: フィルターテキストから対応するフィルター関数を取得し、オプションを適用して返す。\r\n * - createFilters: フィルターテキスト配列からフィルター関数配列を生成し、同じ入力にはキャッシュを利用する。\r\n */\r\nfunction textToFilter(filters:FilterWithOptions, text: IFilterText): FilterFn {\r\n  const filter = filters[text.name];\r\n  if (!filter) raiseError(`outputBuiltinFiltersFn: filter not found: ${name}`);\r\n  return filter(text.options);\r\n}\r\n\r\nconst cache : Map<IFilterText[], Filters> = new Map();\r\n\r\n/**\r\n * フィルターテキスト配列（texts）からフィルター関数配列（Filters）を生成する。\r\n * すでに同じtextsがキャッシュされていればそれを返す。\r\n * \r\n * @param filters フィルター名→関数の辞書\r\n * @param texts   フィルターテキスト配列\r\n * @returns       フィルター関数配列\r\n */\r\nexport function createFilters(filters:FilterWithOptions, texts: IFilterText[]): Filters {\r\n  let result = cache.get(texts);\r\n  if (typeof result === \"undefined\") {\r\n    result = [];\r\n    for(let i = 0; i < texts.length; i++) {\r\n      result.push(textToFilter(filters, texts[i]));\r\n    }\r\n    cache.set(texts, result);\r\n  }\r\n  return result;\r\n}\r\n","import { Filters } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IReadonlyStateProxy } from \"../../StateClass/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IRenderer } from \"../../Updater/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { IBindingNode } from \"./types\";\r\n\r\n/**\r\n * BindingNodeクラスは、1つのバインディング対象ノード（ElementやTextなど）に対する\r\n * バインディング処理の基底クラスです。\r\n *\r\n * 主な役割:\r\n * - ノード・プロパティ名・フィルタ・デコレータ・バインディング情報の保持\r\n * - バインディング値の更新（update）、値の割り当て（assignValue）のインターフェース提供\r\n * - 複数バインド内容（bindContents）の管理\r\n * - サブクラスでassignValueやupdateElementsを実装し、各種ノード・プロパティごとのバインディング処理を拡張\r\n *\r\n * 設計ポイント:\r\n * - assignValue, updateElementsは未実装（サブクラスでオーバーライド必須）\r\n * - isSelectElement, value, filteredValue, isForなどはサブクラスで用途に応じて拡張\r\n * - フィルタやデコレータ、バインド内容の管理も柔軟に対応\r\n */\r\nexport class BindingNode implements IBindingNode {\r\n  #binding: IBinding;\r\n  #node: Node;\r\n  #name: string;\r\n  #filters: Filters;\r\n  #decorates: string[];\r\n  #bindContents: IBindContent[] = [];\r\n  get node(): Node {\r\n    return this.#node;\r\n  }\r\n  get name(): string {\r\n    return this.#name;\r\n  }\r\n  get subName(): string {\r\n    return this.#name;\r\n  }\r\n  get binding(): IBinding {\r\n    return this.#binding;\r\n  }\r\n  get decorates(): string[] {\r\n    return this.#decorates;\r\n  }\r\n  get filters(): Filters {\r\n    return this.#filters;\r\n  }\r\n  get bindContents(): IBindContent[] {\r\n    return this.#bindContents;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    this.#binding = binding;\r\n    this.#node = node;\r\n    this.#name = name;\r\n    this.#filters = filters;\r\n    this.#decorates = decorates;\r\n  }\r\n  init():void {\r\n    // サブクラスで初期化処理を実装可能\r\n  }\r\n  assignValue(value: any): void {\r\n    raiseError(`BindingNode: assignValue not implemented`);\r\n  }\r\n  updateElements(listIndexes: IListIndex[], values: any[]) {\r\n    raiseError(`BindingNode: updateElements not implemented`);\r\n  }\r\n  notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    // サブクラスで親子関係を考慮してバインディングの更新を通知する実装が可能\r\n  }\r\n  applyChange(renderer: IRenderer): void {\r\n    if (renderer.updatedBindings.has(this.binding)) return;\r\n    const filteredValue = this.binding.bindingState.getFilteredValue(renderer.readonlyState);\r\n    this.assignValue(filteredValue);\r\n    renderer.updatedBindings.add(this.binding);\r\n  }\r\n\r\n  get isSelectElement(): boolean {\r\n    return this.node instanceof HTMLSelectElement;\r\n  }\r\n  get value():any {\r\n    return null;\r\n  }\r\n  get filteredValue():any {\r\n    return null;\r\n  }\r\n  get isFor(): boolean {\r\n    return false;\r\n  }\r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeAttributeクラスは、属性バインディング（例: attr.src, attr.alt など）を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - ノード属性名（subName）を抽出し、値を属性としてElementにセット\r\n * - null/undefined/NaNの場合は空文字列に変換してセット\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - nameから属性名（subName）を抽出（例: \"attr.src\" → \"src\"）\r\n * - assignValueで属性値を常に文字列として設定\r\n * - createBindingNodeAttributeファクトリでフィルタ適用済みインスタンスを生成\r\n */\r\nclass BindingNodeAttribute extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as Element;\r\n    element.setAttribute(this.subName, value.toString());\r\n  }\r\n}\r\n\r\n/**\r\n * 属性バインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeAttributeインスタンスを生成\r\n */\r\nexport const createBindingNodeAttribute: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeAttribute(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeCheckboxクラスは、チェックボックス（input[type=\"checkbox\"]）の\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値（配列）に現在のvalueが含まれているかどうかでchecked状態を制御\r\n * - 値が配列でない場合はエラーを投げる\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - assignValueで配列内にvalueが含まれていればchecked=true\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeCheckbox extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError(`BindingNodeCheckbox.update: value is not array`, );\r\n    }\r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value.map(_val => _val.toString()).includes(element.value);\r\n  }\r\n}\r\n\r\n/**\r\n * チェックボックス用バインディングノード生成ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeCheckboxインスタンスを生成\r\n */\r\nexport const createBindingNodeCheckbox: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeCheckbox(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeClassListクラスは、class属性（classList）のバインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値（配列）を空白区切りのclass属性値としてElementにセット\r\n * - 値が配列でない場合はエラーを投げる\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - assignValueで配列を受け取り、join(\" \")でclassNameに反映\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeClassList extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError(`BindingNodeClassList.update: value is not array`);\r\n    }\r\n    const element = this.node as Element;\r\n    element.className = value.join(\" \");\r\n  }\r\n}\r\n\r\n/**\r\n * classList用バインディングノード生成ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeClassListインスタンスを生成\r\n */\r\nexport const createBindingNodeClassList: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeClassList(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeClassNameクラスは、class属性の個別クラス名（例: class.active など）の\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値（boolean）に応じて、指定クラス名（subName）をElementに追加・削除\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - nameからクラス名（subName）を抽出（例: \"class.active\" → \"active\"）\r\n * - assignValueでboolean値のみ許容し、型が異なる場合はエラー\r\n * - trueならclassList.add、falseならclassList.removeでクラス操作\r\n * - ファクトリ関数でフィルタ適用済みインスタンスを生成\r\n */\r\nclass BindingNodeClassName extends BindingNode {\r\n  #subName: string;\r\n  get subName(): string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (typeof value !== \"boolean\") {\r\n      raiseError(`BindingNodeClassName.update: value is not boolean`);\r\n    }\r\n    const element = this.node as Element;\r\n    if (value) {\r\n      element.classList.add(this.subName);\r\n    } else {\r\n      element.classList.remove(this.subName);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * class名バインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeClassNameインスタンスを生成\r\n */\r\nexport const createBindingNodeClassName: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeClassName(binding, node, name, filterFns, decorates);\r\n  }\r\n","export const DATA_BIND_ATTRIBUTE = \"data-bind\";\r\nexport const COMMENT_EMBED_MARK = \"@@:\"; // 埋め込み変数のマーク\r\nexport const COMMENT_TEMPLATE_MARK = \"@@|\"; // テンプレートのマーク\r\nexport const MAX_WILDCARD_DEPTH = 32; // ワイルドカードの最大深度\r\nexport const WILDCARD = \"*\"; // ワイルドカード\r\nexport const RESERVED_WORD_SET = new Set([\r\n  \"constructor\", \"prototype\", \"__proto__\", \"toString\",\r\n  \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",\r\n  \"watch\", \"unwatch\", \"eval\", \"arguments\",\r\n  \"let\", \"var\", \"const\", \"class\", \"function\",\r\n  \"null\", \"true\", \"false\", \"new\", \"return\",\r\n]);\r\n\r\n","/**\r\n * getStructuredPathInfo.ts\r\n *\r\n * Stateプロパティのパス文字列から、詳細な構造化パス情報（IStructuredPathInfo）を生成・キャッシュするユーティリティです。\r\n *\r\n * 主な役割:\r\n * - パス文字列を分割し、各セグメントやワイルドカード（*）の位置・親子関係などを解析\r\n * - cumulativePaths/wildcardPaths/parentPathなど、パス階層やワイルドカード階層の情報を構造化\r\n * - 解析結果をIStructuredPathInfoとしてキャッシュし、再利用性とパフォーマンスを両立\r\n * - reservedWords（予約語）チェックで安全性を担保\r\n *\r\n * 設計ポイント:\r\n * - パスごとにキャッシュし、同じパスへの複数回アクセスでも高速に取得可能\r\n * - ワイルドカードや親子関係、階層構造を厳密に解析し、バインディングや多重ループに最適化\r\n * - childrenプロパティでパス階層のツリー構造も構築\r\n * - 予約語や危険なパスはraiseErrorで例外を発生\r\n */\r\nimport { RESERVED_WORD_SET } from '../constants.js';\r\nimport { raiseError } from '../utils.js';\r\nimport { IStructuredPathInfo } from './types';\r\n\r\n/**\r\n * プロパティ名に\"constructor\"や\"toString\"などの予約語やオブジェクトのプロパティ名を\r\n * 上書きするような名前も指定できるように、Mapを検討したが、そもそもそのような名前を\r\n * 指定することはないと考え、Mapを使わないことにした。\r\n */\r\nconst _cache: { [key:string]: IStructuredPathInfo } = {};\r\n\r\n/**\r\n * パターン情報を取得します\r\n * @param pattern パターン\r\n * @returns {IPatternInfo} パターン情報\r\n */\r\nclass StructuredPathInfo implements IStructuredPathInfo {\r\n  static id : number = 0;\r\n  id = ++StructuredPathInfo.id;\r\n  sid = this.id.toString();\r\n  pattern;\r\n  pathSegments;\r\n  lastSegment;\r\n  cumulativePaths;\r\n  cumulativePathSet;\r\n  cumulativeInfos;\r\n  cumulativeInfoSet;\r\n  wildcardPaths;\r\n  wildcardPathSet;\r\n  wildcardInfos;\r\n  indexByWildcardPath;\r\n  wildcardInfoSet;\r\n  wildcardParentPaths;\r\n  wildcardParentPathSet;\r\n  wildcardParentInfos;\r\n  wildcardParentInfoSet;\r\n  lastWildcardPath;\r\n  lastWildcardInfo;\r\n  parentPath;\r\n  parentInfo;\r\n  wildcardCount;\r\n  children = {};\r\n\r\n  constructor(pattern: string) {\r\n    const getPattern = (_pattern: string): IStructuredPathInfo => {\r\n      return (pattern === _pattern) ? this : getStructuredPathInfo(_pattern);\r\n    };\r\n    const pathSegments = pattern.split(\".\");\r\n    const cumulativePaths = [];\r\n    const cumulativeInfos: IStructuredPathInfo[] = [];\r\n    const wildcardPaths = [];\r\n    const indexByWildcardPath: Record<string, number> = {};\r\n    const wildcardInfos = [];\r\n    const wildcardParentPaths = [];\r\n    const wildcardParentInfos = [];\r\n    let currentPatternPath = \"\", prevPatternPath = \"\";\r\n    let wildcardCount = 0;\r\n    for(let i = 0; i < pathSegments.length; i++) {\r\n      currentPatternPath += pathSegments[i];\r\n      if (pathSegments[i] === \"*\") {\r\n        wildcardPaths.push(currentPatternPath);\r\n        indexByWildcardPath[currentPatternPath] = wildcardCount;\r\n        wildcardInfos.push(getPattern(currentPatternPath));\r\n        wildcardParentPaths.push(prevPatternPath);\r\n        wildcardParentInfos.push(getPattern(prevPatternPath));\r\n        wildcardCount++;\r\n      }\r\n      cumulativePaths.push(currentPatternPath);\r\n      cumulativeInfos.push(getPattern(currentPatternPath));\r\n      prevPatternPath = currentPatternPath;\r\n      currentPatternPath += \".\";\r\n    }\r\n    const lastWildcardPath = wildcardPaths.length > 0 ? wildcardPaths[wildcardPaths.length - 1] : null;\r\n    const parentPath = cumulativePaths.length > 1 ? cumulativePaths[cumulativePaths.length - 2] : null;\r\n    this.pattern = pattern;\r\n    this.pathSegments = pathSegments;\r\n    this.lastSegment = pathSegments[pathSegments.length - 1];\r\n    this.cumulativePaths = cumulativePaths;\r\n    this.cumulativePathSet = new Set(cumulativePaths);\r\n    this.cumulativeInfos = cumulativeInfos;\r\n    this.cumulativeInfoSet = new Set(cumulativeInfos);\r\n    this.wildcardPaths = wildcardPaths;\r\n    this.wildcardPathSet = new Set(wildcardPaths);\r\n    this.indexByWildcardPath = indexByWildcardPath;\r\n    this.wildcardInfos = wildcardInfos;\r\n    this.wildcardInfoSet = new Set(wildcardInfos);\r\n    this.wildcardParentPaths = wildcardParentPaths;\r\n    this.wildcardParentPathSet = new Set(wildcardParentPaths);\r\n    this.wildcardParentInfos = wildcardParentInfos;\r\n    this.wildcardParentInfoSet = new Set(wildcardParentInfos);\r\n    this.lastWildcardPath = lastWildcardPath;\r\n    this.lastWildcardInfo = lastWildcardPath ? getPattern(lastWildcardPath) : null;\r\n    this.parentPath = parentPath;\r\n    this.parentInfo = parentPath ? getPattern(parentPath) : null;\r\n    this.wildcardCount = wildcardCount;\r\n    if (this.parentInfo) {\r\n      this.parentInfo.children[this.lastSegment] = this;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport function getStructuredPathInfo(structuredPath: string): IStructuredPathInfo {\r\n  const info = _cache[structuredPath];\r\n  if (typeof info !== \"undefined\") {\r\n    return info;\r\n  }\r\n  if (RESERVED_WORD_SET.has(structuredPath)) {\r\n    raiseError(`getStructuredPathInfo: pattern is reserved word: ${structuredPath}`);\r\n  }\r\n  return (_cache[structuredPath] = new StructuredPathInfo(structuredPath));\r\n}\r\n","/**\r\n * getResolvedPathInfo.ts\r\n *\r\n * Stateプロパティ名（パス文字列）から、ワイルドカードやインデックス情報を含む\r\n * 詳細なパス情報（IResolvedPathInfo）を解析・生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - プロパティ名を分解し、ワイルドカードやインデックスの有無・種別を判定\r\n * - context/all/partial/none のワイルドカード種別を自動判定\r\n * - パスごとにキャッシュし、再利用性とパフォーマンスを両立\r\n * - getStructuredPathInfoで構造化パス情報も取得\r\n *\r\n * 設計ポイント:\r\n * - \"constructor\"や\"toString\"などの予約語も扱えるよう、Mapではなくオブジェクトでキャッシュ\r\n * - ワイルドカード（*）や数値インデックスを柔軟に判定し、wildcardIndexesに格納\r\n * - context型は未確定インデックス、all型は全て確定インデックス、partial型は混在を示す\r\n * - ResolvedPathInfoクラスでパス解析・情報保持を一元化\r\n */\r\nimport { IResolvedPathInfo, WildcardType } from './types';\r\nimport { getStructuredPathInfo } from './getStructuredPathInfo.js';\r\n\r\n/**\r\n * プロパティ名に\"constructor\"や\"toString\"などの予約語やオブジェクトのプロパティ名を\r\n * 上書きするような名前も指定できるように、Mapを検討したが、そもそもそのような名前を\r\n * 指定することはないと考え、Mapを使わないことにした。\r\n */\r\nconst _cache: Map<string, IResolvedPathInfo> = new Map();\r\n\r\nclass ResolvedPathInfo implements IResolvedPathInfo {\r\n  static id : number = 0;\r\n  id = ++ResolvedPathInfo.id;\r\n  name;\r\n  elements;\r\n  paths;\r\n  wildcardCount;\r\n  wildcardType;\r\n  wildcardIndexes;\r\n  info;\r\n  constructor(name: string) {\r\n    const elements = name.split(\".\");\r\n    const tmpPatternElements = elements.slice();\r\n    const paths = [];\r\n    let incompleteCount = 0;\r\n    let completeCount = 0;\r\n    let lastPath = \"\";\r\n    let wildcardCount = 0;\r\n    let wildcardType: WildcardType = \"none\";\r\n    let wildcardIndexes: (number | null)[] = [];\r\n    for(let i = 0; i < elements.length; i++) {\r\n      const element = elements[i];\r\n      if (element === \"*\") {\r\n        tmpPatternElements[i] = \"*\";\r\n        wildcardIndexes.push(null);\r\n        incompleteCount++;\r\n        wildcardCount++;\r\n      } else {\r\n        const number = Number(element);\r\n        if (!Number.isNaN(number)) {\r\n          tmpPatternElements[i] = \"*\";\r\n          wildcardIndexes.push(number);\r\n          completeCount++;\r\n          wildcardCount++;\r\n        }\r\n      }\r\n      lastPath += element;\r\n      paths.push(lastPath);\r\n      lastPath += (i < elements.length - 1 ? \".\" : \"\");\r\n    }\r\n    const pattern = tmpPatternElements.join(\".\");\r\n    const info = getStructuredPathInfo(pattern);\r\n    if (incompleteCount > 0 || completeCount > 0) {\r\n      if (incompleteCount === wildcardCount) {\r\n        wildcardType = \"context\";\r\n      } else if (completeCount === wildcardCount) {\r\n        wildcardType = \"all\";\r\n      } else {\r\n        wildcardType = \"partial\";\r\n      }\r\n    }\r\n    this.name = name;\r\n    this.elements = elements;\r\n    this.paths = paths;\r\n    this.wildcardCount = wildcardCount;\r\n    this.wildcardType = wildcardType;\r\n    this.wildcardIndexes = wildcardIndexes;\r\n    this.info = info;\r\n  }\r\n}\r\n\r\nexport function getResolvedPathInfo(name:string):IResolvedPathInfo {\r\n  let nameInfo: IResolvedPathInfo | undefined;\r\n  return _cache.get(name) ?? (_cache.set(name, nameInfo = new ResolvedPathInfo(name)), nameInfo);\r\n}","/**\r\n * getContextListIndex.ts\r\n *\r\n * StateClassの内部APIとして、現在のプロパティ参照スコープにおける\r\n * 指定したstructuredPath（ワイルドカード付きプロパティパス）に対応する\r\n * リストインデックス（IListIndex）を取得する関数です。\r\n *\r\n * 主な役割:\r\n * - handlerの最後にアクセスされたStatePropertyRefから、指定パスに対応するリストインデックスを取得\r\n * - ワイルドカード階層に対応し、多重ループやネストした配列バインディングにも利用可能\r\n *\r\n * 設計ポイント:\r\n * - 直近のプロパティ参照情報を取得\r\n * - info.wildcardPathsからstructuredPathのインデックスを特定\r\n * - listIndex.at(index)で該当階層のリストインデックスを取得\r\n * - パスが一致しない場合や参照が存在しない場合はnullを返す\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\nexport function getContextListIndex(\r\n  handler: IStateHandler,\r\n  structuredPath: string\r\n): IListIndex | null {\r\n  const ref = handler.refStack[handler.refIndex];\r\n  if (ref == null) {\r\n    return null;\r\n  }\r\n  if (ref.info == null) {\r\n    return null;\r\n  }\r\n  if (ref.listIndex == null) {\r\n    return null;\r\n  }\r\n  const index = ref.info.indexByWildcardPath[structuredPath];\r\n  if (typeof index !== \"undefined\") {\r\n    return ref.listIndex.at(index);\r\n  }\r\n  return null;\r\n}\r\n","/**\r\n * getListIndex.ts\r\n *\r\n * StateClassの内部APIとして、パス情報（IResolvedPathInfo）から\r\n * 対応するリストインデックス（IListIndex）を取得する関数です。\r\n *\r\n * 主な役割:\r\n * - パスのワイルドカード種別（context/all/partial/none）に応じてリストインデックスを解決\r\n * - context型は現在のループコンテキストからリストインデックスを取得\r\n * - all型は各階層のリストインデックス集合からインデックスを辿って取得\r\n * - partial型やnone型は未実装またはnullを返す\r\n *\r\n * 設計ポイント:\r\n * - ワイルドカードや多重ループ、ネストした配列バインディングに柔軟に対応\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n * - エラー時はraiseErrorで詳細な例外を投げる\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IResolvedPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IStateHandler, IReadonlyStateProxy, IStateProxy } from \"../types\";\r\nimport { getContextListIndex } from \"./getContextListIndex\";\r\n\r\nexport function getListIndex(\r\n  resolvedPath: IResolvedPathInfo, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): IListIndex | null {\r\n  switch (resolvedPath.wildcardType) {\r\n    case \"none\":\r\n      return null;\r\n    case \"context\":\r\n      const lastWildcardPath = resolvedPath.info.lastWildcardPath ?? \r\n        raiseError(`lastWildcardPath is null`);\r\n      return getContextListIndex(handler, lastWildcardPath) ?? \r\n        raiseError(`ListIndex not found: ${resolvedPath.info.pattern}`);\r\n    case \"all\":\r\n      let parentListIndex: IListIndex | null = null;\r\n      for(let i = 0; i < resolvedPath.info.wildcardCount; i++) {\r\n        const wildcardParentPattern = resolvedPath.info.wildcardParentInfos[i] ?? \r\n          raiseError(`wildcardParentPattern is null`);\r\n        const listIndexes: IListIndex[] = handler.engine.getListIndexes(wildcardParentPattern, parentListIndex) ?? \r\n          raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n        const wildcardIndex = resolvedPath.wildcardIndexes[i] ?? \r\n          raiseError(`wildcardIndex is null`);\r\n        parentListIndex = listIndexes[wildcardIndex] ?? \r\n          raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n      }\r\n      return parentListIndex;\r\n    case \"partial\":\r\n      raiseError(`Partial wildcard type is not supported yet: ${resolvedPath.info.pattern}`);\r\n  }\r\n}\r\n","\r\nconst symbolName = \"state\";\r\n\r\nexport const GetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.GetByRef`);\r\nexport const SetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.SetByRef`);\r\nexport const SetCacheableSymbol        : unique symbol = Symbol.for(`${symbolName}.SetCacheable`);\r\nexport const ConnectedCallbackSymbol   : unique symbol = Symbol.for(`${symbolName}.ConnectedCallback`);\r\nexport const DisconnectedCallbackSymbol: unique symbol = Symbol.for(`${symbolName}.DisconnectedCallback`);\r\n","import { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IStatePropertyRef } from \"./types\";\r\n\r\nfunction createRefKey(\r\n  info: IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n) {\r\n  return (listIndex == null) ? info.sid : (info.sid + \"#\" + listIndex.sid);\r\n}\r\n\r\nclass StatePropertyRef implements IStatePropertyRef {\r\n  info: IStructuredPathInfo;\r\n  #listIndexRef: WeakRef<IListIndex> | null;\r\n  get listIndex(): IListIndex | null {\r\n    if (this.#listIndexRef === null) return null;\r\n    return this.#listIndexRef.deref() ?? raiseError(\"listIndex is null\");\r\n  }\r\n  key: string;\r\n  constructor(\r\n    info: IStructuredPathInfo,\r\n    listIndex: IListIndex | null,\r\n  ) {\r\n    this.info = info;\r\n    this.#listIndexRef = listIndex !== null ? new WeakRef(listIndex) : null;\r\n    this.key = createRefKey(info, listIndex);\r\n  }\r\n}\r\n\r\nconst refByInfoByListIndex = new WeakMap<IListIndex, Map<IStructuredPathInfo, IStatePropertyRef>>();\r\nconst refByInfoByNull = new Map<IStructuredPathInfo, IStatePropertyRef>();\r\n\r\nexport function getStatePropertyRef(\r\n  info: IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n): IStatePropertyRef {\r\n  let ref = null;\r\n  if (listIndex !== null) {\r\n    let refByInfo = refByInfoByListIndex.get(listIndex);\r\n    if (typeof refByInfo === \"undefined\") {\r\n      refByInfo = new Map<IStructuredPathInfo, IStatePropertyRef>();\r\n      refByInfoByListIndex.set(listIndex, refByInfo);\r\n    }\r\n    ref = refByInfo.get(info);\r\n    if (typeof ref === \"undefined\") {\r\n      ref = new StatePropertyRef(info, listIndex);\r\n      refByInfo.set(info, ref);\r\n    }\r\n    return ref;\r\n  } else {\r\n    ref = refByInfoByNull.get(info);\r\n    if (typeof ref === \"undefined\") {\r\n      ref = new StatePropertyRef(info, null);\r\n      refByInfoByNull.set(info, ref);\r\n    }\r\n    return ref;\r\n  }\r\n}\r\n","import { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\nexport function checkDependency(\r\n  handler: IStateHandler,\r\n  ref: IStatePropertyRef,\r\n): void {\r\n  // 動的依存関係の登録\r\n  if (handler.refIndex >= 0) {\r\n    const lastInfo = handler.refStack[handler.refIndex]?.info ?? null;\r\n    if (lastInfo !== null) {\r\n      if (handler.engine.pathManager.getters.has(lastInfo.pattern) &&\r\n        !handler.engine.pathManager.setters.has(lastInfo.pattern) &&\r\n        lastInfo.pattern !== ref.info.pattern) {\r\n        handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, ref.info.pattern);\r\n      }\r\n    }\r\n  }\r\n}","/**\r\n * setStatePropertyRef.ts\r\n *\r\n * StateClassの内部APIとして、状態プロパティ参照（IStructuredPathInfo, IListIndex）のスコープを\r\n * 一時的に設定し、指定したコールバックをそのスコープ内で実行するための関数です。\r\n *\r\n * 主な役割:\r\n * - handler.structuredPathInfoStackとhandler.listIndexStackにinfoとlistIndexをpushしてスコープを設定\r\n * - 指定したcallbackをそのスコープ内で実行\r\n * - finallyで必ずスタックからpopし、スコープ外への影響を防止\r\n *\r\n * 設計ポイント:\r\n * - コールバック実行中のみスコープを切り替え、例外発生時も状態復元を保証\r\n * - ネストしたスコープにも対応可能\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\nexport function setStatePropertyRef(\r\n  handler: IStateHandler,\r\n  ref: IStatePropertyRef,\r\n  callback: () => void\r\n): void {\r\n  handler.refIndex++;\r\n  if (handler.refIndex >= handler.refStack.length) {\r\n    handler.refStack.push(null);\r\n  }\r\n  handler.refStack[handler.refIndex] = ref;\r\n  try {\r\n    return callback();\r\n  } finally {\r\n    handler.refStack[handler.refIndex] = null;\r\n    handler.refIndex--;\r\n  }\r\n}\r\n","/**\r\n * getByRef.ts\r\n *\r\n * StateClassの内部APIとして、構造化パス情報（IStructuredPathInfo）とリストインデックス（IListIndex）を指定して\r\n * 状態オブジェクト（target）から値を取得するための関数（getByRef）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定されたパス・インデックスに対応するState値を取得（多重ループやワイルドカードにも対応）\r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyで値をキャッシュ）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * - 存在しない場合は親infoやlistIndexを辿って再帰的に値を取得\r\n *\r\n * 設計ポイント:\r\n * - handler.engine.trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n * - キャッシュ有効時はrefKeyで値をキャッシュし、取得・再利用を最適化\r\n * - ワイルドカードや多重ループにも柔軟に対応し、再帰的な値取得を実現\r\n * - finallyでキャッシュへの格納を保証\r\n */\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IWritableStateHandler, IWritableStateProxy } from \"../types\";\r\nimport { checkDependency } from \"./checkDependency\";\r\nimport { setStatePropertyRef } from \"./setStatePropertyRef\";\r\n\r\n/**\r\n * 構造化パス情報(info, listIndex)をもとに、状態オブジェクト(target)から値を取得する。\r\n * \r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyでキャッシュ）\r\n * - ネスト・ワイルドカード対応（親infoやlistIndexを辿って再帰的に値を取得）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * \r\n * @param target    状態オブジェクト\r\n * @param info      構造化パス情報\r\n * @param listIndex リストインデックス（多重ループ対応）\r\n * @param receiver  プロキシ\r\n * @param handler   状態ハンドラ\r\n * @returns         対象プロパティの値\r\n */\r\nexport function getByRefWritable(\r\n  target   : Object, \r\n  ref      : IStatePropertyRef,\r\n  receiver : IWritableStateProxy,\r\n  handler  : IWritableStateHandler\r\n): any {\r\n  checkDependency(handler, ref);\r\n\r\n  // 親子関係のあるgetterが存在する場合は、外部依存から取得\r\n  // ToDo: stateにgetterが存在する（パスの先頭が一致する）場合はgetter経由で取得\r\n  if (handler.engine.stateOutput.startsWith(ref.info) && handler.engine.pathManager.getters.intersection(ref.info.cumulativePathSet).size === 0) {\r\n    return handler.engine.stateOutput.get(ref.info, ref.listIndex);\r\n  }\r\n\r\n  // パターンがtargetに存在する場合はgetter経由で取得\r\n  if (ref.info.pattern in target) {\r\n    return setStatePropertyRef(handler, ref, () => {\r\n      return Reflect.get(target, ref.info.pattern, receiver);\r\n    });\r\n  } else {\r\n    // 存在しない場合は親infoを辿って再帰的に取得\r\n    const parentInfo = ref.info.parentInfo ?? raiseError(`propRef.stateProp.parentInfo is undefined`);\r\n    const parentListIndex = parentInfo.wildcardCount < ref.info.wildcardCount ? (ref.listIndex?.parentListIndex ?? null) : ref.listIndex;\r\n    const parentRef = getStatePropertyRef(parentInfo, parentListIndex);\r\n    const parentValue = getByRefWritable(target, parentRef, receiver, handler);\r\n    const lastSegment = ref.info.lastSegment;\r\n    if (lastSegment === \"*\") {\r\n      // ワイルドカードの場合はlistIndexのindexでアクセス\r\n      const index = ref.listIndex?.index ?? raiseError(`propRef.listIndex?.index is undefined`);\r\n      return Reflect.get(parentValue, index);\r\n    } else {\r\n      // 通常のプロパティアクセス\r\n      return Reflect.get(parentValue, lastSegment);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * setByRef.ts\r\n *\r\n * StateClassの内部APIとして、構造化パス情報（IStructuredPathInfo）とリストインデックス（IListIndex）を指定して\r\n * 状態オブジェクト（target）に値を設定するための関数（setByRef）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定されたパス・インデックスに対応するState値を設定（多重ループやワイルドカードにも対応）\r\n * - getter/setter経由で値設定時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * - 存在しない場合は親infoやlistIndexを辿って再帰的に値を設定\r\n * - 設定後はengine.updater.addUpdatedStatePropertyRefValueで更新情報を登録\r\n *\r\n * 設計ポイント:\r\n * - ワイルドカードや多重ループにも柔軟に対応し、再帰的な値設定を実現\r\n * - finallyで必ず更新情報を登録し、再描画や依存解決に利用\r\n * - getter/setter経由のスコープ切り替えも考慮した設計\r\n */\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\nimport { getByRefWritable } from \"./getByRefWritable\";\r\nimport { setStatePropertyRef } from \"./setStatePropertyRef\";\r\n\r\nexport function setByRef(\r\n    target   : Object, \r\n    ref      : IStatePropertyRef,\r\n    value    : any, \r\n    receiver : IWritableStateProxy,\r\n    handler  : IWritableStateHandler\r\n): any {\r\n  try {\r\n    // 親子関係のあるgetterが存在する場合は、外部依存を通じて値を設定\r\n    // ToDo: stateにgetterが存在する（パスの先頭が一致する）場合はgetter経由で取得\r\n    if (handler.engine.stateOutput.startsWith(ref.info) && handler.engine.pathManager.setters.intersection(ref.info.cumulativePathSet).size === 0) {\r\n      return handler.engine.stateOutput.set(ref.info, ref.listIndex, value);\r\n    }\r\n    if (ref.info.pattern in target) {\r\n      return setStatePropertyRef(handler, ref, () => {\r\n        return Reflect.set(target, ref.info.pattern, value, receiver);\r\n      });\r\n    } else {\r\n      const parentInfo = ref.info.parentInfo ?? raiseError(`propRef.stateProp.parentInfo is undefined`);\r\n      const parentListIndex = parentInfo.wildcardCount < ref.info.wildcardCount ? (ref.listIndex?.parentListIndex ?? null) : ref.listIndex;\r\n      const parentRef = getStatePropertyRef(parentInfo, parentListIndex);\r\n      const parentValue = getByRefWritable(target, parentRef, receiver, handler);\r\n      const lastSegment = ref.info.lastSegment;\r\n      if (lastSegment === \"*\") {\r\n        const index = ref.listIndex?.index ?? raiseError(`propRef.listIndex?.index is undefined`);\r\n        return Reflect.set(parentValue, index, value);\r\n      } else {\r\n        return Reflect.set(parentValue, lastSegment, value);\r\n      }\r\n    }\r\n  } finally {\r\n    handler.updater.enqueueRef(ref);\r\n  }\r\n}\r\n","/**\r\n * resolve.ts\r\n *\r\n * StateClassのAPIとして、パス（path）とインデックス（indexes）を指定して\r\n * Stateの値を取得・設定するための関数（resolve）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列パス（path）とインデックス配列（indexes）から、該当するState値の取得・設定を行う\r\n * - ワイルドカードや多重ループを含むパスにも対応\r\n * - value未指定時は取得（getByRef）、指定時は設定（setByRef）を実行\r\n *\r\n * 設計ポイント:\r\n * - getStructuredPathInfoでパスを解析し、ワイルドカード階層ごとにリストインデックスを解決\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n * - getByRef/setByRefで値の取得・設定を一元的に処理\r\n * - 柔軟なバインディングやAPI経由での利用が可能\r\n */\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { getByRefWritable } from \"../methods/getByRefWritable\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\n\r\nexport function resolveWritable(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler: IWritableStateHandler\r\n): Function {\r\n  return (path: string, indexes: number[], value?: any): any => {\r\n    const info = getStructuredPathInfo(path);\r\n    const lastInfo = handler.refStack[handler.refIndex]?.info ?? null;\r\n    if (lastInfo !== null && lastInfo.pattern !== info.pattern) {\r\n      // gettersに含まれる場合は依存関係を登録\r\n      if (handler.engine.pathManager.getters.has(lastInfo.pattern) &&\r\n        !handler.engine.pathManager.setters.has(lastInfo.pattern)) {\r\n        handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, info.pattern);\r\n      }\r\n    }\r\n\r\n    let listIndex: IListIndex | null = null;\r\n    for(let i = 0; i < info.wildcardParentInfos.length; i++) {\r\n      const wildcardParentPattern = info.wildcardParentInfos[i] ?? raiseError(`wildcardParentPath is null`);\r\n      const listIndexes: IListIndex[] = handler.engine.getListIndexes(wildcardParentPattern, listIndex) ?? [];\r\n      const index = indexes[i] ?? raiseError(`index is null`);\r\n      listIndex = listIndexes[index] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n    }\r\n    const ref = getStatePropertyRef(info, listIndex);\r\n    if (typeof value === \"undefined\") {\r\n      return getByRefWritable(target, ref, receiver, handler);\r\n    } else {\r\n      return setByRef(target, ref, value, receiver, handler);\r\n    }\r\n  };\r\n} ","import { raiseError } from \"../../utils\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\nexport function trackDependency(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n):Function {\r\n  return (path: string): void => {\r\n    const lastInfo = handler.refStack[handler.refIndex]?.info ?? raiseError(\"Internal error: refStack is null.\");\r\n    if (handler.engine.pathManager.getters.has(lastInfo.pattern) &&\r\n      lastInfo.pattern !== path) {\r\n      handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, path);\r\n    }\r\n  };\r\n}\r\n","import { MAX_WILDCARD_DEPTH } from \"../../constants\";\r\n\r\n/**\r\n * stackIndexByIndexName\r\n * インデックス名からスタックインデックスへのマッピング\r\n * $1 => 0\r\n * $2 => 1\r\n * :\r\n * ${i + 1} => i\r\n * i < MAX_WILDCARD_DEPTH\r\n */\r\nexport const indexByIndexName: { [key: PropertyKey]: number } = {};\r\nfor (let i = 0; i < MAX_WILDCARD_DEPTH; i++) {\r\n  indexByIndexName[`$${i+1}`] = i;\r\n}\r\n","/**\r\n * get.ts\r\n *\r\n * StateClassのProxyトラップとして、プロパティアクセス時の値取得処理を担う関数（get）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列プロパティの場合、特殊プロパティ（$1〜$9, $resolve, $getAll, $navigate）に応じた値やAPIを返却\r\n * - 通常のプロパティはgetResolvedPathInfoでパス情報を解決し、getListIndexでリストインデックスを取得\r\n * - getByRefで構造化パス・リストインデックスに対応した値を取得\r\n * - シンボルプロパティの場合はhandler.callableApi経由でAPIを呼び出し\r\n * - それ以外はReflect.getで通常のプロパティアクセスを実行\r\n *\r\n * 設計ポイント:\r\n * - $1〜$9は直近のStatePropertyRefのリストインデックス値を返す特殊プロパティ\r\n * - $resolve, $getAll, $navigateはAPI関数やルーターインスタンスを返す\r\n * - 通常のプロパティアクセスもバインディングや多重ループに対応\r\n * - シンボルAPIやReflect.getで拡張性・互換性も確保\r\n */\r\nimport { getRouter } from \"../../Router/Router.js\";\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { IWritableStateHandler, IWritableStateProxy } from \"../types.js\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, SetByRefSymbol } from \"../symbols.js\";\r\nimport { getByRefWritable } from \"../methods/getByRefWritable.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { resolveWritable } from \"../apis/resolveWritable.js\";\r\nimport { getAllWritable } from \"../apis/getAllWritable.js\";\r\nimport { connectedCallback } from \"../apis/connectedCallback.js\";\r\nimport { disconnectedCallback } from \"../apis/disconnectedCallback.js\";\r\nimport { trackDependency } from \"../apis/trackDependency.js\";\r\nimport { indexByIndexName } from \"./indexByIndexName.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\n\r\nexport function getWritable(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler : IWritableStateHandler\r\n): any {\r\n  const index = indexByIndexName[prop];\r\n  if (typeof index !== \"undefined\") {\r\n    const listIndex = handler.refStack[handler.refIndex]?.listIndex;\r\n    return listIndex?.indexes[index] ?? raiseError(`ListIndex not found: ${prop.toString()}`);\r\n  }\r\n  if (typeof prop === \"string\") {\r\n    if (prop[0] === \"$\") {\r\n      switch (prop) {\r\n        case \"$resolve\":\r\n          return resolveWritable(target, prop, receiver, handler);\r\n        case \"$getAll\":\r\n          return getAllWritable(target, prop, receiver, handler);\r\n        case \"$trackDependency\":\r\n          return trackDependency(target, prop, receiver, handler);\r\n        case \"$navigate\":\r\n          return (to:string) => getRouter()?.navigate(to);\r\n        case \"$component\":\r\n          return handler.engine.owner;\r\n      }\r\n    }\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    const ref = getStatePropertyRef(resolvedInfo.info, listIndex);\r\n    return getByRefWritable(\r\n      target, \r\n      ref,\r\n      receiver,\r\n      handler\r\n    );\r\n\r\n  } else if (typeof prop === \"symbol\") {\r\n    switch (prop) {\r\n      case GetByRefSymbol: \r\n        return (ref: IStatePropertyRef) => \r\n          getByRefWritable(target, ref, receiver, handler);\r\n      case SetByRefSymbol: \r\n        return (ref: IStatePropertyRef, value: any) => \r\n          setByRef(target, ref, value, receiver, handler);\r\n      case ConnectedCallbackSymbol:\r\n        return () => connectedCallback(target, prop, receiver, handler);\r\n      case DisconnectedCallbackSymbol: \r\n        return () => disconnectedCallback(target, prop, receiver, handler);\r\n      default:\r\n        return Reflect.get(\r\n          target, \r\n          prop, \r\n          receiver\r\n        );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * getAll.ts\r\n *\r\n * StateClassのAPIとして、ワイルドカードを含むStateプロパティパスに対応した\r\n * 全要素取得関数（getAll）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定パス（path）に一致する全てのState要素を配列で取得\r\n * - 多重ループやワイルドカード（*）を含むパスにも対応\r\n * - indexes未指定時は現在のループコンテキストから自動でインデックスを解決\r\n *\r\n * 設計ポイント:\r\n * - getStructuredPathInfoでパス情報を解析し、依存関係も自動で登録\r\n * - walkWildcardPatternでワイルドカード階層を再帰的に探索し、全インデックス組み合わせを列挙\r\n * - resolveで各インデックス組み合わせに対応する値を取得し、配列で返却\r\n * - getContextListIndexで現在のループインデックスを取得\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n */\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IWritableStateHandler, IWritableStateProxy } from \"../types\";\r\nimport { resolveWritable } from \"./resolveWritable.js\";\r\nimport { getContextListIndex } from \"../methods/getContextListIndex\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\n\r\nexport function getAllWritable(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler: IWritableStateHandler\r\n):Function {\r\n    const resolve = resolveWritable(target, prop, receiver, handler);\r\n    return (path: string, indexes?: number[]): any[] => {\r\n      const info = getStructuredPathInfo(path);\r\n      const lastInfo = handler.refStack[handler.refIndex]?.info ?? null;\r\n      if (lastInfo !== null && lastInfo.pattern !== info.pattern) {\r\n        // gettersに含まれる場合は依存関係を登録\r\n        if (handler.engine.pathManager.getters.has(lastInfo.pattern) &&\r\n          !handler.engine.pathManager.setters.has(lastInfo.pattern)) {\r\n          handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, info.pattern);\r\n        }\r\n      }\r\n  \r\n      if (typeof indexes === \"undefined\") {\r\n        for(let i = 0; i < info.wildcardInfos.length; i++) {\r\n          const wildcardPattern = info.wildcardInfos[i] ?? raiseError(`wildcardPattern is null`);\r\n          const listIndex = getContextListIndex(handler, wildcardPattern.pattern);\r\n          if (listIndex) {\r\n            indexes = listIndex.indexes;\r\n            break;\r\n          }\r\n        }\r\n        if (typeof indexes === \"undefined\") {\r\n          indexes = [];\r\n        }\r\n      }\r\n      const walkWildcardPattern = (\r\n        wildcardParentInfos: IStructuredPathInfo[],\r\n        wildardIndexPos: number,\r\n        listIndex: IListIndex | null,\r\n        indexes: number[],\r\n        indexPos: number,\r\n        parentIndexes: number[],\r\n        results: number[][]\r\n      ) => {\r\n        const wildcardParentPattern = wildcardParentInfos[wildardIndexPos] ?? null;\r\n        if (wildcardParentPattern === null) {\r\n          results.push(parentIndexes);\r\n          return;\r\n        }\r\n        const listIndexes = handler.engine.getListIndexes(wildcardParentPattern, listIndex) ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n        const index = indexes[indexPos] ?? null;\r\n        if (index === null) {\r\n          for(let i = 0; i < listIndexes.length; i++) {\r\n            const listIndex = listIndexes[i];\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results);\r\n          }\r\n        } else {\r\n          const listIndex = listIndexes[index] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n          if ((wildardIndexPos + 1) < wildcardParentInfos.length) {\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results\r\n            );\r\n          }\r\n        }\r\n      }\r\n      const resultIndexes: number[][] = [];\r\n      walkWildcardPattern(\r\n        info.wildcardParentInfos, \r\n        0, \r\n        null, \r\n        indexes, \r\n        0, \r\n        [], \r\n        resultIndexes\r\n      );\r\n      const resultValues: any[] = [];\r\n      for(let i = 0; i < resultIndexes.length; i++) {\r\n        resultValues.push(resolve(\r\n          info.pattern,\r\n          resultIndexes[i]\r\n        ));\r\n      }\r\n      return resultValues;\r\n    }\r\n  }","/**\r\n * connectedCallback.ts\r\n *\r\n * StateClassのライフサイクルフック「$connectedCallback」を呼び出すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - オブジェクト（target）に$connectedCallbackメソッドが定義されていれば呼び出す\r\n * - コールバックはtargetのthisコンテキストで呼び出し、IReadonlyStateProxy（receiver）を引数として渡す\r\n * - 非同期関数として実行可能（await対応）\r\n *\r\n * 設計ポイント:\r\n * - Reflect.getで$connectedCallbackプロパティを安全に取得\r\n * - 存在しない場合は何もしない\r\n * - ライフサイクル管理やカスタム初期化処理に利用\r\n */\r\nimport { IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\n\r\nconst CONNECTED_CALLBACK = \"$connectedCallback\";\r\n\r\nexport async function connectedCallback(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler: IWritableStateHandler\r\n):Promise<void> {\r\n  const callback = Reflect.get(target, CONNECTED_CALLBACK);\r\n  if (typeof callback === \"function\") {\r\n    await callback.call(receiver);\r\n  }\r\n}","/**\r\n * disconnectedCallback.ts\r\n *\r\n * StateClassのライフサイクルフック「$disconnectedCallback」を呼び出すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - オブジェクト（target）に$disconnectedCallbackメソッドが定義されていれば呼び出す\r\n * - コールバックはtargetのthisコンテキストで呼び出し、IReadonlyStateProxy（receiver）を引数として渡す\r\n * - 非同期関数として実行可能（await対応）\r\n *\r\n * 設計ポイント:\r\n * - Reflect.getで$disconnectedCallbackプロパティを安全に取得\r\n * - 存在しない場合は何もしない\r\n * - ライフサイクル管理やクリーンアップ処理に利用\r\n */\r\nimport { IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\n\r\nconst DISCONNECTED_CALLBACK = \"$disconnectedCallback\";\r\n\r\nexport async function disconnectedCallback(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler: IWritableStateHandler\r\n):Promise<void> {\r\n  const callback = Reflect.get(target, DISCONNECTED_CALLBACK);\r\n  if (typeof callback === \"function\") {\r\n    await callback.call(receiver);\r\n  }\r\n}","/**\r\n * createWritableStateProxy.ts\r\n *\r\n * StateClassの「書き込み可能」プロキシを生成するための実装ファイルです。\r\n *\r\n * 主な役割:\r\n * - Stateオブジェクトに対して、書き込み可能なProxyを作成\r\n * - StateHandlerクラスで各種APIやトラップ（get/set）を実装\r\n * - getトラップでバインディングやAPI呼び出し、依存解決などに対応\r\n * - setトラップで値の書き込みや副作用（依存解決・再描画）を一元管理\r\n *\r\n * 設計ポイント:\r\n * - StateHandlerはIWritableStateHandlerを実装し、状態管理やAPI呼び出しの基盤となる\r\n * - callableApiに各種APIシンボルと関数をマッピングし、柔軟なAPI拡張が可能\r\n * - createWritableStateProxyで一貫した生成・利用が可能\r\n * - 依存解決やキャッシュ、ループ・プロパティ参照スコープ管理など多機能な設計\r\n */\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IState, IWritableStateHandler, IWritableStateProxy } from \"./types\";\r\nimport { getWritable as trapGet } from \"./traps/getWritable.js\";\r\nimport { set as trapSet } from \"./traps/set.js\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { setLoopContext } from \"./methods/setLoopContext\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IUpdater } from \"../Updater/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\n\r\nconst STACK_DEPTH = 32;\r\n\r\nclass StateHandler implements IWritableStateHandler {\r\n  engine   : IComponentEngine;\r\n  lastTrackingStack: IStructuredPathInfo | null = null;\r\n  trackingStack: (IStructuredPathInfo | null)[] = Array(STACK_DEPTH).fill(null);\r\n  trackingIndex: number = -1;\r\n  refStack: (IStatePropertyRef | null)[] = Array(STACK_DEPTH).fill(null);\r\n  refIndex: number = -1;\r\n  loopContext: ILoopContext | null = null;\r\n  updater: IUpdater;\r\n  \r\n  constructor(engine: IComponentEngine, updater: IUpdater) {\r\n    this.engine = engine;\r\n    this.updater = updater;\r\n  }\r\n\r\n  get(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    receiver: IWritableStateProxy\r\n  ): any {\r\n    return trapGet(target, prop, receiver, this);\r\n  }\r\n\r\n  set(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    value   : any, \r\n    receiver: IWritableStateProxy\r\n  ): boolean {\r\n    return trapSet(target, prop, value, receiver, this);\r\n  }\r\n}\r\n\r\nexport async function useWritableStateProxy(\r\n  engine: IComponentEngine, \r\n  updater: IUpdater,\r\n  state: Object,\r\n  loopContext: ILoopContext | null,\r\n  callback: (stateProxy: IWritableStateProxy) => Promise<void>\r\n): Promise<void> {\r\n  const handler = new StateHandler(engine, updater);\r\n  const stateProxy = new Proxy<IState>(state, handler) as IWritableStateProxy;\r\n  return setLoopContext(handler, loopContext, async () => {\r\n    await callback(stateProxy);\r\n  });\r\n}\r\n\r\n","/**\r\n * set.ts\r\n *\r\n * StateClassのProxyトラップとして、プロパティ設定時の値セット処理を担う関数（set）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列プロパティの場合、getResolvedPathInfoでパス情報を解決し、getListIndexでリストインデックスを取得\r\n * - setByRefで構造化パス・リストインデックスに対応した値設定を実行\r\n * - それ以外（シンボル等）の場合はReflect.setで通常のプロパティ設定を実行\r\n *\r\n * 設計ポイント:\r\n * - バインディングや多重ループ、ワイルドカードを含むパスにも柔軟に対応\r\n * - setByRefを利用することで、依存解決や再描画などの副作用も一元管理\r\n * - Reflect.setで標準的なプロパティ設定の互換性も確保\r\n */\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { IStateHandler, IReadonlyStateProxy, IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\n\r\nexport function set(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  value   : any, \r\n  receiver: IWritableStateProxy,\r\n  handler : IWritableStateHandler\r\n): boolean {\r\n  if (typeof prop === \"string\") {\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    const ref = getStatePropertyRef(resolvedInfo.info, listIndex);\r\n    return setByRef(\r\n      target, \r\n      ref,\r\n      value, \r\n      receiver,\r\n      handler\r\n    );\r\n  } else {\r\n    return Reflect.set(\r\n      target, \r\n      prop, \r\n      value, \r\n      receiver\r\n    );\r\n  }\r\n}\r\n","/**\r\n * setLoopContext.ts\r\n *\r\n * StateClassの内部APIとして、ループコンテキスト（ILoopContext）を一時的に設定し、\r\n * 指定した非同期コールバックをそのスコープ内で実行するための関数です。\r\n *\r\n * 主な役割:\r\n * - handler.loopContextにループコンテキストを一時的に設定\r\n * - 既にループコンテキストが設定されている場合はエラーを投げる\r\n * - loopContextが存在する場合はasyncSetStatePropertyRefでスコープを設定しコールバックを実行\r\n * - loopContextがnullの場合はそのままコールバックを実行\r\n * - finallyで必ずloopContextをnullに戻し、スコープ外への影響を防止\r\n *\r\n * 設計ポイント:\r\n * - ループバインディングや多重ループ時のスコープ管理を安全に行う\r\n * - finallyで状態復元を保証し、例外発生時も安全\r\n * - 非同期処理にも対応\r\n */\r\nimport { ILoopContext } from \"../../LoopContext/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IWritableStateHandler } from \"../types\";\r\nimport { asyncSetStatePropertyRef } from \"./asyncSetStatePropertyRef\";\r\n\r\nexport async function setLoopContext(\r\n  handler: IWritableStateHandler,\r\n  loopContext: ILoopContext | null,\r\n  callback: () => Promise<void>\r\n): Promise<void> {\r\n  if (handler.loopContext) {\r\n    raiseError('already in loop context');\r\n  }\r\n  handler.loopContext = loopContext;\r\n  try {\r\n    if (loopContext) {\r\n      await asyncSetStatePropertyRef(handler, loopContext.ref, callback);\r\n    } else {\r\n      await callback();\r\n    }\r\n  } finally {\r\n    handler.loopContext = null;\r\n  }\r\n}\r\n","/**\r\n * asyncSetStatePropertyRef.ts\r\n *\r\n * 状態プロパティ参照のスコープを一時的に設定し、非同期コールバックを実行するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - handlerのstructuredPathInfoStackとlistIndexStackに、infoとlistIndexをpushしてスコープを設定\r\n * - 指定した非同期コールバック（callback）をそのスコープ内で実行\r\n * - callback実行後は必ずpopしてスコープを元に戻す（finallyで保証）\r\n *\r\n * 設計ポイント:\r\n * - 非同期処理中も正しいスコープ情報（パス・リストインデックス）が維持される\r\n * - ネストした非同期処理にも対応可能\r\n * - スコープのpush/popは例外発生時も確実に実行される\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\n/**\r\n * 状態プロパティ参照のスコープを一時的に設定し、非同期コールバックを実行します。\r\n * \r\n * @param handler   スコープ管理用のハンドラ\r\n * @param info      現在の構造化パス情報\r\n * @param listIndex 現在のリストインデックス（ネスト対応用）\r\n * @param callback  スコープ内で実行する非同期処理\r\n * \r\n * スタックに info と listIndex をpushし、callback実行後に必ずpopします。\r\n * これにより、非同期処理中も正しいスコープ情報が維持されます。\r\n */\r\nexport async function asyncSetStatePropertyRef(\r\n  handler: IStateHandler,\r\n  ref: IStatePropertyRef,\r\n  callback: () => Promise<void>\r\n): Promise<void> {\r\n  handler.refIndex++;\r\n  if (handler.refIndex >= handler.refStack.length) {\r\n    handler.refStack.push(null);\r\n  }\r\n  handler.refStack[handler.refIndex] = ref;\r\n  try {\r\n    await callback();\r\n  } finally {\r\n    handler.refStack[handler.refIndex] = null;\r\n    handler.refIndex--;\r\n  }\r\n}\r\n","import { IListIndex } from \"./types\";\r\n\r\n\r\nlet version = 0;\r\nlet id = 0;\r\nclass ListIndex implements IListIndex {\r\n  #parentListIndex: IListIndex | null = null;\r\n  #pos: number = 0;\r\n  #index: number = 0;\r\n  #version: number;\r\n  #id = ++id;\r\n  #sid = this.#id.toString();\r\n  constructor(parentListIndex: IListIndex | null, index: number) {\r\n    this.#parentListIndex = parentListIndex;\r\n    this.#pos = parentListIndex ? parentListIndex.position + 1 : 0;\r\n    this.#index = index;\r\n    this.#version = version;\r\n  }\r\n\r\n  get parentListIndex() {\r\n    return this.#parentListIndex;\r\n  }\r\n\r\n  get id() {\r\n    return this.#id;\r\n  }\r\n\r\n  get sid() {\r\n    return this.#sid;\r\n  }\r\n\r\n  get position() {\r\n    return this.#pos;\r\n  }\r\n\r\n  get length() {\r\n    return this.#pos + 1;\r\n  }\r\n\r\n  get index() {\r\n    return this.#index;\r\n  }\r\n  set index(value: number) {\r\n    this.#index = value;\r\n    this.#version = ++version;\r\n    this.indexes[this.#pos] = value;\r\n  }\r\n\r\n  get version(): number {\r\n    return this.#version;\r\n  }\r\n\r\n  get dirty(): boolean {\r\n    if (this.#parentListIndex === null) {\r\n      return false;\r\n    } else {\r\n      return this.#parentListIndex.dirty || this.#parentListIndex.version > this.#version;\r\n    }\r\n  }\r\n\r\n  #indexes: number[] | undefined;\r\n  get indexes(): number[] {\r\n    if (this.#parentListIndex === null) {\r\n      if (typeof this.#indexes === \"undefined\") {\r\n        this.#indexes = [this.#index];\r\n      }\r\n    } else {\r\n      if (typeof this.#indexes === \"undefined\" || this.dirty) {\r\n        this.#indexes = [...this.#parentListIndex.indexes, this.#index];\r\n        this.#version = version;\r\n      }\r\n    }\r\n    return this.#indexes;\r\n  }\r\n\r\n  #listIndexes: WeakRef<IListIndex>[] | undefined;\r\n  get listIndexes(): WeakRef<IListIndex>[] {\r\n    if (this.#parentListIndex === null) {\r\n      if (typeof this.#listIndexes === \"undefined\") {\r\n        this.#listIndexes = [new WeakRef(this)];\r\n      }\r\n    } else {\r\n      if (typeof this.#listIndexes === \"undefined\") {\r\n        this.#listIndexes = [...this.#parentListIndex.listIndexes, new WeakRef(this)];\r\n      }\r\n    }\r\n    return this.#listIndexes;\r\n  }\r\n\r\n  get varName(): string {\r\n    return `${this.position + 1}`;\r\n  }\r\n\r\n  at(pos: number): IListIndex | null {\r\n    if (pos >= 0) {\r\n      return this.listIndexes[pos]?.deref() || null;\r\n    } else {\r\n      return this.listIndexes[this.listIndexes.length + pos]?.deref() || null;\r\n    }\r\n  }\r\n}\r\n\r\nexport function createListIndex(parentListIndex: IListIndex | null, index: number): IListIndex {\r\n  return new ListIndex(parentListIndex, index);\r\n}\r\n","import { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IPathNode } from \"./types\";\r\n\r\nclass NodePath implements IPathNode {\r\n  parentPath: string;\r\n  currentPath: string;\r\n  name: string;\r\n  childNodeByName: Map<string, IPathNode>;\r\n  level: number;\r\n\r\n  constructor(parentPath: string, name: string, level: number) {\r\n    this.parentPath = parentPath;\r\n    this.currentPath = parentPath ? parentPath + \".\" + name : name;\r\n    this.name = name;\r\n    this.level = level;\r\n    this.childNodeByName = new Map<string, IPathNode>();\r\n  }\r\n\r\n  find(segments: string[], segIndex: number = 0): IPathNode | null {\r\n    if (segIndex >= segments.length) {\r\n      return null;\r\n    }\r\n\r\n    const currentSegment = segments[segIndex];\r\n    const childNode = this.childNodeByName.get(currentSegment);\r\n\r\n    if (childNode) {\r\n      if (segIndex === segments.length - 1) {\r\n        return childNode;\r\n      }\r\n      return childNode.find(segments, segIndex + 1);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  appendChild(childName: string): IPathNode {\r\n    let childNode = this.childNodeByName.get(childName);\r\n    if (!childNode) {\r\n      const currentPath = this.parentPath ? this.parentPath + \".\" + this.name : this.name;\r\n      childNode = new NodePath(currentPath, childName, this.level + 1);\r\n      this.childNodeByName.set(childName, childNode);\r\n    }\r\n    return childNode;\r\n  }\r\n}\r\n\r\nexport function createRootNode(): IPathNode {\r\n  return new NodePath(\"\", \"\", 0);\r\n}\r\n\r\nconst cache = new Map<IPathNode, Map<string, IPathNode | null>>();\r\nexport function findPathNodeByPath(rootNode: IPathNode, path: string): IPathNode | null {\r\n  let nodeCache = cache.get(rootNode);\r\n  if (!nodeCache) {\r\n    nodeCache = new Map<string, IPathNode>();\r\n    cache.set(rootNode, nodeCache);\r\n  }\r\n  let cachedNode = nodeCache.get(path) ?? null;\r\n  if (cachedNode) {\r\n    return cachedNode;\r\n  }\r\n  const info = getStructuredPathInfo(path);\r\n  cachedNode = rootNode.find(info.pathSegments);\r\n  nodeCache.set(path, cachedNode);\r\n  return cachedNode;\r\n}\r\n\r\nexport function addPathNode(rootNode: IPathNode, path: string): IPathNode {\r\n  const info = getStructuredPathInfo(path);\r\n  if (info.parentPath === null) {\r\n    return rootNode.appendChild(path);\r\n  } else {\r\n    let parentNode = findPathNodeByPath(rootNode, info.parentPath);\r\n    if (parentNode === null) {\r\n      parentNode = addPathNode(rootNode, info.parentPath);\r\n    }\r\n    return parentNode.appendChild(info.lastSegment);\r\n  }\r\n}\r\n","/**\r\n * getByRef.ts\r\n *\r\n * StateClassの内部APIとして、構造化パス情報（IStructuredPathInfo）とリストインデックス（IListIndex）を指定して\r\n * 状態オブジェクト（target）から値を取得するための関数（getByRef）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定されたパス・インデックスに対応するState値を取得（多重ループやワイルドカードにも対応）\r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyで値をキャッシュ）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * - 存在しない場合は親infoやlistIndexを辿って再帰的に値を取得\r\n *\r\n * 設計ポイント:\r\n * - handler.engine.trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n * - キャッシュ有効時はrefKeyで値をキャッシュし、取得・再利用を最適化\r\n * - ワイルドカードや多重ループにも柔軟に対応し、再帰的な値取得を実現\r\n * - finallyでキャッシュへの格納を保証\r\n */\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IReadonlyStateProxy, IReadonlyStateHandler } from \"../types\";\r\nimport { checkDependency } from \"./checkDependency\";\r\nimport { setStatePropertyRef } from \"./setStatePropertyRef\";\r\n\r\n/**\r\n * 構造化パス情報(info, listIndex)をもとに、状態オブジェクト(target)から値を取得する。\r\n * \r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyでキャッシュ）\r\n * - ネスト・ワイルドカード対応（親infoやlistIndexを辿って再帰的に値を取得）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * \r\n * @param target    状態オブジェクト\r\n * @param info      構造化パス情報\r\n * @param listIndex リストインデックス（多重ループ対応）\r\n * @param receiver  プロキシ\r\n * @param handler   状態ハンドラ\r\n * @returns         対象プロパティの値\r\n */\r\nexport function getByRefReadonly(\r\n  target   : Object, \r\n  ref      : IStatePropertyRef,\r\n  receiver : IReadonlyStateProxy,\r\n  handler  : IReadonlyStateHandler\r\n): any {\r\n  checkDependency(handler, ref);\r\n\r\n  // キャッシュが有効な場合はrefKeyで値をキャッシュ\r\n  if (handler.cacheable) {\r\n    const value = handler.cache.get(ref.key);\r\n    if (typeof value !== \"undefined\") {\r\n      return value;\r\n    }\r\n    if (handler.cache.has(ref.key)) {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  let value;\r\n  try {\r\n    // 親子関係のあるgetterが存在する場合は、外部依存から取得\r\n    // ToDo: stateにgetterが存在する（パスの先頭が一致する）場合はgetter経由で取得\r\n    if (handler.engine.stateOutput.startsWith(ref.info) && handler.engine.pathManager.getters.intersection(ref.info.cumulativePathSet).size === 0) {\r\n      return value = handler.engine.stateOutput.get(ref.info, ref.listIndex);\r\n    }\r\n    // パターンがtargetに存在する場合はgetter経由で取得\r\n    if (ref.info.pattern in target) {\r\n      return (value = setStatePropertyRef(handler, ref, () => {\r\n        return Reflect.get(target, ref.info.pattern, receiver);\r\n      }));\r\n    } else {\r\n      // 存在しない場合は親infoを辿って再帰的に取得\r\n      const parentInfo = ref.info.parentInfo ?? raiseError(`propRef.stateProp.parentInfo is undefined`);\r\n      const parentListIndex = parentInfo.wildcardCount < ref.info.wildcardCount ? (ref.listIndex?.parentListIndex ?? null) : ref.listIndex;\r\n      const parentRef = getStatePropertyRef(parentInfo, parentListIndex);\r\n      const parentValue = getByRefReadonly(target, parentRef, receiver, handler);\r\n      const lastSegment = ref.info.lastSegment;\r\n      if (lastSegment === \"*\") {\r\n        // ワイルドカードの場合はlistIndexのindexでアクセス\r\n        const index = ref.listIndex?.index ?? raiseError(`propRef.listIndex?.index is undefined`);\r\n        return (value = Reflect.get(parentValue, index));\r\n      } else {\r\n        // 通常のプロパティアクセス\r\n        return (value = Reflect.get(parentValue, lastSegment));\r\n      }\r\n    }\r\n  } finally {\r\n    // キャッシュが有効な場合は取得値をキャッシュ\r\n    if (handler.cacheable) {\r\n      handler.cache.set(ref.key, value);\r\n    }\r\n    if (handler.renderer != null) {\r\n      if (handler.engine.pathManager.lists.has(ref.info.pattern)) {\r\n        handler.renderer.calcListDiff(ref, value as any[] | undefined | null, true);\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * resolve.ts\r\n *\r\n * StateClassのAPIとして、パス（path）とインデックス（indexes）を指定して\r\n * Stateの値を取得・設定するための関数（resolve）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列パス（path）とインデックス配列（indexes）から、該当するState値の取得・設定を行う\r\n * - ワイルドカードや多重ループを含むパスにも対応\r\n * - value未指定時は取得（getByRef）、指定時は設定（setByRef）を実行\r\n *\r\n * 設計ポイント:\r\n * - getStructuredPathInfoでパスを解析し、ワイルドカード階層ごとにリストインデックスを解決\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n * - getByRef/setByRefで値の取得・設定を一元的に処理\r\n * - 柔軟なバインディングやAPI経由での利用が可能\r\n */\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IReadonlyStateProxy, IReadonlyStateHandler } from \"../types\";\r\nimport { getByRefReadonly } from \"../methods/getByRefReadonly\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\n\r\nexport function resolveReadonly(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IReadonlyStateProxy,\r\n  handler: IReadonlyStateHandler\r\n): Function {\r\n  return (path: string, indexes: number[], value?: any): any => {\r\n    const info = getStructuredPathInfo(path);\r\n    const lastInfo = handler.refStack[handler.refIndex]?.info ?? null;\r\n    if (lastInfo !== null && lastInfo.pattern !== info.pattern) {\r\n      // gettersに含まれる場合は依存関係を登録\r\n      if (handler.engine.pathManager.getters.has(lastInfo.pattern) &&\r\n        !handler.engine.pathManager.setters.has(lastInfo.pattern)) {\r\n        handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, info.pattern);\r\n      }\r\n    }\r\n\r\n    let listIndex: IListIndex | null = null;\r\n    for(let i = 0; i < info.wildcardParentInfos.length; i++) {\r\n      const wildcardParentPattern = info.wildcardParentInfos[i] ?? raiseError(`wildcardParentPath is null`);\r\n      const listIndexes: IListIndex[] = handler.engine.getListIndexes(wildcardParentPattern, listIndex) ?? [];\r\n      const index = indexes[i] ?? raiseError(`index is null`);\r\n      listIndex = listIndexes[index] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n    }\r\n    const ref = getStatePropertyRef(info, listIndex);\r\n    if (typeof value === \"undefined\") {\r\n      return getByRefReadonly(target, ref, receiver, handler);\r\n    } else {\r\n      raiseError(`Cannot set value on a readonly proxy: ${path}`);\r\n    }\r\n  };\r\n} ","/**\r\n * get.ts\r\n *\r\n * StateClassのProxyトラップとして、プロパティアクセス時の値取得処理を担う関数（get）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列プロパティの場合、特殊プロパティ（$1〜$9, $resolve, $getAll, $navigate）に応じた値やAPIを返却\r\n * - 通常のプロパティはgetResolvedPathInfoでパス情報を解決し、getListIndexでリストインデックスを取得\r\n * - getByRefで構造化パス・リストインデックスに対応した値を取得\r\n * - シンボルプロパティの場合はhandler.callableApi経由でAPIを呼び出し\r\n * - それ以外はReflect.getで通常のプロパティアクセスを実行\r\n *\r\n * 設計ポイント:\r\n * - $1〜$9は直近のStatePropertyRefのリストインデックス値を返す特殊プロパティ\r\n * - $resolve, $getAll, $navigateはAPI関数やルーターインスタンスを返す\r\n * - 通常のプロパティアクセスもバインディングや多重ループに対応\r\n * - シンボルAPIやReflect.getで拡張性・互換性も確保\r\n */\r\nimport { getRouter } from \"../../Router/Router.js\";\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { IReadonlyStateHandler, IReadonlyStateProxy } from \"../types.js\";\r\nimport { resolveReadonly } from \"../apis/resolveReadonly.js\";\r\nimport { GetByRefSymbol, SetCacheableSymbol } from \"../symbols.js\";\r\nimport { getByRefReadonly } from \"../methods/getByRefReadonly.js\";\r\nimport { setCacheable } from \"../methods/setCacheable.js\";\r\nimport { getAllReadonly } from \"../apis/getAllReadonly.js\";\r\nimport { trackDependency } from \"../apis/trackDependency.js\";\r\nimport { indexByIndexName } from \"./indexByIndexName.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\n\r\n\r\nexport function getReadonly(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  receiver: IReadonlyStateProxy,\r\n  handler : IReadonlyStateHandler\r\n): any {\r\n  const index = indexByIndexName[prop];\r\n  if (typeof index !== \"undefined\") {\r\n    const listIndex = handler.refStack[handler.refIndex]?.listIndex;\r\n    return listIndex?.indexes[index] ?? raiseError(`ListIndex not found: ${prop.toString()}`);\r\n  }\r\n  if (typeof prop === \"string\") {\r\n    if (prop[0] === \"$\") {\r\n      switch (prop) {\r\n        case \"$resolve\":\r\n          return resolveReadonly(target, prop, receiver, handler);\r\n        case \"$getAll\":\r\n          return getAllReadonly(target, prop, receiver, handler);\r\n        case \"$trackDependency\":\r\n          return trackDependency(target, prop, receiver, handler);\r\n        case \"$navigate\":\r\n          return (to:string) => getRouter()?.navigate(to);\r\n        case \"$component\":\r\n          return handler.engine.owner;\r\n      }\r\n    }\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    const ref = getStatePropertyRef(resolvedInfo.info, listIndex);\r\n    return getByRefReadonly(\r\n      target, \r\n      ref,\r\n      receiver,\r\n      handler\r\n    );\r\n\r\n  } else if (typeof prop === \"symbol\") {\r\n    switch (prop) {\r\n      case GetByRefSymbol: \r\n        return (ref: IStatePropertyRef) => \r\n          getByRefReadonly(target, ref, receiver, handler);\r\n      case SetCacheableSymbol:\r\n        return (callback: () => void) => setCacheable(handler, callback)\r\n      default:\r\n        return Reflect.get(\r\n          target, \r\n          prop, \r\n          receiver\r\n        );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * getAll.ts\r\n *\r\n * StateClassのAPIとして、ワイルドカードを含むStateプロパティパスに対応した\r\n * 全要素取得関数（getAll）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定パス（path）に一致する全てのState要素を配列で取得\r\n * - 多重ループやワイルドカード（*）を含むパスにも対応\r\n * - indexes未指定時は現在のループコンテキストから自動でインデックスを解決\r\n *\r\n * 設計ポイント:\r\n * - getStructuredPathInfoでパス情報を解析し、依存関係も自動で登録\r\n * - walkWildcardPatternでワイルドカード階層を再帰的に探索し、全インデックス組み合わせを列挙\r\n * - resolveで各インデックス組み合わせに対応する値を取得し、配列で返却\r\n * - getContextListIndexで現在のループインデックスを取得\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n */\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IReadonlyStateProxy, IReadonlyStateHandler } from \"../types\";\r\nimport { resolveReadonly } from \"./resolveReadonly.js\";\r\nimport { getContextListIndex } from \"../methods/getContextListIndex\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { GetByRefSymbol } from \"../symbols.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\n\r\nexport function getAllReadonly(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IReadonlyStateProxy,\r\n  handler: IReadonlyStateHandler\r\n):Function {\r\n    const resolve = resolveReadonly(target, prop, receiver, handler);\r\n    return (path: string, indexes?: number[]): any[] => {\r\n      const info = getStructuredPathInfo(path);\r\n      const lastInfo = handler.refStack[handler.refIndex]?.info ?? null;\r\n      if (lastInfo !== null && lastInfo.pattern !== info.pattern) {\r\n        // gettersに含まれる場合は依存関係を登録\r\n        if (handler.engine.pathManager.getters.has(lastInfo.pattern) &&\r\n          !handler.engine.pathManager.setters.has(lastInfo.pattern)) {\r\n          handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, info.pattern);\r\n        }\r\n      }\r\n  \r\n      if (typeof indexes === \"undefined\") {\r\n        for(let i = 0; i < info.wildcardInfos.length; i++) {\r\n          const wildcardPattern = info.wildcardInfos[i] ?? raiseError(`wildcardPattern is null`);\r\n          const listIndex = getContextListIndex(handler, wildcardPattern.pattern);\r\n          if (listIndex) {\r\n            indexes = listIndex.indexes;\r\n            break;\r\n          }\r\n        }\r\n        if (typeof indexes === \"undefined\") {\r\n          indexes = [];\r\n        }\r\n      }\r\n      const walkWildcardPattern = (\r\n        wildcardParentInfos: IStructuredPathInfo[],\r\n        wildardIndexPos: number,\r\n        listIndex: IListIndex | null,\r\n        indexes: number[],\r\n        indexPos: number,\r\n        parentIndexes: number[],\r\n        results: number[][]\r\n      ) => {\r\n        const wildcardParentPattern = wildcardParentInfos[wildardIndexPos] ?? null;\r\n        if (wildcardParentPattern === null) {\r\n          results.push(parentIndexes);\r\n          return;\r\n        }\r\n        let listIndexes = handler.engine.getListIndexes(wildcardParentPattern, listIndex);\r\n        if (listIndexes === null) {\r\n          const ref = getStatePropertyRef(wildcardParentPattern, listIndex);\r\n          receiver[GetByRefSymbol](ref);\r\n          listIndexes = handler.engine.getListIndexes(wildcardParentPattern, listIndex);\r\n          if (listIndexes === null) {\r\n            raiseError(`ListIndex is not found: ${wildcardParentPattern.pattern}`);\r\n          }\r\n        }\r\n        const index = indexes[indexPos] ?? null;\r\n        if (index === null) {\r\n          for(let i = 0; i < listIndexes.length; i++) {\r\n            const listIndex = listIndexes[i];\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results);\r\n          }\r\n        } else {\r\n          const listIndex = listIndexes[index] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n          if ((wildardIndexPos + 1) < wildcardParentInfos.length) {\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results\r\n            );\r\n          }\r\n        }\r\n      }\r\n      const resultIndexes: number[][] = [];\r\n      walkWildcardPattern(\r\n        info.wildcardParentInfos, \r\n        0, \r\n        null, \r\n        indexes, \r\n        0, \r\n        [], \r\n        resultIndexes\r\n      );\r\n      const resultValues: any[] = [];\r\n      for(let i = 0; i < resultIndexes.length; i++) {\r\n        resultValues.push(resolve(\r\n          info.pattern,\r\n          resultIndexes[i]\r\n        ));\r\n      }\r\n      return resultValues;\r\n    }\r\n  }","/**\r\n * setCacheable.ts\r\n *\r\n * StateClassの内部APIとして、キャッシュ可能なスコープを一時的に有効化し、\r\n * 指定したコールバック処理をキャッシュ付きで実行するための関数です。\r\n *\r\n * 主な役割:\r\n * - handler.cacheableをtrueに設定し、キャッシュ用オブジェクトを初期化\r\n * - 指定したcallbackをキャッシュ有効状態で実行\r\n * - finallyで必ずcacheableをfalseに戻し、スコープ外ではキャッシュを無効化\r\n *\r\n * 設計ポイント:\r\n * - コールバック実行中のみキャッシュを有効化し、スコープ外への影響を防止\r\n * - finallyで状態復元を保証し、例外発生時も安全\r\n */\r\nimport { IReadonlyStateHandler } from \"../types\";\r\n\r\nexport function setCacheable(handler: IReadonlyStateHandler, callback: () => void): void {\r\n  handler.cacheable = true;\r\n  handler.cache = new Map<string, any>();\r\n  try {\r\n    callback();\r\n  } finally {\r\n    handler.cacheable = false;\r\n  }\r\n}\r\n","/**\r\n * createReadonlyStateProxy.ts\r\n *\r\n * StateClassの「読み取り専用」プロキシを生成するための実装ファイルです。\r\n *\r\n * 主な役割:\r\n * - Stateオブジェクトに対して、読み取り専用のProxyを作成\r\n * - StateHandlerクラスで各種APIやトラップ（get/set）を実装\r\n * - getトラップでバインディングやAPI呼び出し、依存解決などに対応\r\n * - setトラップではエラーを投げて書き込みを禁止\r\n *\r\n * 設計ポイント:\r\n * - StateHandlerはIReadonlyStateHandlerを実装し、状態管理やAPI呼び出しの基盤となる\r\n * - callableApiに各種APIシンボルと関数をマッピングし、柔軟なAPI拡張が可能\r\n * - createReadonlyStateProxyで一貫した生成・利用が可能\r\n * - 依存解決やキャッシュ、ループ・プロパティ参照スコープ管理など多機能な設計\r\n */\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IReadonlyStateHandler, IState, IReadonlyStateProxy } from \"./types\";\r\nimport { getReadonly as trapGet } from \"./traps/getReadonly.js\";\r\nimport { raiseError } from \"../utils\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IRenderer } from \"../Updater/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\n\r\nconst STACK_DEPTH = 32;\r\n\r\nclass StateHandler implements IReadonlyStateHandler {\r\n  engine   : IComponentEngine;\r\n  cacheable: boolean = false;\r\n  cache    : Map<string, any> = new Map();\r\n  lastTrackingStack: IStructuredPathInfo | null = null;\r\n  trackingStack: (IStructuredPathInfo | null)[] = Array(STACK_DEPTH).fill(null);\r\n  trackingIndex: number = -1;\r\n  refStack: (IStatePropertyRef | null)[] = Array(STACK_DEPTH).fill(null);\r\n  refIndex: number = -1;\r\n  loopContext: ILoopContext | null = null;\r\n  renderer : IRenderer | null = null;\r\n\r\n  constructor(engine: IComponentEngine, renderer: IRenderer | null) {\r\n    this.engine = engine;\r\n    this.renderer = renderer;\r\n  }\r\n\r\n  get(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    receiver: IReadonlyStateProxy\r\n  ): any {\r\n    return trapGet(target, prop, receiver, this);\r\n  }\r\n\r\n  set(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    value   : any, \r\n    receiver: IReadonlyStateProxy\r\n  ): boolean {\r\n    raiseError(`Cannot set property ${String(prop)} of readonly state.`);\r\n  }\r\n}\r\n\r\nexport function createReadonlyStateProxy(\r\n  engine: IComponentEngine, \r\n  state: Object,\r\n  renderer: IRenderer | null = null,\r\n): IReadonlyStateProxy {\r\n  return new Proxy<IState>(state, new StateHandler(engine, renderer)) as IReadonlyStateProxy;\r\n}\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { WILDCARD } from \"../constants\";\r\nimport { IBinding } from \"../DataBinding/types\";\r\nimport { calcListDiff } from \"../ListDiff/ListDiff\";\r\nimport { IListDiff } from \"../ListDiff/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { findPathNodeByPath } from \"../PathTree/PathNode\";\r\nimport { IPathNode } from \"../PathTree/types\";\r\nimport { createReadonlyStateProxy } from \"../StateClass/createReadonlyStateProxy\";\r\nimport { GetByRefSymbol, SetCacheableSymbol } from \"../StateClass/symbols\";\r\nimport { IReadonlyStateProxy } from \"../StateClass/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IRenderer, IUpdateInfo } from \"./types\";\r\n\r\nclass Renderer implements IRenderer {\r\n  #updatedBindings: Set<IBinding> = new Set();\r\n  #trackedRefs: Set<IStatePropertyRef> = new Set();\r\n  #engine: IComponentEngine;\r\n  #readonlyState: IReadonlyStateProxy | null = null;\r\n  #listDiffByRef: Map<IStatePropertyRef, IListDiff> = new Map();\r\n\r\n  constructor(engine: IComponentEngine) {\r\n    this.#engine = engine;\r\n  }\r\n\r\n  get updatedBindings(): Set<IBinding> {\r\n    return this.#updatedBindings;\r\n  }\r\n\r\n  get trackedRefs(): Set<IStatePropertyRef> {\r\n    return this.#trackedRefs;\r\n  }\r\n\r\n  get readonlyState(): IReadonlyStateProxy {\r\n    if (!this.#readonlyState) {\r\n      raiseError(\"ReadonlyState is not initialized.\");\r\n    }\r\n    return this.#readonlyState;\r\n  }\r\n\r\n  get engine(): IComponentEngine {\r\n    if (!this.#engine) {\r\n      raiseError(\"Engine is not initialized.\");\r\n    }\r\n    return this.#engine;\r\n  }\r\n\r\n  render(items: IStatePropertyRef[]): void {\r\n    this.#listDiffByRef.clear();\r\n    this.#trackedRefs.clear();\r\n    this.#updatedBindings.clear();\r\n\r\n    // 実際のレンダリングロジックを実装\r\n    const readonlyState = this.#readonlyState = createReadonlyStateProxy(this.#engine, this.#engine.state, this);\r\n    try {\r\n      readonlyState[SetCacheableSymbol](() => {\r\n        for(let i = 0; i < items.length; i++) {\r\n          const ref = items[i];\r\n          const node = findPathNodeByPath(this.#engine.pathManager.rootNode, ref.info.pattern);\r\n          if (node === null) {\r\n            raiseError(`PathNode not found: ${ref.info.pattern}`);\r\n          }\r\n          this.renderItem(ref, node);\r\n        }\r\n      });\r\n\r\n    } finally {\r\n      this.#readonlyState = null;\r\n    }\r\n  }\r\n\r\n  calcListDiff(ref: IStatePropertyRef, _newListValue: any[] | undefined | null = undefined, isNewValue: boolean = false): IListDiff {\r\n    let listDiff = this.#listDiffByRef.get(ref);\r\n    if (typeof listDiff === \"undefined\") {\r\n      const [ oldListValue, oldListIndexes ] = this.engine.getListAndListIndexes(ref.info, ref.listIndex);\r\n      let newListValue = isNewValue ? _newListValue : this.readonlyState[GetByRefSymbol](ref);\r\n      listDiff = calcListDiff(ref.listIndex, oldListValue, newListValue, oldListIndexes);\r\n      this.#listDiffByRef.set(ref, listDiff);\r\n      if (oldListValue !== newListValue) {\r\n        this.engine.saveListAndListIndexes(ref.info, ref.listIndex, newListValue, listDiff.newIndexes);\r\n      }\r\n    }\r\n    return listDiff;\r\n  }\r\n\r\n  renderItem(\r\n    ref: IStatePropertyRef,\r\n    node: IPathNode,\r\n  ): void {\r\n    if (this.trackedRefs.has(ref)) {\r\n      return; // すでに処理済みのRef情報はスキップ\r\n    }\r\n    this.trackedRefs.add(ref);\r\n\r\n    // バインディングに変更を適用する\r\n    // 変更があったバインディングはupdatedBindingsに追加する\r\n    const bindings = this.#engine.getBindings(ref.info, ref.listIndex);\r\n    for(let i = 0; i < bindings.length; i++) {\r\n      const binding = bindings[i];\r\n      if (this.updatedBindings.has(binding)) {\r\n        continue; // すでに更新済みのバインディングはスキップ\r\n      }\r\n      binding.applyChange(this);\r\n    }\r\n\r\n    // 静的な依存関係を辿る\r\n    for(const [ name, childNode ] of node.childNodeByName) {\r\n      const childInfo = getStructuredPathInfo(childNode.currentPath);\r\n      if (name === WILDCARD) {\r\n        const diff = this.calcListDiff(ref);\r\n        for(const listIndex of diff.adds ?? []) {\r\n          const childRef = getStatePropertyRef(childInfo, listIndex);\r\n          this.renderItem(childRef, childNode);\r\n        }\r\n      } else {\r\n        const childRef = getStatePropertyRef(childInfo, ref.listIndex);\r\n        this.renderItem(childRef, childNode);\r\n      }\r\n    }\r\n\r\n    // 動的な依存関係を辿る\r\n    const deps = this.#engine.pathManager.dynamicDependencies.get(ref.info.pattern);\r\n    if (deps) {\r\n      for(const depPath of deps) {\r\n        const depInfo = getStructuredPathInfo(depPath);\r\n        if (depInfo.wildcardCount > 0) {\r\n          const infos = depInfo.wildcardParentInfos;\r\n          const walk = (info: IStructuredPathInfo, listIndex: IListIndex | null, index: number, nextInfo: IStructuredPathInfo) => {\r\n            const listIndexes = this.#engine.getListIndexes(info, listIndex) || [];\r\n            if ((index + 1) < infos.length) {\r\n              for(let i = 0; i < listIndexes.length; i++) {\r\n                const subListIndex = listIndexes[i];\r\n                walk(nextInfo, subListIndex, index + 1, infos[index + 1]);\r\n              }\r\n            } else {\r\n              for(let i = 0; i < listIndexes.length; i++) {\r\n                const subListIndex = listIndexes[i];\r\n                const depRef = getStatePropertyRef(depInfo, subListIndex);\r\n                const depNode = findPathNodeByPath(this.#engine.pathManager.rootNode, depInfo.pattern);\r\n                if (depNode === null) {\r\n                  raiseError(`PathNode not found: ${depInfo.pattern}`);\r\n                }\r\n                this.renderItem(depRef, depNode);\r\n              }\r\n            }\r\n          }\r\n          walk(depInfo.wildcardParentInfos[0], null, 0, depInfo.wildcardParentInfos[1] || null);\r\n        } else {\r\n          const depRef = getStatePropertyRef(depInfo, null);\r\n          const depNode = findPathNodeByPath(this.#engine.pathManager.rootNode, depInfo.pattern);\r\n          if (depNode === null) {\r\n            raiseError(`PathNode not found: ${depInfo.pattern}`);\r\n          }\r\n          this.renderItem(depRef, depNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function render(refs: IStatePropertyRef[], engine: IComponentEngine): void {\r\n  const renderer = new Renderer(engine);\r\n  renderer.render(refs);\r\n}","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { createListIndex } from \"../ListIndex/ListIndex\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IListDiff } from \"./types\";\r\n\r\nexport function calcListDiff(\r\n  parentListIndex: IListIndex | null,\r\n  oldListValue: any[] | undefined | null,\r\n  newListValue: any[] | undefined | null,\r\n  oldIndexes: IListIndex[] | undefined | null,\r\n): IListDiff {\r\n  const _newListValue = newListValue || [];\r\n  const _oldListValue = oldListValue || [];\r\n  const _oldIndexes = oldIndexes || [];\r\n  if (_newListValue === _oldListValue || (_newListValue.length === 0 && _oldListValue.length === 0)) {\r\n    return {\r\n      oldListValue,\r\n      newListValue,\r\n      oldIndexes: _oldIndexes,\r\n      newIndexes: _oldIndexes,\r\n    };\r\n  }\r\n  if (_newListValue.length === 0) {\r\n    return {\r\n      oldListValue,\r\n      newListValue,\r\n      oldIndexes: _oldIndexes,\r\n      newIndexes: [],\r\n      removes: new Set(_oldIndexes),\r\n    };\r\n  } else if (_oldListValue.length === 0) {\r\n    const newIndexes = [];\r\n    for(let i = 0; i< _newListValue.length; i++) {\r\n      newIndexes.push(createListIndex(parentListIndex, i));\r\n    }\r\n    return {\r\n      oldListValue,\r\n      newListValue,\r\n      oldIndexes: _oldIndexes,\r\n      newIndexes,\r\n      adds: new Set(newIndexes),\r\n    };\r\n  } else {\r\n    const listIndexByListValue = new Map<any, IListIndex>();\r\n    for(let i = 0; i< _oldListValue.length; i++) {\r\n      listIndexByListValue.set(_oldListValue[i], _oldIndexes[i]);\r\n    }\r\n    const adds = new Set<IListIndex>();\r\n    const removes = new Set<IListIndex>(oldIndexes);\r\n    const overwrites = new Set<IListIndex>();\r\n    const changeIndexes = new Set<IListIndex>();\r\n    const newIndexes: IListIndex[] = [];\r\n    for(let i = 0; i< _newListValue.length; i++) {\r\n      const newValue = _newListValue[i];\r\n      let newListIndex = listIndexByListValue.get(newValue);\r\n      if (typeof newListIndex === \"undefined\") {\r\n        newListIndex = createListIndex(parentListIndex, i);\r\n        adds.add(newListIndex);\r\n      } else {\r\n        if (newListIndex.index !== i) {\r\n          newListIndex.index = i;\r\n          changeIndexes.add(newListIndex);\r\n        }\r\n        removes.delete(newListIndex);\r\n      }\r\n      newIndexes.push(newListIndex);\r\n    }\r\n    return {\r\n      oldListValue,\r\n      newListValue,\r\n      oldIndexes: _oldIndexes,\r\n      newIndexes,\r\n      adds,\r\n      removes,\r\n      overwrites,\r\n      changeIndexes,\r\n    };\r\n  }\r\n}\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IWritableStateProxy } from \"../StateClass/types\";\r\nimport { useWritableStateProxy } from \"../StateClass/useWritableStateProxy\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { render } from \"./Renderer\";\r\nimport { IUpdater } from \"./types\";\r\n\r\n\r\n/**\r\n * Updater2クラスは、状態管理と更新の中心的な役割を果たします。\r\n * 状態更新が必要な場合に、都度インスタンスを作成して使用します。\r\n * 主な機能は以下の通りです:\r\n */\r\nclass Updater implements IUpdater {\r\n  queue: IStatePropertyRef[] = [];\r\n  #updating: boolean = false;\r\n  #rendering: boolean = false;\r\n  #engine: IComponentEngine | null = null;\r\n\r\n  // Ref情報をキューに追加\r\n  enqueueRef(ref: IStatePropertyRef): void {\r\n    this.queue.push(ref);\r\n    if (this.#rendering) return;\r\n    this.#rendering = true;\r\n    queueMicrotask(() => {\r\n      this.rendering();\r\n    });\r\n  }\r\n\r\n  // 状態更新開始\r\n  async beginUpdate(engine: IComponentEngine, loopContext: ILoopContext | null, callback: (state: IWritableStateProxy) => Promise<void>): Promise<void> {\r\n    try {\r\n      this.#updating = true;\r\n      this.#engine = engine;\r\n      await useWritableStateProxy(engine, this, engine.state, loopContext, async (state:IWritableStateProxy) => {\r\n        // 状態更新処理\r\n        await callback(state);\r\n      });\r\n    } finally {\r\n      this.#updating = false;\r\n    }\r\n  }\r\n\r\n  // レンダリング\r\n  rendering(): void {\r\n    try {\r\n      while( this.queue.length > 0 ) {\r\n        // キュー取得\r\n        const queue = this.queue;\r\n        this.queue = [];\r\n        if (!this.#engine) raiseError(\"Engine is not initialized.\");\r\n        // レンダリング実行\r\n        render(queue, this.#engine);\r\n      }\r\n    } finally {\r\n      this.#rendering = false;\r\n    }\r\n  }\r\n}\r\n\r\nexport async function update(engine: IComponentEngine, loopContext: ILoopContext | null, callback: (updater: IUpdater, state: IWritableStateProxy) => Promise<void>): Promise<void> {\r\n  const updater = new Updater();\r\n  await updater.beginUpdate(engine, loopContext, async (state) => {\r\n    await callback(updater, state);\r\n  });\r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { update } from \"../../Updater/Updater.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeEventクラスは、イベントバインディング（onClick, onInputなど）を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - 指定イベント（on～）に対して、バインディングされた関数をイベントリスナーとして登録\r\n * - デコレータ（preventDefault, stopPropagation）によるイベント制御に対応\r\n * - ループコンテキストやリストインデックスも引数としてイベントハンドラに渡す\r\n * - ハンドラ実行時はstateProxyを生成し、Updater経由で非同期的に状態を更新\r\n *\r\n * 設計ポイント:\r\n * - nameからイベント名（subName）を抽出し、addEventListenerで登録\r\n * - バインディング値が関数でない場合はエラー\r\n * - デコレータでpreventDefault/stopPropagationを柔軟に制御\r\n * - ループ内イベントにも対応し、リストインデックスを引数展開\r\n */\r\nclass BindingNodeEvent extends BindingNode {\r\n  #subName    : string;\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    this.#subName = this.name.slice(2); // on～\r\n    const element = node as HTMLElement;\r\n    element.addEventListener(this.subName, (e:Event) => this.handler(e));\r\n  }\r\n  get subName(): string {\r\n    return this.#subName;\r\n  }\r\n  update() {\r\n    // 何もしない（イベントバインディングは初期化時のみ）\r\n  }\r\n\r\n  async handler(e: Event) {\r\n    const engine = this.binding.engine;\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n    const indexes = loopContext?.serialize().map((context) => context.listIndex.index) ?? [];\r\n    const options = this.decorates;\r\n    if (options.includes(\"preventDefault\")) {\r\n      e.preventDefault();\r\n    }\r\n    if (options.includes(\"stopPropagation\")) {\r\n      e.stopPropagation();\r\n    }\r\n    await update(engine, loopContext, async (updater, state) => {\r\n      // stateProxyを生成し、バインディング値を実行\r\n      const func = this.binding.bindingState.getValue(state);\r\n      if (typeof func !== \"function\") {\r\n        raiseError(`BindingNodeEvent: ${this.name} is not a function.`);\r\n      }\r\n      await Reflect.apply(func, state, [e, ...indexes]);\r\n    });\r\n  }\r\n  applyChange(renderer: IRenderer): void {\r\n    // イベントバインディングは初期化時のみで、状態変更時に何もしない\r\n  }\r\n}\r\n\r\n/**\r\n * イベントバインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeEventインスタンスを生成\r\n */\r\nexport const createBindingNodeEvent: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeEvent(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { COMMENT_TEMPLATE_MARK } from \"../../constants.js\";\r\nimport { Filters } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\n\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\n/**\r\n * BindingNodeBlockクラスは、テンプレートブロック（コメントノードによるテンプレート挿入部）を\r\n * バインディング対象とするためのバインディングノード実装です。\r\n *\r\n * 主な役割:\r\n * - コメントノード内のテンプレートIDを抽出し、idプロパティとして保持\r\n * - テンプレートブロックのバインディング処理の基盤となる\r\n *\r\n * 設計ポイント:\r\n * - コメントノードのテキストからテンプレートIDを抽出（COMMENT_TEMPLATE_MARK以降を数値変換）\r\n * - IDが取得できない場合はエラーを投げる\r\n * - 他のBindingNode系クラスと同様、フィルタやデコレータにも対応\r\n */\r\nexport class BindingNodeBlock extends BindingNode {\r\n  #id: number;\r\n  get id(): number {\r\n    return this.#id;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const id = this.node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN) ?? raiseError(\"BindingNodeBlock.id: invalid node\");\r\n    this.#id = Number(id);\r\n  }\r\n    \r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindContent } from \"../BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeIfクラスは、ifバインディング（条件付き描画）を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値（boolean）に応じて、BindContent（描画内容）のマウント・アンマウントを制御\r\n * - true/false時のBindContent集合を管理し、現在の描画状態をbindContentsで取得可能\r\n *\r\n * 設計ポイント:\r\n * - assignValueでboolean型以外が渡された場合はエラー\r\n * - trueならBindContentをrender・mount、falseならunmount\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeIf extends BindingNodeBlock {\r\n  #bindContent: IBindContent;\r\n  #trueBindContents: IBindContent[];\r\n  #falseBindContents: IBindContent[] = [];\r\n  #bindContents: IBindContent[];\r\n\r\n  get bindContents(): IBindContent[] {\r\n    return this.#bindContents;\r\n  }\r\n\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const blankInfo = getStructuredPathInfo(\"\");\r\n    const blankRef = getStatePropertyRef(blankInfo, null);\r\n    this.#bindContent = createBindContent(\r\n      this.binding, \r\n      this.id, \r\n      this.binding.engine,\r\n      blankRef, \r\n    );\r\n    this.#trueBindContents = this.#bindContents = [this.#bindContent];\r\n  }\r\n\r\n  assignValue(value: any): void {\r\n    raiseError(`BindingNodeIf.assignValue: not implemented`);\r\n  }\r\n  \r\n  applyChange(renderer: IRenderer): void {\r\n    if (renderer.updatedBindings.has(this.binding)) return;\r\n    const filteredValue = this.binding.bindingState.getFilteredValue(renderer.readonlyState);\r\n    if (typeof filteredValue !== \"boolean\") {\r\n      raiseError(`BindingNodeIf.update: value is not boolean`);\r\n    }\r\n    const parentNode = this.node.parentNode;\r\n    if (parentNode == null) {\r\n      raiseError(`BindingNodeIf.update: parentNode is null`);\r\n    }\r\n    if (filteredValue) {\r\n      this.#bindContent.mountAfter(parentNode, this.node);\r\n      this.#bindContent.applyChange(renderer);\r\n      this.#bindContents = this.#trueBindContents;\r\n    } else {\r\n      this.#bindContent.unmount();\r\n      this.#bindContents = this.#falseBindContents;\r\n    }\r\n    renderer.updatedBindings.add(this.binding);\r\n  }\r\n}\r\n\r\n/**\r\n * ifバインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeIfインスタンスを生成\r\n */\r\nexport const createBindingNodeIf: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeIf(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindContent } from \"../BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nconst EMPTY_SET = new Set<any>();\r\n\r\n/**\r\n * BindingNodeForクラスは、forバインディング（配列やリストの繰り返し描画）を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - リストデータの各要素ごとにBindContent（バインディングコンテキスト）を生成・管理\r\n * - 配列の差分検出により、必要なBindContentの生成・再利用・削除・再描画を最適化\r\n * - DOM上での要素の並び替えや再利用、アンマウント・マウント処理を効率的に行う\r\n * - プール機構によりBindContentの再利用を促進し、パフォーマンスを向上\r\n *\r\n * 設計ポイント:\r\n * - assignValueでリストの差分を検出し、BindContentの生成・削除・再利用を管理\r\n * - updateElementsでリストの並び替えやSWAP処理にも対応\r\n * - BindContentのプール・インデックス管理でGCやDOM操作の最小化を図る\r\n * - バインディング状態やリストインデックス情報をエンジンに保存し、再描画や依存解決を容易にする\r\n *\r\n * ファクトリ関数 createBindingNodeFor でフィルタ・デコレータ適用済みインスタンスを生成\r\n */\r\nclass BindingNodeFor extends BindingNodeBlock {\r\n  #bindContents          : IBindContent[] = [];\r\n  #bindContentByListIndex: WeakMap<IListIndex, IBindContent> = new WeakMap();\r\n  #bindContentPool       : IBindContent[] = [];\r\n  #bindContentLastIndex  : number = 0;\r\n  #loopInfo: IStructuredPathInfo | undefined = undefined;\r\n\r\n  get bindContents(): IBindContent[] {\r\n    return this.#bindContents;\r\n  }\r\n\r\n  get isFor(): boolean {\r\n    return true;\r\n  }\r\n\r\n  init() {\r\n  }\r\n\r\n  createBindContent(listIndex: IListIndex): IBindContent {\r\n    let bindContent: IBindContent;\r\n    if (this.#bindContentLastIndex >= 0) {\r\n      // プールの最後の要素を取得して、プールの長さをあとで縮減する\r\n      // 作るたびにプールを縮減すると、パフォーマンスが悪化するため\r\n      // プールの長さを縮減するのは、全ての要素を作った後に行う\r\n      bindContent = this.#bindContentPool[this.#bindContentLastIndex];\r\n      this.#bindContentLastIndex--;\r\n      bindContent.assignListIndex(listIndex);\r\n    } else {\r\n      const loopRef = getStatePropertyRef(this.loopInfo, listIndex);\r\n      bindContent = createBindContent(\r\n        this.binding,\r\n        this.id,\r\n        this.binding.engine,\r\n        loopRef\r\n      );\r\n    }\r\n    // 登録\r\n    this.#bindContentByListIndex.set(listIndex, bindContent);\r\n    return bindContent;\r\n  }\r\n\r\n  deleteBindContent(bindContent: IBindContent): void {\r\n    bindContent.unmount();\r\n    bindContent.loopContext?.clearListIndex();\r\n  }\r\n\r\n  get bindContentLastIndex():number {\r\n    return this.#bindContentLastIndex;\r\n  }\r\n  set bindContentLastIndex(value:number) {\r\n    this.#bindContentLastIndex = value;\r\n  }\r\n\r\n  get poolLength():number {\r\n    return this.#bindContentPool.length;\r\n  }\r\n  set poolLength(length: number) {\r\n    if (length < 0) {\r\n      raiseError(`BindingNodeFor.setPoolLength: length is negative`);\r\n    }\r\n    this.#bindContentPool.length = length;\r\n  }\r\n\r\n  get loopInfo(): IStructuredPathInfo {\r\n    if (typeof this.#loopInfo === \"undefined\") {\r\n      const loopPath = this.binding.bindingState.pattern + \".*\";\r\n      this.#loopInfo = getStructuredPathInfo(loopPath);\r\n    }\r\n    return this.#loopInfo;\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    raiseError(\"BindingNodeFor.assignValue: Not implemented. Use update or applyChange.\");\r\n  }\r\n\r\n  applyChange(renderer: IRenderer): void {\r\n    if (renderer.updatedBindings.has(this.binding)) return;\r\n    let newBindContents: IBindContent[] = [];\r\n    // 削除を先にする\r\n    const removeBindContentsSet = new Set<IBindContent>();\r\n    const listDiff = renderer.calcListDiff(this.binding.bindingState.ref);\r\n    const parentNode = this.node.parentNode ?? raiseError(`BindingNodeFor.update: parentNode is null`);\r\n    // 全削除最適化のフラグ\r\n    const isAllRemove = (listDiff.oldListValue?.length === listDiff.removes?.size && (listDiff.oldListValue?.length ?? 0) > 0);\r\n    // 親ノードこのノードだけ持つかのチェック\r\n    let isParentNodeHasOnlyThisNode = false;\r\n    if (isAllRemove) {\r\n      const parentChildNodes = Array.from(parentNode.childNodes);\r\n      const lastContent = this.#bindContents.at(-1) ?? raiseError(`BindingNodeFor.update: lastContent is null`);\r\n      // ブランクノードを飛ばす\r\n      let firstNode: Node | null = parentChildNodes[0];\r\n      while(firstNode && firstNode.nodeType === Node.TEXT_NODE && firstNode.textContent?.trim() === \"\") {\r\n        firstNode = firstNode.nextSibling;\r\n      }\r\n      let lastNode: Node | null = parentChildNodes.at(-1) ?? null;\r\n      while(lastNode && lastNode.nodeType === Node.TEXT_NODE && lastNode.textContent?.trim() === \"\") {\r\n        lastNode = lastNode.previousSibling;\r\n      }\r\n      if (firstNode === this.node && lastNode === lastContent.getLastNode(parentNode)) {\r\n        isParentNodeHasOnlyThisNode = true;\r\n      }\r\n    }\r\n    if (isAllRemove && isParentNodeHasOnlyThisNode) {\r\n      // 全削除最適化\r\n      parentNode.textContent = \"\";\r\n      parentNode.append(this.node);\r\n      for(let i = 0; i < this.#bindContents.length; i++) {\r\n        const bindContent = this.#bindContents[i];\r\n        bindContent.loopContext?.clearListIndex();\r\n      }\r\n      this.#bindContentPool.push(...this.#bindContents);\r\n    } else {\r\n      if (listDiff.removes) {\r\n        for(const listIndex of listDiff.removes) {\r\n          const bindContent = this.#bindContentByListIndex.get(listIndex);\r\n          if (typeof bindContent === \"undefined\") {\r\n            raiseError(`BindingNodeFor.applyChange: bindContent is not found`);\r\n          }\r\n          this.deleteBindContent(bindContent);\r\n          removeBindContentsSet.add(bindContent);\r\n        }\r\n      }\r\n      this.#bindContentPool.push(...removeBindContentsSet);\r\n    }\r\n\r\n    let lastBindContent = null;\r\n    const firstNode = this.node;\r\n    this.bindContentLastIndex = this.poolLength - 1;\r\n    const isAllAppend = listDiff.newListValue?.length === listDiff.adds?.size && (listDiff.newListValue?.length ?? 0) > 0;\r\n//    if (!listDiff.onlySwap) {\r\n      // 全追加の場合、バッファリングしてから一括追加する\r\n      const fragmentParentNode = isAllAppend ? document.createDocumentFragment() : parentNode;\r\n      const fragmentFirstNode = isAllAppend ? null : firstNode;\r\n      const adds = listDiff.adds ?? EMPTY_SET;\r\n      for(const listIndex of listDiff.newIndexes) {\r\n        const lastNode = lastBindContent?.getLastNode(fragmentParentNode) ?? fragmentFirstNode;\r\n        let bindContent;\r\n        if (adds.has(listIndex)) {\r\n          bindContent = this.createBindContent(listIndex);\r\n          bindContent.mountAfter(fragmentParentNode, lastNode);\r\n          bindContent.applyChange(renderer);\r\n        } else {\r\n          bindContent = this.#bindContentByListIndex.get(listIndex);\r\n          if (typeof bindContent === \"undefined\") {\r\n            raiseError(`BindingNodeFor.applyChange: bindContent is not found`);\r\n          }\r\n          if (lastNode?.nextSibling !== bindContent.firstChildNode) {\r\n            bindContent.mountAfter(fragmentParentNode, lastNode);\r\n          }\r\n        }\r\n        newBindContents.push(bindContent);\r\n        lastBindContent = bindContent;\r\n      }\r\n      // 全追加最適化\r\n      if (isAllAppend) {\r\n        const beforeNode = firstNode.nextSibling;\r\n        parentNode.insertBefore(fragmentParentNode, beforeNode);\r\n      }\r\n//    } else {\r\n      // リストインデックスの並び替え\r\n      // リストインデックスの並び替え時、インデックスの変更だけなので、要素の再描画はしたくない\r\n      // 並べ替えはするが、要素の内容は変わらないため\r\n/*\r\n      if (listIndexResults.swapTargets) {\r\n        const bindContents = Array.from(this.#bindContents);\r\n        const targets = Array.from(listIndexResults.swapTargets);\r\n        targets.sort((a, b) => a.index - b.index);\r\n        for(let i = 0; i < targets.length; i++) {\r\n          const targetListIndex = targets[i];\r\n          const targetBindContent = this.#bindContentByListIndex.get(targetListIndex);\r\n          if (typeof targetBindContent === \"undefined\") {\r\n            raiseError(`BindingNodeFor.assignValue2: bindContent is not found`);\r\n          }\r\n          bindContents[targetListIndex.index] = targetBindContent;\r\n          const lastNode = bindContents[targetListIndex.index - 1]?.getLastNode(parentNode) ?? firstNode;\r\n          targetBindContent.mountAfter(parentNode, lastNode);\r\n        }\r\n        newBindContents = bindContents;\r\n      }\r\n*/\r\n//    }\r\n    // リスト要素の上書き\r\n/*    \r\n    if (listDiff.replaces) {\r\n      for (const listIndex of listDiff.replaces) {\r\n        const bindContent = this.#bindContentByListIndex.get(listIndex);\r\n        if (typeof bindContent === \"undefined\") {\r\n          raiseError(`BindingNodeFor.assignValue2: bindContent is not found`);\r\n        }\r\n        bindContent.applyChange(renderer);\r\n      }\r\n    }\r\n*/\r\n    // プールの長さを更新する\r\n    // プールの長さは、プールの最後の要素のインデックス+1であるため、\r\n    this.poolLength = this.bindContentLastIndex + 1;\r\n    this.#bindContents = newBindContents;\r\n  }\r\n}\r\n\r\nexport const createBindingNodeFor: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeFor(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { NodeType } from \"./types\";\r\n\r\nconst DEFAULT_PROPERTY = \"textContent\";\r\n\r\ntype DefaultPropertyByElementType = {\r\n  [key:string]: string;\r\n}\r\n\r\nconst defaultPropertyByElementType:DefaultPropertyByElementType = {\r\n  \"radio\"   : \"checked\",\r\n  \"checkbox\": \"checked\",\r\n  \"button\"  : \"onclick\",\r\n}\r\n\r\n/**\r\n * HTML要素のデフォルトプロパティを取得\r\n */\r\nconst getDefaultPropertyHTMLElement = (node:Node):string => \r\n  node instanceof HTMLSelectElement || node instanceof HTMLTextAreaElement || node instanceof HTMLOptionElement ? \"value\" : \r\n  node instanceof HTMLButtonElement ? \"onclick\" : \r\n  node instanceof HTMLAnchorElement ? \"onclick\" : \r\n  node instanceof HTMLFormElement ? \"onsubmit\" : \r\n  node instanceof HTMLInputElement ? (defaultPropertyByElementType[node.type] ?? \"value\") :\r\n  DEFAULT_PROPERTY;\r\n\r\ntype DefaultPropertyByKey = {\r\n  [key:string]: string | undefined;\r\n}\r\n\r\nconst _cache: DefaultPropertyByKey = {};\r\n\r\nconst textContentProperty = (node:Node):string => DEFAULT_PROPERTY;\r\n\r\ntype GetDefaultPropertyByNodeType = {\r\n  [key in NodeType]: ((node:Node)=>string) | undefined;\r\n}\r\n\r\nconst getDefaultPropertyByNodeType: GetDefaultPropertyByNodeType = {\r\n  HTMLElement: getDefaultPropertyHTMLElement,\r\n  SVGElement : undefined,\r\n  Text       : textContentProperty,\r\n  Template   : undefined,\r\n}\r\n\r\n/**\r\n * バインド情報でノードプロパティが省略された場合に、ノード種別・要素タイプごとに\r\n * 適切なデフォルトプロパティ名（例: textContent, value, checked, onclick など）を返すユーティリティ関数。\r\n *\r\n * - HTMLInputElementやHTMLSelectElementなど、要素ごとに最適なプロパティを判定\r\n * - input要素はtype属性（radio, checkboxなど）も考慮\r\n * - 一度判定した組み合わせはキャッシュし、パフォーマンス向上\r\n *\r\n * @param node     対象ノード\r\n * @param nodeType ノードタイプ（\"HTMLElement\" | \"SVGElement\" | \"Text\" | \"Template\"）\r\n * @returns        デフォルトのプロパティ名（例: \"value\", \"checked\", \"textContent\" など）\r\n */\r\nexport function getDefaultName(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n): string | undefined {\r\n  const key = node.constructor.name + \"\\t\" + ((node as HTMLInputElement).type ?? \"\"); // type attribute\r\n  return _cache[key] ?? (_cache[key] = getDefaultPropertyByNodeType[nodeType]?.(node));\r\n}\r\n  ","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { getDefaultName } from \"../../BindingBuilder/getDefaultName.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { update } from \"../../Updater/Updater.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nfunction isTwoWayBindable(element: HTMLElement): boolean {\r\n  return element instanceof HTMLInputElement || \r\n    element instanceof HTMLTextAreaElement || \r\n    element instanceof HTMLSelectElement;\r\n}\r\n\r\nconst defaultEventByName: {[key:string]: string} = {\r\n  \"value\"   : \"input\",\r\n  \"checked\" : \"change\",\r\n  \"selected\": \"change\",\r\n};\r\n\r\n/**\r\n * BindingNodePropertyクラスは、ノードのプロパティ（value, checked, selected など）への\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - ノードプロパティへの値の割り当て・取得\r\n * - 双方向バインディング（input, changeイベント等）に対応\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - デフォルトプロパティ名と一致し、かつ双方向バインディング可能な要素の場合のみイベントリスナーを登録\r\n * - デコレータでイベント名を指定可能（onInput, onChangeなど）\r\n * - イベント発火時はUpdater経由でstateを非同期的に更新\r\n * - assignValueでnull/undefined/NaNは空文字列に変換してセット\r\n */\r\nclass BindingNodeProperty extends BindingNode {\r\n  get value(): any {\r\n    // @ts-ignore\r\n    return this.node[this.name];\r\n  }\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for(let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n\r\n    const isElement = this.node instanceof HTMLElement;\r\n    if (!isElement) return;\r\n    if (!isTwoWayBindable(this.node)) return;\r\n    const defaultName = getDefaultName(this.node, \"HTMLElement\");\r\n    if (defaultName !== this.name) return;\r\n    if (decorates.length > 1) raiseError(`BindingNodeProperty: ${this.name} has multiple decorators`);\r\n    const event = (decorates[0]?.startsWith(\"on\") ? decorates[0]?.slice(2) : decorates[0]) ?? null;\r\n    const eventName = event ?? defaultEventByName[this.name] ?? \"readonly\";\r\n    if (eventName === \"readonly\" || eventName === \"ro\") return;\r\n\r\n    // 双方向バインディング: イベント発火時にstateを更新\r\n    const engine = this.binding.engine;\r\n    this.node.addEventListener(eventName, async () => {\r\n      const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n      const value = this.filteredValue;\r\n      await update(engine, loopContext, async (updater, state) => {\r\n        binding.updateStateValue(state, value);\r\n      });\r\n    });\r\n  }\r\n\r\n  init() {\r\n    // サブクラスで初期化処理を実装可能\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    // @ts-ignore\r\n    this.node[this.name] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * プロパティバインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodePropertyインスタンスを生成\r\n */\r\nexport const createBindingNodeProperty: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeProperty(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeRadioクラスは、ラジオボタン（input[type=\"radio\"]）の\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値とinput要素のvalueが一致していればchecked=trueにする\r\n * - null/undefined/NaNの場合は空文字列に変換して比較\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - assignValueで値を文字列化し、input要素のvalueと比較してcheckedを制御\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeRadio extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value.toString() === element.value.toString();\r\n  }\r\n}\r\n\r\n/**\r\n * ラジオボタン用バインディングノード生成ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeRadioインスタンスを生成\r\n */\r\nexport const createBindingNodeRadio: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeRadio(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeStyleクラスは、style属性（インラインスタイル）のバインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値を指定のCSSプロパティ（subName）としてHTMLElementにセット\r\n * - null/undefined/NaNの場合は空文字列に変換してセット\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - nameからCSSプロパティ名（subName）を抽出（例: \"style.color\" → \"color\"）\r\n * - assignValueで値を文字列化し、style.setPropertyで反映\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeStyle extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as HTMLElement;\r\n    element.style.setProperty(this.subName, value.toString());\r\n  }\r\n}\r\n\r\n/**\r\n * style属性バインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeStyleインスタンスを生成\r\n */\r\nexport const createBindingNodeStyle: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeStyle(binding, node, name, filterFns, decorates);\r\n  }\r\n","const symbolName = \"component-state-input\";\r\n\r\nexport const AssignStateSymbol: unique symbol = Symbol.for(`${symbolName}.AssignState`);\r\nexport const NotifyRedrawSymbol: unique symbol = Symbol.for(`${symbolName}.NotifyRedraw`);","import { StructiveComponent } from \"./types\";\r\n\r\nconst parentStructiveComponentByStructiveComponent = new WeakMap<StructiveComponent, StructiveComponent>();\r\n\r\nexport function findStructiveParent(el:StructiveComponent): StructiveComponent | null {\r\n  return parentStructiveComponentByStructiveComponent.get(el) ?? null;\r\n}\r\n\r\nexport function registerStructiveComponent(parentComponent: StructiveComponent, component: StructiveComponent): void {\r\n  parentStructiveComponentByStructiveComponent.set(component, parentComponent);\r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { NotifyRedrawSymbol } from \"../../ComponentStateInput/symbols.js\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { registerStructiveComponent } from \"../../WebComponents/findStructiveParent.js\";\r\nimport { StructiveComponent } from \"../../WebComponents/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeComponentクラスは、StructiveComponent（カスタムコンポーネント）への\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング対象のコンポーネントのstateプロパティ（subName）に値を反映\r\n * - バインディング情報をコンポーネント単位で管理（bindingsByComponentに登録）\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - nameからstateプロパティ名（subName）を抽出（例: \"state.foo\" → \"foo\"）\r\n * - assignValueでコンポーネントのstateに値をセット（RenderSymbol経由で反映）\r\n * - 初期化時にbindingsByComponentへバインディング情報を登録\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeComponent extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n\r\n  init(): void {\r\n    const engine = this.binding.engine;\r\n    registerStructiveComponent(engine.owner, this.node as StructiveComponent);\r\n    let bindings = engine.bindingsByComponent.get(this.node as StructiveComponent);\r\n    if (typeof bindings === \"undefined\") {\r\n      engine.bindingsByComponent.set(this.node as StructiveComponent, bindings = new Set<IBinding>());\r\n    }\r\n    bindings.add(this.binding);\r\n  }\r\n\r\n  assignValue(value: any): void {\r\n  }\r\n\r\n  notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    const notifyRefs = [];\r\n    const info = this.binding.bindingState.info;\r\n    const listIndex = this.binding.bindingState.listIndex?.at(info.wildcardCount - 1) ?? null;\r\n    const at = (listIndex?.length ?? 0) - 1;\r\n    for(const ref of refs) {\r\n      if (info.pathSegments.length > ref.info.pathSegments.length) {\r\n        // 親パスが更新された\r\n        // ex values, values.* valuesが更新された場合\r\n        if (info.cumulativePathSet.has(ref.info.pattern)) {\r\n          const thisAt = (ref.listIndex?.length ?? 0) - 1;\r\n          if (thisAt >= 0) {\r\n            if (listIndex === null) continue;\r\n            if (ref.listIndex !== listIndex?.at(thisAt)) continue;\r\n          }\r\n          const newRef = getStatePropertyRef(info, listIndex);\r\n          notifyRefs.push(newRef);\r\n        }\r\n      } else {\r\n        // 子パスが更新された\r\n        // ex values.*.foo values.* values.*.fooが更新された\r\n        if (!ref.info.cumulativePathSet.has(info.pattern)) {\r\n          // リストインデックスが一致しない場合はスキップ\r\n          if (at >= 0) {\r\n            if (ref.listIndex?.at(at) !== listIndex) continue;\r\n          }\r\n          notifyRefs.push(ref);\r\n        }\r\n\r\n      }\r\n    }\r\n    if (notifyRefs.length === 0) {\r\n      return;\r\n    }\r\n    const component = this.node as StructiveComponent;\r\n    component.state[NotifyRedrawSymbol](notifyRefs);\r\n  }\r\n}\r\n\r\n/**\r\n * コンポーネント用バインディングノード生成ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeComponentインスタンスを生成\r\n */\r\nexport const createBindingNodeComponent: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeComponent(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createBindingNodeAttribute } from \"../DataBinding/BindingNode/BindingNodeAttribute.js\";\r\nimport { createBindingNodeCheckbox } from \"../DataBinding/BindingNode/BindingNodeCheckbox.js\";\r\nimport { createBindingNodeClassList } from \"../DataBinding/BindingNode/BindingNodeClassList.js\";\r\nimport { createBindingNodeClassName } from \"../DataBinding/BindingNode/BindingNodeClassName.js\";\r\nimport { createBindingNodeEvent } from \"../DataBinding/BindingNode/BindingNodeEvent.js\";\r\nimport { createBindingNodeIf } from \"../DataBinding/BindingNode/BindingNodeIf.js\";\r\nimport { createBindingNodeFor } from \"../DataBinding/BindingNode/BindingNodeFor.js\";\r\nimport { createBindingNodeProperty } from \"../DataBinding/BindingNode/BindingNodeProperty.js\";\r\nimport { createBindingNodeRadio } from \"../DataBinding/BindingNode/BindingNodeRadio.js\";\r\nimport { createBindingNodeStyle } from \"../DataBinding/BindingNode/BindingNodeStyle.js\";\r\nimport { CreateBindingNodeByNodeFn, CreateBindingNodeFn } from \"../DataBinding/BindingNode/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IFilterText } from \"./types\";\r\nimport { createBindingNodeComponent } from \"../DataBinding/BindingNode/BindingNodeComponent.js\";\r\n\r\ntype NodePropertyConstructorByName = {[key:string]:CreateBindingNodeFn};\r\ntype NodePropertyConstructorByNameByIsComment = {[key:number]:NodePropertyConstructorByName};\r\n\r\nconst nodePropertyConstructorByNameByIsComment:NodePropertyConstructorByNameByIsComment = {\r\n  0: {\r\n    \"class\"   : createBindingNodeClassList,\r\n    \"checkbox\": createBindingNodeCheckbox,\r\n    \"radio\"   : createBindingNodeRadio,\r\n  },\r\n  1: {\r\n    \"if\" : createBindingNodeIf,\r\n  },\r\n};\r\n\r\ntype NodePropertyConstructorByFirstName = {[key:string]:CreateBindingNodeFn};\r\n\r\nconst nodePropertyConstructorByFirstName:NodePropertyConstructorByFirstName = {\r\n  \"class\": createBindingNodeClassName,\r\n  \"attr\" : createBindingNodeAttribute,\r\n  \"style\": createBindingNodeStyle,\r\n  \"state\": createBindingNodeComponent,\r\n//  \"popover\": PopoverTarget,\r\n//  \"commandfor\": CommandForTarget,\r\n};\r\n\r\n/**\r\n * バインディング対象ノードのプロパティ名やノード種別（Element/Comment）に応じて、\r\n * 適切なバインディングノード生成関数（CreateBindingNodeFn）を返すユーティリティ。\r\n *\r\n * - ノード種別やプロパティ名ごとに専用の生成関数をマッピング\r\n * - コメントノードや特殊プロパティ（for/if等）にも対応\r\n * - プロパティ名の先頭や\"on\"でイベントバインディングも判別\r\n * - 一度判定した組み合わせはキャッシュし、パフォーマンス向上\r\n *\r\n * これにより、テンプレートのdata-bindやコメントバインディングの各種ケースに柔軟に対応できる。\r\n */\r\nfunction _getBindingNodeCreator(isComment:boolean, isElement: boolean, propertyName: string): CreateBindingNodeFn {\r\n  // コメント/エレメント種別とプロパティ名で専用の生成関数を優先的に取得\r\n  const bindingNodeCreatorByName = nodePropertyConstructorByNameByIsComment[isComment ? 1 : 0][propertyName];\r\n  if (typeof bindingNodeCreatorByName !== \"undefined\") {\r\n    return bindingNodeCreatorByName;\r\n  }\r\n  // コメントノードでforの場合は専用関数\r\n  if (isComment && propertyName === \"for\") {\r\n    return createBindingNodeFor;\r\n  }\r\n  // コメントノードで未対応プロパティはエラー\r\n  if (isComment) {\r\n    raiseError(`getBindingNodeCreator: unknown node property ${propertyName}`);\r\n  }\r\n  // プロパティ名の先頭で判別（class.attr.style.state等）\r\n  const nameElements = propertyName.split(\".\");\r\n  const bindingNodeCreatorByFirstName = nodePropertyConstructorByFirstName[nameElements[0]];\r\n  if (typeof bindingNodeCreatorByFirstName !== \"undefined\") {\r\n    return bindingNodeCreatorByFirstName;\r\n  }\r\n  // エレメントノードでonから始まる場合はイベントバインディング\r\n  if (isElement) {\r\n    if (propertyName.startsWith(\"on\")) {\r\n      return createBindingNodeEvent;\r\n    } else {\r\n      return createBindingNodeProperty;\r\n    }\r\n  } else {\r\n    // それ以外は汎用プロパティバインディング\r\n    return createBindingNodeProperty;\r\n  }\r\n}\r\n\r\nconst _cache: {[key:string]:CreateBindingNodeFn} = {};\r\n\r\n/**\r\n * ノード・プロパティ名・フィルタ・デコレータ情報から\r\n * 適切なバインディングノード生成関数を取得し、呼び出すファクトリ関数。\r\n * \r\n * @param node         バインディング対象ノード\r\n * @param propertyName バインディングプロパティ名\r\n * @param filterTexts  フィルタ情報\r\n * @param decorates    デコレータ情報\r\n * @returns            バインディングノード生成関数の実行結果\r\n */\r\nexport function getBindingNodeCreator(\r\n  node        : Node, \r\n  propertyName: string,\r\n  filterTexts : IFilterText[],\r\n  decorates   : string[]\r\n): CreateBindingNodeByNodeFn {\r\n  const isComment = node instanceof Comment;\r\n  const isElement = node instanceof Element;\r\n  const key = isComment + \"\\t\" + isElement + \"\\t\" + propertyName;\r\n  // キャッシュを利用して生成関数を取得\r\n  const fn = _cache[key] ?? (_cache[key] = _getBindingNodeCreator(isComment, isElement, propertyName));\r\n  return fn(propertyName, filterTexts, decorates);\r\n}\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { GetByRefSymbol, SetByRefSymbol } from \"../../StateClass/symbols.js\";\r\nimport { IReadonlyStateProxy, IWritableStateProxy } from \"../../StateClass/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\n/**\r\n * BindingStateクラスは、バインディング対象の状態（State）プロパティへのアクセス・更新・フィルタ適用を担当する実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング対象の状態プロパティ（pattern, info）やリストインデックス（listIndex）を管理\r\n * - get valueで現在の値を取得し、get filteredValueでフィルタ適用後の値を取得\r\n * - initでリストバインディング時のループコンテキストやインデックス参照を初期化\r\n * - assignValueで状態プロキシに値を書き込む（双方向バインディング対応）\r\n * - バインディング情報をエンジンに登録し、依存解決や再描画を効率化\r\n *\r\n * 設計ポイント:\r\n * - ワイルドカードパス（配列バインディング等）にも対応し、ループごとのインデックス管理が可能\r\n * - フィルタ適用は配列で柔軟に対応\r\n * - createBindingStateファクトリでフィルタ適用済みインスタンスを生成\r\n */\r\nclass BindingState implements IBindingState {\r\n  #binding     : IBinding;\r\n  #pattern     : string;\r\n  #info        : IStructuredPathInfo;\r\n  #filters     : Filters;\r\n  #ref         : IStatePropertyRef | null = null;\r\n  get pattern(): string {\r\n    return this.#pattern;\r\n  }\r\n  get info() {\r\n    return this.#info;\r\n  }\r\n  get listIndex() {\r\n    return this.ref.listIndex;\r\n  }\r\n  get ref() {\r\n    return this.#ref ?? raiseError(\"ref is null\");\r\n  }\r\n  get filters() {\r\n    return this.#filters;\r\n  }\r\n  get binding() {\r\n    return this.#binding;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this.#binding = binding;\r\n    this.#pattern = pattern;\r\n    this.#info = getStructuredPathInfo(pattern);\r\n    this.#filters = filters;\r\n  }\r\n  getValue(state:IReadonlyStateProxy | IWritableStateProxy): any {\r\n    return state[GetByRefSymbol](this.ref);\r\n  }\r\n  getFilteredValue(state:IReadonlyStateProxy | IWritableStateProxy): any {\r\n    let value = state[GetByRefSymbol](this.ref);\r\n    for(let i = 0; i < this.#filters.length; i++) {\r\n      value = this.#filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  init(): void {\r\n    if (this.info.wildcardCount > 0) {\r\n      const lastWildcardPath = this.info.lastWildcardPath ?? \r\n        raiseError(`BindingState.init: wildcardLastParentPath is null`);\r\n      const loopContext = this.binding.parentBindContent.currentLoopContext?.find(lastWildcardPath) ?? \r\n        raiseError(`BindingState.init: loopContext is null`);\r\n      this.#ref = getStatePropertyRef(this.#info, loopContext.listIndex);\r\n    } else {\r\n      this.#ref = getStatePropertyRef(this.#info, null);\r\n    }\r\n    this.binding.engine.saveBinding(this.info, this.listIndex, this.binding);\r\n  }\r\n  assignValue(writeState: IWritableStateProxy, value: any) {\r\n    writeState[SetByRefSymbol](this.ref, value);\r\n  }\r\n}\r\n\r\nexport const createBindingState: CreateBindingStateFn = \r\n(name: string, filterTexts: IFilterText[]) => \r\n  (binding:IBinding, filters:FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts); // ToDo:ここは、メモ化できる\r\n    return new BindingState(binding, name, filterFns);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { IReadonlyStateProxy, IWritableStateProxy } from \"../../StateClass/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\n/**\r\n * BindingStateIndexクラスは、forバインディング等のループ内で利用される\r\n * インデックス値（$1, $2, ...）のバインディング状態を管理する実装です。\r\n *\r\n * 主な役割:\r\n * - ループコンテキストからインデックス値を取得し、value/filteredValueで参照可能にする\r\n * - バインディング時にbindingsByListIndexへ自身を登録し、依存解決や再描画を効率化\r\n * - フィルタ適用にも対応\r\n *\r\n * 設計ポイント:\r\n * - pattern（例: \"$1\"）からインデックス番号を抽出し、ループコンテキストから該当インデックスを取得\r\n * - initでループコンテキストやlistIndexRefを初期化し、バインディング情報をエンジンに登録\r\n * - assignValueは未実装（インデックスは書き換え不可のため）\r\n * - createBindingStateIndexファクトリでフィルタ適用済みインスタンスを生成\r\n */\r\nclass BindingStateIndex implements IBindingState {\r\n  #binding     : IBinding;\r\n  #indexNumber : number;\r\n  #filters     : Filters;\r\n  #ref         : IStatePropertyRef | null = null;\r\n  get pattern(): string {\r\n    return raiseError(\"Not implemented\");\r\n  }\r\n  get info() {\r\n    return raiseError(\"Not implemented\");\r\n  }\r\n  get listIndex() {\r\n    return this.ref.listIndex;\r\n  }\r\n  get ref() {\r\n    return this.#ref ?? raiseError(\"ref is null\");\r\n  }\r\n  get filters() {\r\n    return this.#filters;\r\n  }\r\n  get binding() {\r\n    return this.#binding;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this.#binding = binding;\r\n    const indexNumber = Number(pattern.slice(1));\r\n    if (isNaN(indexNumber)) {\r\n      raiseError(\"BindingStateIndex: pattern is not a number\");\r\n    }\r\n    this.#indexNumber = indexNumber;\r\n    this.#filters = filters;\r\n  }\r\n  getValue(state: IReadonlyStateProxy | IWritableStateProxy) {\r\n    return this.listIndex?.index ?? raiseError(\"listIndex is null\");\r\n  }\r\n  getFilteredValue(state: IReadonlyStateProxy | IWritableStateProxy) {\r\n    let value = this.listIndex?.index ?? raiseError(\"listIndex is null\");\r\n    for(let i = 0; i < this.#filters.length; i++) {\r\n      value = this.#filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  init(): void {\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext ??\r\n      raiseError(`BindingState.init: loopContext is null`);\r\n    const loopContexts = loopContext.serialize();\r\n    const currentLoopContext = loopContexts[this.#indexNumber - 1] ??\r\n      raiseError(`BindingState.init: currentLoopContext is null`);\r\n    this.#ref = currentLoopContext.ref;\r\n    const bindings = this.binding.engine.bindingsByListIndex.get(currentLoopContext.listIndex);\r\n    if (bindings === undefined) {\r\n      this.binding.engine.bindingsByListIndex.set(currentLoopContext.listIndex, new Set([this.binding]));\r\n    } else {\r\n      bindings.add(this.binding);\r\n    }\r\n  }\r\n  assignValue(writeState:IWritableStateProxy, value:any): void {\r\n    raiseError(\"BindingStateIndex: assignValue is not implemented\");\r\n  }\r\n}\r\n\r\nexport const createBindingStateIndex: CreateBindingStateFn = \r\n(name: string, filterTexts: IFilterText[]) => \r\n  (binding:IBinding, filters:FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts); // ToDo:ここは、メモ化できる\r\n\r\n    return new BindingStateIndex(binding, name, filterFns);\r\n  }\r\n","import { createBindingState } from \"../DataBinding/BindingState/BindingState.js\";\r\nimport { createBindingStateIndex } from \"../DataBinding/BindingState/BindingStateIndex.js\";\r\nimport { CreateBindingStateByStateFn } from \"../DataBinding/BindingState/types\";\r\nimport { IFilterText } from \"./types\";\r\n\r\nconst ereg = new RegExp(/^\\$\\d+$/);\r\n\r\n/**\r\n * バインディング対象の状態プロパティ名とフィルタ情報から、\r\n * 適切なバインディング状態生成関数（CreateBindingStateByStateFn）を返すユーティリティ。\r\n *\r\n * - プロパティ名が \"$数字\"（例: \"$1\"）の場合は createBindingStateIndex を使用（インデックスバインディング用）\r\n * - それ以外は通常の createBindingState を使用\r\n *\r\n * @param name        バインディング対象の状態プロパティ名\r\n * @param filterTexts フィルタ情報\r\n * @returns           バインディング状態生成関数\r\n */\r\nexport function getBindingStateCreator(\r\n  name       : string, \r\n  filterTexts: IFilterText[]\r\n): CreateBindingStateByStateFn {\r\n  if (ereg.test(name)) {\r\n    // \"$数字\"形式の場合はインデックスバインディング用の生成関数を返す\r\n    return createBindingStateIndex(name, filterTexts);\r\n  } else {\r\n    // 通常のプロパティ名の場合は標準の生成関数を返す\r\n    return createBindingState(name, filterTexts);\r\n  }\r\n}","import { raiseError } from \"../utils.js\";\r\nimport { NodeType } from \"./types\";\r\n\r\nconst createNodeKey = (node:Node):string => node.constructor.name + \"\\t\" + ((node instanceof Comment) ? (node.textContent?.[2] ?? \"\") : \"\");\r\n\r\ntype NodeTypeByNodeKey = {\r\n  [nodeKey:string]:NodeType;\r\n};\r\n\r\nconst nodeTypeByNodeKey:NodeTypeByNodeKey = {};\r\n\r\nconst getNodeTypeByNode = (node:Node):NodeType =>\r\n  (node instanceof Comment && node.textContent?.[2] === \":\") ? \"Text\" : \r\n  (node instanceof HTMLElement) ? \"HTMLElement\" :\r\n  (node instanceof Comment && node.textContent?.[2] === \"|\") ? \"Template\" : \r\n  (node instanceof SVGElement) ? \"SVGElement\" : raiseError(`Unknown NodeType: ${node.nodeType}`);\r\n\r\n/**\r\n * ノードのタイプ（\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\"）を判定・キャッシュするユーティリティ関数。\r\n *\r\n * - コメントノードの場合、3文字目が \":\" なら \"Text\"、\"|\" なら \"Template\" と判定\r\n * - HTMLElement, SVGElement もそれぞれ判定\r\n * - 未知のノード型はエラー\r\n * - ノードごとに一意なキー（constructor名＋コメント種別）でキャッシュし、再判定を省略\r\n *\r\n * @param node    判定対象のノード\r\n * @param nodeKey キャッシュ用のノードキー（省略時は自動生成）\r\n * @returns       ノードタイプ（NodeType）\r\n */\r\nexport function getNodeType(\r\n  node   : Node, \r\n  nodeKey: string = createNodeKey(node)\r\n): NodeType {\r\n  return nodeTypeByNodeKey[nodeKey] ?? (nodeTypeByNodeKey[nodeKey] = getNodeTypeByNode(node));\r\n}\r\n","import { IFilterText, IBindText } from \"./types\";\r\n\r\nconst trim = (s:string):string => s.trim();\r\n\r\nconst has = (s:string):boolean => s.length > 0; // check length\r\n\r\nconst re = new RegExp(/^#(.*)#$/);\r\nconst decode = (s:string):string => {\r\n  const m = re.exec(s);\r\n  return m ? decodeURIComponent(m[1]) : s;\r\n};\r\n\r\n/**\r\n * parse filter part\r\n * \"eq,100|falsey\" ---> [Filter(eq, [100]), Filter(falsey)]\r\n */\r\nconst parseFilter = (text:string): IFilterText => {\r\n  const [name, ...options] = text.split(\",\").map(trim);\r\n  return {name, options:options.map(decode)};\r\n};\r\n\r\ntype ReturnParseStateProperty = {property:string,filters:IFilterText[]};\r\n/**\r\n * parse expression\r\n * \"value|eq,100|falsey\" ---> [\"value\", Filter[]]\r\n */\r\nconst parseProperty = (text:string): ReturnParseStateProperty => {\r\n  const [property, ...filterTexts] = text.split(\"|\").map(trim);\r\n  return {property, filters:filterTexts.map(parseFilter)};\r\n};\r\n\r\n/**\r\n * parse expressions\r\n * \"textContent:value|eq,100|falsey\" ---> [\"textContent\", \"value\", Filter[eq, falsey]]\r\n */\r\nconst parseExpression = (expression:string): IBindText => {\r\n  const [ bindExpression, decoratesExpression = null ] = expression.split(\"@\").map(trim);\r\n  const decorates = decoratesExpression ? decoratesExpression.split(\",\").map(trim) : [];\r\n  const [nodePropertyText, statePropertyText] = bindExpression.split(\":\").map(trim);\r\n  const { property:nodeProperty, filters:inputFilterTexts } = parseProperty(nodePropertyText);\r\n  const { property:stateProperty, filters:outputFilterTexts } = parseProperty(statePropertyText);\r\n  return { nodeProperty, stateProperty, inputFilterTexts, outputFilterTexts, decorates };\r\n};\r\n\r\n/**\r\n * parse bind text and return BindText[]\r\n */\r\nconst parseExpressions = (text:string): IBindText[] => {\r\n  return text.split(\";\").map(trim).filter(has).map(s => parseExpression(s));\r\n};\r\n\r\nconst cache:{[key:string]: IBindText[]} = {};\r\n\r\n/**\r\n * バインドテキスト（data-bind属性やコメント等から取得した文字列）を解析し、\r\n * バインディング情報（IBindText[]）に変換するユーティリティ関数群。\r\n *\r\n * - フィルターやデコレータ、プロパティ名などをパースし、構造化データとして返す\r\n * - \"textContent:value|eq,100|falsey@decorate1,decorate2\" のような複雑な記法にも対応\r\n * - セミコロン区切りで複数バインドもサポート\r\n * - パース結果はキャッシュし、同じ入力の再解析を防止\r\n *\r\n * @param text バインドテキスト\r\n * @returns    解析済みバインディング情報（IBindText[]）\r\n */\r\nexport function parseBindText(\r\n  text: string\r\n): IBindText[] {\r\n  if (text.trim() === \"\") {\r\n    return [];\r\n  }\r\n  return cache[text] ?? (cache[text] = parseExpressions(text));\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\nconst DATASET_BIND_PROPERTY = 'data-bind';\r\n\r\nconst removeAttributeFromElement = (node:Node):void => {\r\n  const element = node as Element;\r\n  element.removeAttribute(DATASET_BIND_PROPERTY);\r\n}\r\n\r\ntype RemoveAttributeByNodeType = {\r\n  [key in NodeType]: ((node:Node)=>void) | undefined;\r\n}\r\n\r\nconst removeAttributeByNodeType:RemoveAttributeByNodeType = {\r\n  HTMLElement: removeAttributeFromElement,\r\n  SVGElement : removeAttributeFromElement,\r\n  Text       : undefined,\r\n  Template   : undefined,\r\n}\r\n\r\n/**\r\n * 指定ノードから data-bind 属性を削除するユーティリティ関数。\r\n *\r\n * - ノードタイプ（HTMLElement, SVGElement）の場合のみ data-bind 属性を削除\r\n * - Text, Template ノードは対象外\r\n *\r\n * @param node     対象ノード\r\n * @param nodeType ノードタイプ（\"HTMLElement\" | \"SVGElement\" | \"Text\" | \"Template\"）\r\n * @returns        なし\r\n */\r\nexport function removeDataBindAttribute(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n):void {\r\n  return removeAttributeByNodeType[nodeType]?.(node);\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\nconst replaceTextNodeText = (node:Node):Node => {\r\n  const textNode = document.createTextNode(\"\");\r\n  node.parentNode?.replaceChild(textNode, node);\r\n  return textNode;\r\n}\r\n\r\ntype ReplaceTextNodeFn = {\r\n  [key in NodeType]: ((node:Node)=>Node) | undefined;\r\n}\r\n\r\nconst replaceTextNodeFn:ReplaceTextNodeFn = {\r\n  Text       : replaceTextNodeText,\r\n  HTMLElement: undefined,\r\n  Template   : undefined,\r\n  SVGElement : undefined\r\n}\r\n\r\n/**\r\n * コメントノードをテキストノードに置き換えるユーティリティ関数。\r\n *\r\n * - ノードタイプが \"Text\" の場合のみ、コメントノードを空のテキストノードに置換する\r\n * - それ以外のノードタイプ（HTMLElement, Template, SVGElement）は何もしない\r\n *\r\n * @param node     対象ノード\r\n * @param nodeType ノードタイプ（\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\"）\r\n * @returns        置換後のノード（または元のノード）\r\n */\r\nexport function replaceTextNodeFromComment(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n): Node {\r\n  return replaceTextNodeFn[nodeType]?.(node) ?? node;\r\n}\r\n","import { getAbsoluteNodePath } from \"./getAbsoluteNodePath.js\";\r\nimport { getBindingNodeCreator } from \"./getBindingNodeCreator.js\";\r\nimport { getBindingStateCreator } from \"./getBindingStateCreator.js\";\r\nimport { getDataBindText } from \"./getDataBindText.js\";\r\nimport { getNodeType } from \"./getNodeType.js\";\r\nimport { parseBindText } from \"./parseBindText.js\";\r\nimport { removeDataBindAttribute } from \"./removeDataBindAttribute.js\";\r\nimport { replaceTextNodeFromComment } from \"./replaceTextNodeFromComment.js\";\r\nimport { IBindingCreator, IBindText, IDataBindAttributes, NodePath, NodeType } from \"./types\";\r\n\r\n/**\r\n * DataBindAttributesクラスは、DOMノードからバインディング情報を抽出・解析し、\r\n * バインディング生成に必要な情報（ノード種別・パス・バインドテキスト・クリエイター）を管理します。\r\n *\r\n * - ノード種別やパスを特定\r\n * - data-bind属性やコメントノードからバインドテキストを取得・解析\r\n * - バインドテキストごとにバインディング生成関数（ノード用・状態用）を用意\r\n * - data-bind属性やコメントノードはパース後に削除・置換\r\n *\r\n * これにより、テンプレート内のバインディング定義を一元的に管理し、後続のバインディング構築処理を効率化します。\r\n */\r\nclass DataBindAttributes implements IDataBindAttributes {\r\n  nodeType     : NodeType; // ノードの種別\r\n  nodePath     : NodePath; // ノードのルート\r\n  bindTexts    : IBindText[]; // BINDテキストの解析結果\r\n  creatorByText: Map<IBindText, IBindingCreator> = new Map(); // BINDテキストからバインディングクリエイターを取得\r\n  constructor(node: Node) {\r\n    this.nodeType = getNodeType(node);\r\n    const text = getDataBindText(this.nodeType, node);\r\n\r\n    // コメントノードの場合はTextノードに置換（template.contentが書き換わる点に注意）\r\n    node = replaceTextNodeFromComment(node, this.nodeType);\r\n\r\n    // data-bind属性を削除（パース後は不要なため）\r\n    removeDataBindAttribute(node, this.nodeType);\r\n\r\n    this.nodePath = getAbsoluteNodePath(node);\r\n    this.bindTexts = parseBindText(text);\r\n\r\n    // 各バインドテキストごとにバインディング生成関数を用意\r\n    for(let i = 0; i < this.bindTexts.length; i++) {\r\n      const bindText = this.bindTexts[i];\r\n      const creator: IBindingCreator = {\r\n        createBindingNode : getBindingNodeCreator(\r\n          node, \r\n          bindText.nodeProperty, \r\n          bindText.inputFilterTexts,\r\n          bindText.decorates\r\n        ),\r\n        createBindingState: getBindingStateCreator(\r\n          bindText.stateProperty, \r\n          bindText.outputFilterTexts\r\n        ),\r\n      }\r\n      this.creatorByText.set(bindText, creator);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * 指定ノードからDataBindAttributesインスタンスを生成するファクトリ関数。\r\n */\r\nexport function createDataBindAttributes(node: Node): IDataBindAttributes {\r\n  return new DataBindAttributes(node);\r\n}","import { COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants.js\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { NodeType } from \"./types\";\r\n\r\nconst COMMENT_EMBED_MARK_LEN = COMMENT_EMBED_MARK.length;\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\n/**\r\n * ノード種別ごとにdata-bindテキスト（バインディング定義文字列）を取得するユーティリティ関数。\r\n *\r\n * - Textノード: コメントマーク以降のテキストを取得し、\"textContent:\"を付与\r\n * - HTMLElement: data-bind属性値を取得\r\n * - Templateノード: コメントマーク以降のIDからテンプレートを取得し、そのdata-bind属性値を取得\r\n * - SVGElement: data-bind属性値を取得\r\n *\r\n * @param nodeType ノード種別（\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\"）\r\n * @param node     対象ノード\r\n * @returns        バインディング定義文字列\r\n */\r\nexport function getDataBindText(nodeType: NodeType, node: Node): string {\r\n  switch (nodeType) {\r\n    case \"Text\": {\r\n      const text = node.textContent?.slice(COMMENT_EMBED_MARK_LEN).trim() ?? \"\";\r\n      return \"textContent:\" + text;\r\n    }\r\n    case \"HTMLElement\": {\r\n      return (node as HTMLElement).getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    case \"Template\": {\r\n      const text = node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN).trim();\r\n      const id = Number(text);\r\n      const template = getTemplateById(id) ?? raiseError(`Template not found: ${text}`);\r\n      return template.getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    case \"SVGElement\": {\r\n      return (node as SVGElement).getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    default:\r\n      return \"\";\r\n  }\r\n}","import { NodePath } from \"./types\";\r\n\r\n/**\r\n * 指定ノードの「親からのインデックス」をルートまで辿り、絶対パス（NodePath）として返すユーティリティ関数。\r\n *\r\n * 例: ルートから見て [0, 2, 1] のような配列を返す。\r\n *     これは「親→子→孫…」とたどったときの各階層でのインデックスを表す。\r\n *\r\n * @param node 対象のDOMノード\r\n * @returns    ルートからこのノードまでのインデックス配列（NodePath）\r\n */\r\nexport function getAbsoluteNodePath(node: Node): NodePath {\r\n  let routeIndexes: NodePath = [];\r\n  while(node.parentNode !== null) {\r\n    const childNodes = Array.from(node.parentNode.childNodes) as Node[];\r\n    routeIndexes = [ childNodes.indexOf(node), ...routeIndexes ];\r\n    node = node.parentNode;\r\n  }\r\n  return routeIndexes;\r\n}","import { DATA_BIND_ATTRIBUTE, COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK } from \"../constants.js\";\r\n\r\n/**\r\n * \"@@:\"もしくは\"@@|\"で始まるコメントノードを取得する\r\n */\r\nfunction isCommentNode(node: Node): boolean {\r\n  return node instanceof Comment && (\r\n    (node.textContent?.indexOf(COMMENT_EMBED_MARK) === 0) || (node.textContent?.indexOf(COMMENT_TEMPLATE_MARK) === 0)\r\n  );\r\n} \r\n\r\n/**\r\n * 指定ノード以下のツリーから「data-bind属性を持つ要素」または\r\n * 「特定のマーク（@@: または @@|）で始まるコメントノード」をすべて取得するユーティリティ関数。\r\n *\r\n * - Elementノードの場合: data-bind属性があるものだけを抽出\r\n * - Commentノードの場合: COMMENT_EMBED_MARK または COMMENT_TEMPLATE_MARK で始まるものだけを抽出\r\n * - DOMツリー全体をTreeWalkerで効率的に走査\r\n *\r\n * @param root 探索の起点となるノード\r\n * @returns    条件に合致したノードの配列\r\n */\r\nexport function getNodesHavingDataBind(root: Node): Node[] {\r\n  const nodes: Node[] = [];\r\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, {\r\n    acceptNode(node:Node) {\r\n      return (node instanceof Element) ? \r\n        (node.hasAttribute(DATA_BIND_ATTRIBUTE) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP)\r\n        : (isCommentNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\r\n    }\r\n  });\r\n  while (walker.nextNode()) {\r\n    nodes.push(walker.currentNode);\r\n  }\r\n  return nodes;\r\n}\r\n\r\n","import { createDataBindAttributes } from \"./createDataBindAttributes.js\";\r\nimport { getNodesHavingDataBind } from \"./getNodesHavingDataBind.js\";\r\nimport { IDataBindAttributes } from \"./types\";\r\n\r\nconst listDataBindAttributesById: {[key:number]:IDataBindAttributes[]} = {};\r\n\r\nconst listPathsSetById: {[key:number]:Set<string>} = {};\r\n\r\nconst pathsSetById: {[key:number]:Set<string>} = {};\r\n\r\nfunction getDataBindAttributesFromTemplate(content: DocumentFragment): IDataBindAttributes[] {\r\n  const nodes = getNodesHavingDataBind(content);\r\n  return nodes.map(node => createDataBindAttributes(node));\r\n}\r\n\r\n/**\r\n * テンプレート（DocumentFragment）内のバインディング情報（data-bind属性やコメント）を解析・登録し、\r\n * 各テンプレートIDごとにバインディング属性情報・状態パス集合を管理するユーティリティ。\r\n *\r\n * - getNodesHavingDataBindで対象ノードを抽出し、createDataBindAttributesで解析\r\n * - 各テンプレートIDごとにバインディング属性リスト・状態パス集合・リストパス集合をキャッシュ\r\n * - forバインディング（ループ）のstatePropertyはlistPathsにも登録\r\n *\r\n * @param id      テンプレートID\r\n * @param content テンプレートのDocumentFragment\r\n * @param rootId  ルートテンプレートID（省略時はidと同じ）\r\n * @returns       解析済みバインディング属性リスト\r\n */\r\nexport function registerDataBindAttributes(\r\n  id     : number, \r\n  content: DocumentFragment,\r\n  rootId : number = id\r\n): IDataBindAttributes[] {\r\n  const dataBindAttributes = getDataBindAttributesFromTemplate(content);\r\n  const paths = pathsSetById[rootId] ?? (pathsSetById[rootId] = new Set<string>());\r\n  const listPaths = listPathsSetById[rootId] ?? (listPathsSetById[rootId] = new Set<string>());\r\n  for(let i = 0; i < dataBindAttributes.length; i++) {\r\n    const attribute = dataBindAttributes[i];\r\n    for(let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      paths.add(bindText.stateProperty);\r\n      if (bindText.nodeProperty === \"for\") {\r\n        listPaths.add(bindText.stateProperty);\r\n      }\r\n    }\r\n  }\r\n  return listDataBindAttributesById[id] = dataBindAttributes;\r\n}\r\n\r\n/**\r\n * テンプレートIDからバインディング属性リストを取得\r\n */\r\nexport const getDataBindAttributesById = (id: number): IDataBindAttributes[] => {\r\n  return listDataBindAttributesById[id];\r\n}\r\n\r\n/**\r\n * テンプレートIDからforバインディングのstateProperty集合を取得\r\n */\r\nexport const getListPathsSetById = (id: number): Set<string> => {\r\n  return listPathsSetById[id] ?? [];\r\n};\r\n\r\n/**\r\n * テンプレートIDから全バインディングのstateProperty集合を取得\r\n */\r\nexport const getPathsSetById = (id: number): Set<string> => {\r\n  return pathsSetById[id] ?? [];\r\n};","/**\r\n * registerTemplate.ts\r\n *\r\n * HTMLTemplateElementをIDで登録・取得するための管理モジュールです。\r\n *\r\n * 主な役割:\r\n * - templateById: IDをキーにHTMLTemplateElementを管理するレコード\r\n * - registerTemplate: 指定IDでテンプレートを登録し、空テキストノード除去やデータバインド属性の登録も実行\r\n * - getTemplateById: 指定IDのテンプレートを取得（未登録時はエラーを投げる）\r\n *\r\n * 設計ポイント:\r\n * - テンプレート登録時にremoveEmptyTextNodesで空テキストノードを除去し、クリーンなDOMを維持\r\n * - registerDataBindAttributesでデータバインド属性を自動付与\r\n * - グローバルにテンプレートを一元管理し、ID経由で高速にアクセス可能\r\n * - 存在しないIDアクセス時はraiseErrorで明確な例外を発生\r\n */\r\nimport { registerDataBindAttributes } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { removeEmptyTextNodes } from \"./removeEmptyTextNodes.js\";\r\n\r\nconst templateById:Record<number, HTMLTemplateElement> = {};\r\n\r\nexport function registerTemplate(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number\r\n): number {\r\n  removeEmptyTextNodes(template.content);\r\n  registerDataBindAttributes(id, template.content, rootId);  \r\n  templateById[id] = template;\r\n  return id;\r\n}\r\n\r\nexport function getTemplateById(id: number): HTMLTemplateElement {\r\n  return templateById[id] ?? raiseError(`getTemplateById: template not found: ${id}`);\r\n}","/**\r\n * removeEmptyTextNodes.ts\r\n *\r\n * DocumentFragment内の空テキストノードを削除するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - content（DocumentFragment）の直下にある空白のみのテキストノードを検出し、削除する\r\n *\r\n * 設計ポイント:\r\n * - childNodesをArray.fromで配列化し、forEachで全ノードを走査\r\n * - nodeTypeがTEXT_NODEかつ、nodeValueが空白のみの場合にremoveChildで削除\r\n * - テンプレート処理やクリーンなDOM生成時に利用\r\n */\r\nexport function removeEmptyTextNodes(content:DocumentFragment):void {\r\n  Array.from(content.childNodes).forEach(node => {\r\n    if (node.nodeType === Node.TEXT_NODE && !(node.nodeValue ?? \"\").trim()) {\r\n      content.removeChild(node);\r\n    }\r\n  });  \r\n}\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IReadonlyStateProxy, IWritableStateProxy } from \"../StateClass/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { IRenderer } from \"../Updater/types\";\r\nimport { CreateBindingNodeByNodeFn, IBindingNode } from \"./BindingNode/types\";\r\nimport { CreateBindingStateByStateFn, IBindingState } from \"./BindingState/types\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\n\r\n/**\r\n * Bindingクラスは、1つのバインディング（ノードと状態の対応）を管理する中核的な実装です。\r\n *\r\n * 主な役割:\r\n * - DOMノードと状態（State）を結びつけるバインディングノード（bindingNode）とバインディング状態（bindingState）の生成・管理\r\n * - バインディングの初期化（init）、再描画（render）、状態値の更新（updateStateValue）などの処理を提供\r\n * - バージョン管理により、不要な再描画を防止\r\n *\r\n * 設計ポイント:\r\n * - createBindingNode, createBindingStateファクトリで柔軟なバインディング構造に対応\r\n * - renderでバージョン差分がある場合のみバインディングノードを更新\r\n * - 双方向バインディング時はupdateStateValueで状態プロキシに値を反映\r\n * - createBinding関数で一貫したバインディング生成を提供\r\n */\r\nclass Binding implements IBinding {\r\n  parentBindContent: IBindContent;\r\n  node             : Node;\r\n  engine           : IComponentEngine;\r\n  bindingNode      : IBindingNode;\r\n  bindingState     : IBindingState;\r\n  version          : number | undefined;\r\n  constructor(\r\n    parentBindContent : IBindContent,\r\n    node              : Node,\r\n    engine            : IComponentEngine,\r\n    createBindingNode : CreateBindingNodeByNodeFn, \r\n    createBindingState: CreateBindingStateByStateFn,\r\n  ) {\r\n    this.parentBindContent = parentBindContent\r\n    this.node = node;\r\n    this.engine = engine\r\n    this.bindingNode = createBindingNode(this, node, engine.inputFilters);\r\n    this.bindingState = createBindingState(this, engine.outputFilters);\r\n  }\r\n\r\n  get bindContents(): IBindContent[] {\r\n    return this.bindingNode.bindContents;\r\n  }\r\n\r\n  init() {\r\n    this.bindingNode.init();\r\n    this.bindingState.init();\r\n  }\r\n\r\n  updateStateValue(writeState:IWritableStateProxy, value: any) {\r\n    return this.bindingState.assignValue(writeState, value);\r\n  }\r\n\r\n  notifyRedraw(refs: IStatePropertyRef[]) {\r\n    this.bindingNode.notifyRedraw(refs);\r\n  }\r\n\r\n  applyChange(renderer: IRenderer): void {\r\n    if (renderer.updatedBindings.has(this)) return;\r\n    this.bindingNode.applyChange(renderer);\r\n  }\r\n}\r\n\r\n/**\r\n * バインディング生成用ファクトリ関数\r\n * - 各種ファクトリ・エンジン・ノード情報からBindingインスタンスを生成\r\n */\r\nexport function createBinding(\r\n  parentBindContent : IBindContent,\r\n  node              : Node, \r\n  engine            : IComponentEngine, \r\n  createBindingNode : CreateBindingNodeByNodeFn, \r\n  createBindingState: CreateBindingStateByStateFn\r\n): IBinding {\r\n  return new Binding(\r\n    parentBindContent, \r\n    node, \r\n    engine, \r\n    createBindingNode, \r\n    createBindingState\r\n  );\r\n}","/**\r\n * createLoopContext.ts\r\n *\r\n * ループバインディング（for等）で利用するLoopContext（ループコンテキスト）管理クラスとファクトリ関数の実装です。\r\n *\r\n * 主な役割:\r\n * - ループごとのプロパティパス・インデックス・BindContentを紐付けて管理\r\n * - 親ループコンテキストの探索やキャッシュ、インデックスの再割り当て・クリアなどを提供\r\n * - ループ階層をたどるwalk/serializeや、名前でのfind検索も可能\r\n *\r\n * 設計ポイント:\r\n * - WeakRefでlistIndexを保持し、GCフレンドリーな設計\r\n * - parentLoopContextで親ループを遅延探索・キャッシュし、効率的な親子関係管理を実現\r\n * - findで名前からループコンテキストを高速検索（キャッシュ付き）\r\n * - walk/serializeでループ階層をたどる処理を簡潔に記述可能\r\n * - createLoopContextファクトリで一貫した生成・管理が可能\r\n */\r\nimport { IBindContent } from \"../DataBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { ILoopContext } from \"./types\";\r\n\r\nclass LoopContext implements ILoopContext {\r\n  #ref: IStatePropertyRef | null;\r\n  #info: IStructuredPathInfo;\r\n  #bindContent : IBindContent;\r\n  constructor(\r\n    ref: IStatePropertyRef,\r\n    bindContent: IBindContent\r\n  ) {\r\n    this.#ref = ref;\r\n    this.#info = ref.info;\r\n    this.#bindContent = bindContent;\r\n  }\r\n  get ref(): IStatePropertyRef {\r\n    return this.#ref ?? raiseError(\"ref is null\");\r\n  }\r\n  get path(): string {\r\n    return this.ref.info.pattern ?? raiseError(\"info.pattern is null\");\r\n  }\r\n  get info(): IStructuredPathInfo {\r\n    return this.ref.info ?? raiseError(\"info is null\");\r\n  }\r\n  get listIndex(): IListIndex {\r\n    return this.ref.listIndex ?? raiseError(\"listIndex is required\");\r\n  }\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    this.#ref = getStatePropertyRef(this.#info, listIndex);\r\n    // 構造は変わらないので、#parentLoopContext、#cacheはクリアする必要はない\r\n  }\r\n  clearListIndex():void {\r\n    this.#ref = null;\r\n  }\r\n  get bindContent(): IBindContent {\r\n    return this.#bindContent;\r\n  }\r\n\r\n  #parentLoopContext: ILoopContext | null | undefined;\r\n  get parentLoopContext(): ILoopContext | null {\r\n    if (typeof this.#parentLoopContext === \"undefined\") {\r\n      let currentBindContent: IBindContent | null = this.bindContent;\r\n      while(currentBindContent !== null) {\r\n        if (currentBindContent.loopContext !== null && currentBindContent.loopContext !== this) {\r\n          this.#parentLoopContext = currentBindContent.loopContext;\r\n          break;\r\n        }\r\n        currentBindContent = currentBindContent.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      if (typeof this.#parentLoopContext === \"undefined\") this.#parentLoopContext = null;\r\n    }\r\n    return this.#parentLoopContext;\r\n  }\r\n\r\n  #cache:Record<string, ILoopContext | null> = {};\r\n  find(name: string): ILoopContext | null {\r\n    let loopContext = this.#cache[name];\r\n    if (typeof loopContext === \"undefined\") {\r\n      let currentLoopContext: ILoopContext | null = this;\r\n      while(currentLoopContext !== null) {\r\n        if (currentLoopContext.path === name) break;\r\n        currentLoopContext = currentLoopContext.parentLoopContext;\r\n      }\r\n      loopContext = this.#cache[name] = currentLoopContext;\r\n    }\r\n    return loopContext;\r\n  }\r\n\r\n  walk(callback: (loopContext: ILoopContext) => void): void {\r\n    let currentLoopContext: ILoopContext | null = this;\r\n    while(currentLoopContext !== null) {\r\n      callback(currentLoopContext);\r\n      currentLoopContext = currentLoopContext.parentLoopContext;\r\n    }\r\n  }\r\n\r\n  serialize(): ILoopContext[] {\r\n    const results: ILoopContext[] = [];\r\n    this.walk((loopContext) => {\r\n      results.unshift(loopContext);\r\n    });\r\n    return results;\r\n  }\r\n\r\n}\r\n\r\n// 生成されたあと、IBindContentのloopContextに登録される\r\n// IBindContentにずっと保持される\r\nexport function createLoopContext(\r\n  ref: IStatePropertyRef,\r\n  bindContent: IBindContent\r\n): ILoopContext {\r\n  return new LoopContext(ref, bindContent);\r\n}","import { resolveNodeFromPath } from \"../BindingBuilder/resolveNodeFromPath.js\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { createBinding } from \"./Binding.js\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\nimport { createLoopContext } from \"../LoopContext/createLoopContext.js\";\r\nimport { getDataBindAttributesById } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { hasLazyLoadComponents, loadLazyLoadComponent } from \"../WebComponents/loadFromImportMap.js\";\r\nimport { IListIndex } from \"../ListIndex/types.js\";\r\nimport { IRenderer } from \"../Updater/types.js\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types.js\";\r\n\r\nfunction createContent(id: number): DocumentFragment {\r\n  const template = getTemplateById(id) ?? \r\n    raiseError(`BindContent: template is not found: ${id}`);\r\n  const fragment = document.importNode(template.content, true);\r\n  if (hasLazyLoadComponents()) {\r\n    const lazyLoadElements = fragment.querySelectorAll(\":not(:defined)\");\r\n    for(let i = 0; i < lazyLoadElements.length; i++) {\r\n      const tagName = lazyLoadElements[i].tagName.toLowerCase();\r\n      loadLazyLoadComponent(tagName);\r\n    }\r\n  }\r\n  return fragment;\r\n}\r\n\r\nfunction createBindings(\r\n  bindContent: IBindContent, \r\n  id         : number, \r\n  engine     : IComponentEngine, \r\n  content    : DocumentFragment\r\n): IBinding[] {\r\n  const attributes = getDataBindAttributesById(id) ?? \r\n    raiseError(`BindContent: data-bind is not set`);\r\n  const bindings: IBinding[] = [];\r\n  for(let i = 0; i < attributes.length; i++) {\r\n    const attribute = attributes[i];\r\n    const node = resolveNodeFromPath(content, attribute.nodePath) ?? \r\n      raiseError(`BindContent: node is not found: ${attribute.nodePath}`);\r\n    for(let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      const creator = attribute.creatorByText.get(bindText) ?? \r\n        raiseError(`BindContent: creator is not found: ${bindText}`);\r\n      const binding = createBinding(\r\n        bindContent, \r\n        node, \r\n        engine, \r\n        creator.createBindingNode, \r\n        creator.createBindingState\r\n      );\r\n      bindings.push(binding);\r\n    }\r\n  }\r\n  return bindings;\r\n}\r\n\r\n/**\r\n * BindContentクラスは、テンプレートから生成されたDOM断片（DocumentFragment）と\r\n * そのバインディング情報（IBinding配列）を管理するための実装です。\r\n *\r\n * 主な役割:\r\n * - テンプレートIDからDOM断片を生成し、バインディング情報を構築\r\n * - mount/mountBefore/mountAfter/unmountでDOMへの挿入・削除を制御\r\n * - renderでバインディングの再描画、initで初期化処理を実行\r\n * - ループバインディング時のLoopContextやリストインデックス管理にも対応\r\n * - getLastNodeで再帰的に最後のノードを取得し、リスト描画や差し替えに利用\r\n * - assignListIndexでループ内のリストインデックスを再割り当てし、再初期化\r\n *\r\n * 設計ポイント:\r\n * - fragmentとchildNodesの両方を管理し、効率的なDOM操作を実現\r\n * - バインディング情報はテンプレートごとに動的に生成され、各ノードに紐付く\r\n * - ループや条件分岐など複雑なバインディング構造にも柔軟に対応\r\n * - createBindContentファクトリ関数で一貫した生成・初期化を提供\r\n */\r\nclass BindContent implements IBindContent {\r\n  loopContext  : ILoopContext | null;\r\n  parentBinding: IBinding | null;\r\n  childNodes   : Node[];\r\n  fragment     : DocumentFragment;\r\n  engine       : IComponentEngine | undefined;\r\n  #id;\r\n  get id() {\r\n    return this.#id;\r\n  }\r\n  get isMounted() {\r\n    return this.childNodes.length > 0 && this.childNodes[0].parentNode !== this.fragment;\r\n  }\r\n  get firstChildNode() {\r\n    return this.childNodes[0] ?? null;\r\n  }\r\n  get lastChildNode() {\r\n    return this.childNodes[this.childNodes.length - 1] ?? null;\r\n  }\r\n  getLastNode(parentNode: Node): Node | null {\r\n    const lastBinding = this.bindings[this.bindings.length - 1];\r\n    const lastChildNode = this.lastChildNode;\r\n    if (typeof lastBinding !== \"undefined\" && lastBinding.node === lastChildNode) {\r\n      if (lastBinding.bindContents.length > 0) {\r\n        const childBindContent = lastBinding.bindContents.at(-1) ?? raiseError(`BindContent: childBindContent is not found`);\r\n        const lastNode = childBindContent.getLastNode(parentNode);\r\n        if (lastNode !== null) {\r\n          return lastNode;\r\n        }\r\n      }\r\n    }\r\n    if (parentNode !== lastChildNode?.parentNode) {\r\n      return null;\r\n    }\r\n    return lastChildNode;\r\n  }\r\n  #currentLoopContext: ILoopContext | null | undefined;\r\n  get currentLoopContext(): ILoopContext | null {\r\n    if (typeof this.#currentLoopContext === \"undefined\") {\r\n      let bindContent: IBindContent | null = this;\r\n      while(bindContent !== null) {\r\n        if (bindContent.loopContext !== null) break; ;\r\n        bindContent = bindContent.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      this.#currentLoopContext = bindContent?.loopContext ?? null;\r\n    }\r\n    return this.#currentLoopContext;\r\n  }\r\n  constructor(\r\n    parentBinding: IBinding | null,\r\n    id           : number, \r\n    engine       : IComponentEngine, \r\n    loopRef      : IStatePropertyRef,\r\n  ) {\r\n    this.parentBinding = parentBinding;\r\n    this.#id = id;\r\n    this.fragment = createContent(id);\r\n    this.childNodes = Array.from(this.fragment.childNodes);\r\n    this.engine = engine;\r\n    this.loopContext = (loopRef.listIndex !== null) ? createLoopContext(loopRef, this) : null;\r\n    this.bindings = createBindings(\r\n      this, \r\n      id, \r\n      engine, \r\n      this.fragment\r\n    );\r\n  }\r\n  mount(parentNode: Node) {\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentNode.appendChild(this.childNodes[i]);\r\n    }\r\n  }\r\n  mountBefore(parentNode: Node, beforeNode: Node | null) {\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentNode.insertBefore(this.childNodes[i], beforeNode);\r\n    }\r\n  }\r\n  mountAfter(parentNode: Node, afterNode: Node | null) {\r\n    const beforeNode = afterNode?.nextSibling ?? null;\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentNode.insertBefore(this.childNodes[i], beforeNode);\r\n    }\r\n  }\r\n  unmount() {\r\n    const parentElement = this.childNodes[0]?.parentElement ?? null;\r\n    if (parentElement === null) {\r\n      return; // すでにDOMから削除されている場合は何もしない\r\n    }\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentElement.removeChild(this.childNodes[i]);\r\n    }\r\n  }\r\n  bindings: IBinding[] = [];\r\n  init() {\r\n    for(let i = 0; i < this.bindings.length; i++) {\r\n      this.bindings[i].init();\r\n    }\r\n  }\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    if (this.loopContext == null) raiseError(`BindContent: loopContext is null`);\r\n    this.loopContext.assignListIndex(listIndex);\r\n    this.init();\r\n  }\r\n  applyChange(renderer: IRenderer): void {\r\n    for(let i = 0; i < this.bindings.length; i++) {\r\n      const binding = this.bindings[i];\r\n      if (renderer.updatedBindings.has(binding)) continue;\r\n      binding.applyChange(renderer);\r\n    }\r\n  }\r\n}\r\n\r\nexport function createBindContent(\r\n  parentBinding: IBinding | null,\r\n  id           : number, \r\n  engine       :IComponentEngine, \r\n  loopRef      : IStatePropertyRef,\r\n):IBindContent {\r\n  const bindContent = new BindContent(\r\n    parentBinding, \r\n    id, \r\n    engine, \r\n    loopRef,\r\n  );\r\n  bindContent.init();\r\n  return bindContent;\r\n}","/**\r\n * loadFromImportMap.ts\r\n *\r\n * importmapの情報をもとに、Structiveのルートやコンポーネントを動的にロード・登録するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - importmap.imports内のエイリアスを走査し、@routes/や@components/のプレフィックスで判定\r\n * - @routes/の場合はルーティング情報をentryRouteで登録\r\n * - @components/の場合はloadSingleFileComponentでSFCをロードし、createComponentClassでクラス化してregisterComponentClassで登録\r\n *\r\n * 設計ポイント:\r\n * - importmapのエイリアスを利用して、ルーティングやコンポーネントの自動登録を実現\r\n * - パスやタグ名の正規化、パラメータ除去なども自動で処理\r\n * - 非同期でSFCをロードし、動的なWeb Components登録に対応\r\n */\r\nimport { entryRoute } from \"../Router/Router\";\r\nimport { raiseError } from \"../utils\";\r\nimport { createComponentClass } from \"./createComponentClass\";\r\nimport { loadImportmap } from \"./loadImportmap\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent\";\r\nimport { registerComponentClass } from \"./registerComponentClass\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nconst ROUTES_KEY = \"@routes/\";\r\nconst COMPONENTS_KEY = \"@components/\";\r\nconst LAZY_LOAD_SUFFIX = \"#lazy\";\r\nconst LAZY_LOAD_SUFFIX_LEN = LAZY_LOAD_SUFFIX.length;\r\n\r\nconst lazyLoadComponentAliasByTagName: Record<string, string> = {};\r\n\r\nexport async function loadFromImportMap(): Promise<void> {\r\n  const importmap = loadImportmap();\r\n  if (importmap.imports) {\r\n    const loadAliasByTagName: Map<string, string> = new Map();\r\n    for (const [alias, value] of Object.entries(importmap.imports)) {\r\n      let tagName, isLazyLoad;\r\n      if (alias.startsWith(ROUTES_KEY)) {\r\n        isLazyLoad = alias.endsWith(LAZY_LOAD_SUFFIX);\r\n        // remove the prefix '@routes' and the suffix '#lazy' if it exists\r\n        const path = alias.slice(ROUTES_KEY.length - 1, isLazyLoad ? -LAZY_LOAD_SUFFIX_LEN : undefined); \r\n        const pathWithoutParams = path.replace(/:[^\\s/]+/g, \"\"); // remove the params\r\n        tagName = \"routes\" + pathWithoutParams.replace(/\\//g, \"-\"); // replace '/' with '-'\r\n        entryRoute(tagName, path === \"/root\" ? \"/\" : path); // routing\r\n      } if (alias.startsWith(COMPONENTS_KEY)) {\r\n        isLazyLoad = alias.endsWith(LAZY_LOAD_SUFFIX);\r\n        // remove the prefix '@components/' and the suffix '#lazy' if it exists\r\n        tagName = alias.slice(COMPONENTS_KEY.length, isLazyLoad ? -LAZY_LOAD_SUFFIX_LEN : undefined);\r\n      }\r\n      if (!tagName) {\r\n        continue;\r\n      }\r\n      if (isLazyLoad) {\r\n        // Lazy Load用のコンポーネントのエイリアスを格納\r\n        lazyLoadComponentAliasByTagName[tagName] = alias;\r\n        continue; // Lazy Loadの場合はここでスキップ\r\n      }\r\n      loadAliasByTagName.set(tagName, alias);\r\n    }\r\n    for (const [tagName, alias] of loadAliasByTagName.entries()) {\r\n      // 非Lazy Loadのコンポーネントはここで登録\r\n      const componentData = await loadSingleFileComponent(alias);\r\n      const componentClass = createComponentClass(componentData);\r\n      registerComponentClass(tagName, componentClass);\r\n    }\r\n  }\r\n}\r\n\r\nexport function hasLazyLoadComponents(): boolean {\r\n  return Object.keys(lazyLoadComponentAliasByTagName).length > 0;\r\n}\r\n\r\nexport function isLazyLoadComponent(tagName: string): boolean {\r\n  return lazyLoadComponentAliasByTagName.hasOwnProperty(tagName);\r\n}\r\n\r\nexport function loadLazyLoadComponent(tagName: string): void {\r\n  const alias = lazyLoadComponentAliasByTagName[tagName];\r\n  if (!alias) {\r\n    console.warn(`loadLazyLoadComponent: alias not found for tagName: ${tagName}`);\r\n    return;\r\n  }\r\n  delete lazyLoadComponentAliasByTagName[tagName]; // 一度ロードしたら削除\r\n  queueMicrotask(async () => {\r\n    const componentData = await loadSingleFileComponent(alias);\r\n    const componentClass = createComponentClass(componentData);\r\n    registerComponentClass(tagName, componentClass);\r\n  });\r\n}\r\n","import { raiseError } from \"../utils.js\";\r\nimport { IComponentConfig } from \"../WebComponents/types\";\r\nimport { canHaveShadowRoot } from \"./canHaveShadowRoot.js\";\r\n\r\nfunction getParentShadowRoot(parentNode: Node | null): ShadowRoot|undefined{\r\n  let node: Node | null = parentNode;\r\n  while(node) {\r\n    if (node instanceof ShadowRoot) {\r\n      return node;\r\n    }\r\n    node = node.parentNode;\r\n  }\r\n}\r\n\r\n/**\r\n * 指定したHTMLElementにShadow DOMをアタッチし、スタイルシートを適用するユーティリティ関数。\r\n *\r\n * - config.enableShadowDomがtrueの場合は、ShadowRootを生成し、adoptedStyleSheetsでスタイルを適用\r\n * - extends指定がある場合はcanHaveShadowRootで拡張可能かチェック\r\n * - Shadow DOMを使わない場合は、親のShadowRootまたはdocumentにスタイルシートを追加\r\n * - すでに同じスタイルシートが含まれていれば重複追加しない\r\n *\r\n * @param element    対象のHTMLElement\r\n * @param config     コンポーネント設定\r\n * @param styleSheet 適用するCSSStyleSheet\r\n * @throws           Shadow DOM非対応の組み込み要素を拡張しようとした場合はエラー\r\n */\r\nexport function attachShadow(element: HTMLElement, config: IComponentConfig, styleSheet: CSSStyleSheet): void {\r\n    if (config.enableShadowDom) {\r\n      if (config.extends === null || canHaveShadowRoot(config.extends)) {\r\n        if (!element.shadowRoot) {\r\n          const shadowRoot = element.attachShadow({ mode: 'open' });\r\n          shadowRoot.adoptedStyleSheets = [styleSheet];\r\n        }\r\n      } else {\r\n        raiseError(`ComponentEngine: Shadow DOM not supported for builtin components that extend ${config.extends}`);\r\n      }\r\n    } else {\r\n      const shadowRootOrDocument = getParentShadowRoot(element.parentNode) || document;\r\n      const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n      if (!styleSheets.includes(styleSheet)) {\r\n        shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, styleSheet];\r\n      }\r\n    }\r\n\r\n}","/**\r\n * 指定したタグ名の要素がShadowRootを持てるかどうかを判定するユーティリティ関数。\r\n *\r\n * - 指定タグ名で要素を生成し、attachShadowメソッドが存在するかどうかで判定\r\n * - 無効なタグ名やattachShadow未対応の場合はfalseを返す\r\n *\r\n * @param tagName 判定したい要素のタグ名（例: \"div\", \"span\", \"input\" など）\r\n * @returns       ShadowRootを持てる場合はtrue、持てない場合はfalse\r\n */\r\nexport function canHaveShadowRoot(tagName: string): boolean {\r\n  try {\r\n    // 一時的に要素を作成\r\n    const element = document.createElement(tagName);\r\n    // `attachShadow` メソッドが存在し、実行可能かを確認\r\n    if (typeof element.attachShadow !== \"function\") {\r\n      return false;\r\n    }\r\n    // 一時的にShadowRootをアタッチしてみる\r\n    const shadowRoot = element.attachShadow({ mode: 'open' });\r\n    return true;\r\n  } catch {\r\n    // 無効なタグ名などが渡された場合は false を返す\r\n    return false;\r\n  }\r\n}\r\n","import { IBinding } from \"../DataBinding/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { StructiveComponent } from \"../WebComponents/types\";\r\nimport { IComponentStateBinding } from \"./types\";\r\n\r\nclass ComponentStateBinding implements IComponentStateBinding {\r\n  parentPaths: Set<string> = new Set<string>();\r\n  childPaths: Set<string> = new Set<string>();\r\n  childPathByParentPath: Map<string, string> = new Map();\r\n  parentPathByChildPath: Map<string, string> = new Map();\r\n  bindingByParentPath: Map<string, IBinding> = new Map();\r\n  bindingByChildPath: Map<string, IBinding> = new Map();\r\n  bindings: WeakSet<IBinding> = new WeakSet();\r\n\r\n  addBinding(binding: IBinding): void {\r\n    if (this.bindings.has(binding)) {\r\n      return; // 既にバインディングが追加されている場合は何もしない\r\n    }\r\n    const parentPath = binding.bindingState.pattern;\r\n    const childPath = binding.bindingNode.subName;\r\n    if (this.childPathByParentPath.has(parentPath)) {\r\n      throw new Error(`Parent path \"${parentPath}\" already has a child path.`);\r\n    }\r\n    if (this.parentPathByChildPath.has(childPath)) {\r\n      throw new Error(`Child path \"${childPath}\" already has a parent path.`);\r\n    }\r\n    this.childPathByParentPath.set(parentPath, childPath);\r\n    this.parentPathByChildPath.set(childPath, parentPath);\r\n    this.parentPaths.add(parentPath);\r\n    this.childPaths.add(childPath);\r\n    this.bindingByParentPath.set(parentPath, binding);\r\n    this.bindingByChildPath.set(childPath, binding);\r\n    this.bindings.add(binding);\r\n  }\r\n  \r\n  getChildPath(parentPath: string): string | undefined {\r\n    return this.childPathByParentPath.get(parentPath);\r\n  }\r\n\r\n  getParentPath(childPath: string): string | undefined {\r\n    return this.parentPathByChildPath.get(childPath);\r\n  }\r\n\r\n  toParentPathFromChildPath(childPath: string): string {\r\n    const childPathInfo = getStructuredPathInfo(childPath);\r\n    const matchPaths = childPathInfo.cumulativePathSet.intersection(this.childPaths);\r\n    if (matchPaths.size === 0) {\r\n      raiseError(`No parent path found for child path \"${childPath}\".`);\r\n    }\r\n    const matchPathArray = Array.from(matchPaths);\r\n    const longestMatchPath = matchPathArray[matchPathArray.length - 1];\r\n    const remainPath = childPath.slice(longestMatchPath.length); // include the dot\r\n    const matchParentPath = this.parentPathByChildPath.get(longestMatchPath);\r\n    if (typeof matchParentPath === \"undefined\") {\r\n      raiseError(`No parent path found for child path \"${childPath}\".`);\r\n    }\r\n    return matchParentPath + remainPath;\r\n  }\r\n\r\n  toChildPathFromParentPath(parentPath: string): string {\r\n     const parentPathInfo = getStructuredPathInfo(parentPath);\r\n    const matchPaths = parentPathInfo.cumulativePathSet.intersection(this.parentPaths);\r\n    if (matchPaths.size === 0) {\r\n      raiseError(`No child path found for parent path \"${parentPath}\".`);\r\n    }\r\n    const matchPathArray = Array.from(matchPaths);\r\n    const longestMatchPath = matchPathArray[matchPathArray.length - 1];\r\n    const remainPath = parentPath.slice(longestMatchPath.length); // include the dot\r\n    const matchChildPath = this.childPathByParentPath.get(longestMatchPath);\r\n    if (typeof matchChildPath === \"undefined\") {\r\n      raiseError(`No child path found for parent path \"${parentPath}\".`);\r\n    }\r\n    return matchChildPath + remainPath;\r\n  }\r\n\r\n  startsWithByChildPath(childPathInfo: IStructuredPathInfo): string | null {\r\n    if (this.childPaths.size === 0) {\r\n      return null;\r\n    }\r\n    const matchPaths = childPathInfo.cumulativePathSet.intersection(this.childPaths);\r\n    if (matchPaths.size === 0) {\r\n      return null;\r\n    } else {\r\n      const matches = Array.from(matchPaths);\r\n      const longestMatchPath = matches[matches.length - 1];\r\n      return longestMatchPath;\r\n    }\r\n  }\r\n\r\n  bind(parentComponent: StructiveComponent, childComponent: StructiveComponent): void {\r\n    // bindParentComponent\r\n    const bindings = parentComponent.getBindingsFromChild(childComponent);\r\n    for (const binding of bindings ?? []) {\r\n      this.addBinding(binding);\r\n    }\r\n  }\r\n}\r\n\r\nexport function createComponentStateBinding(): IComponentStateBinding {\r\n  return new ComponentStateBinding();\r\n}","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IComponentStateBinding } from \"../ComponentStateBinding/types\";\r\nimport { SetByRefSymbol } from \"../StateClass/symbols\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { update } from \"../Updater/Updater\";\r\nimport { raiseError } from \"../utils\";\r\nimport { AssignStateSymbol, NotifyRedrawSymbol } from \"./symbols\";\r\nimport { IComponentStateInput, IComponentStateInputHandler } from \"./types\";\r\n\r\nclass ComponentStateInputHandler implements IComponentStateInputHandler {\r\n  private componentStateBinding: IComponentStateBinding;\r\n  private engine: IComponentEngine;\r\n  constructor(engine:IComponentEngine, componentStateBinding: IComponentStateBinding) {\r\n    this.componentStateBinding = componentStateBinding;\r\n    this.engine = engine;\r\n  }\r\n\r\n  assignState(object: any): void {\r\n    update(this.engine, null, async (updater, stateProxy) => {\r\n      for(const [key, value] of Object.entries(object)) {\r\n        const childPathInfo = getStructuredPathInfo(key);\r\n        const childRef = getStatePropertyRef(childPathInfo, null);\r\n        stateProxy[SetByRefSymbol](childRef, value);\r\n      }     \r\n    });\r\n  }\r\n\r\n  /**\r\n   * listindexに一致するかどうかは事前にスクリーニングしておく\r\n   * @param refs \r\n   */\r\n  notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    for(const parentPathRef of refs) {\r\n      try {\r\n        const childPath = this.componentStateBinding.toChildPathFromParentPath(parentPathRef.info.pattern);\r\n        const childPathInfo = getStructuredPathInfo(childPath);\r\n        const childListIndex = parentPathRef.listIndex;\r\n        const value = this.engine.getPropertyValue(childPathInfo, childListIndex);\r\n        // Ref情報をもとに状態更新キューに追加\r\n        update(this.engine, null, async (updater, stateProxy) => {\r\n          const childRef = getStatePropertyRef(childPathInfo, childListIndex);\r\n          updater.enqueueRef(childRef);\r\n        });\r\n      } catch(e) {\r\n        // 対象でないものは何もしない\r\n      }\r\n    }\r\n  }\r\n\r\n  get(target:any, prop:PropertyKey, receiver:IComponentStateInput) {\r\n    if (prop === AssignStateSymbol) {\r\n      return this.assignState.bind(this);\r\n    } else if (prop === NotifyRedrawSymbol) {\r\n      return this.notifyRedraw.bind(this);\r\n    } else if (typeof prop === \"string\") {\r\n      return this.engine.getPropertyValue(getStructuredPathInfo(prop), null);\r\n    }\r\n    raiseError(`Property \"${String(prop)}\" is not supported in ComponentStateInput.`);\r\n  }\r\n\r\n  set(target:any, prop:PropertyKey, value:any, receiver:IComponentStateInput): boolean {\r\n    if (typeof prop === \"string\") {\r\n      this.engine.setPropertyValue(getStructuredPathInfo(prop), null, value);\r\n      return true;\r\n    }\r\n    raiseError(`Property \"${String(prop)}\" is not supported in ComponentStateInput.`);\r\n  }\r\n}\r\n\r\nexport function createComponentStateInput(\r\n  engine: IComponentEngine,\r\n  componentStateBinding: IComponentStateBinding\r\n): IComponentStateInput {\r\n  const handler = new ComponentStateInputHandler(engine, componentStateBinding);\r\n  return new Proxy({}, handler) as IComponentStateInput;\r\n}","import { IComponentStateBinding } from \"../ComponentStateBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { SetByRefSymbol } from \"../StateClass/symbols\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { update } from \"../Updater/Updater\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IComponentStateOutput } from \"./types\";\r\n\r\nclass ComponentStateOutput implements IComponentStateOutput {\r\n  binding: IComponentStateBinding;\r\n  constructor(binding: IComponentStateBinding) {\r\n    this.binding = binding;\r\n  }\r\n\r\n  get(pathInfo: IStructuredPathInfo, listIndex: IListIndex | null): any {\r\n    const childPath = this.binding.startsWithByChildPath(pathInfo);\r\n    if (childPath === null) {\r\n      raiseError(`No child path found for path \"${pathInfo.toString()}\".`);\r\n    }\r\n    const binding = this.binding.bindingByChildPath.get(childPath);\r\n    if (typeof binding === \"undefined\") {\r\n      raiseError(`No binding found for child path \"${childPath}\".`);\r\n    }\r\n    const parentPathInfo = getStructuredPathInfo(this.binding.toParentPathFromChildPath(pathInfo.pattern));\r\n    return binding.engine.getPropertyValue(parentPathInfo, listIndex ?? binding.bindingState.listIndex);\r\n  }\r\n\r\n  set(pathInfo: IStructuredPathInfo, listIndex: IListIndex | null, value: any): boolean {\r\n    const childPath = this.binding.startsWithByChildPath(pathInfo);\r\n    if (childPath === null) {\r\n      raiseError(`No child path found for path \"${pathInfo.toString()}\".`);\r\n    }\r\n    const binding = this.binding.bindingByChildPath.get(childPath);\r\n    if (typeof binding === \"undefined\") {\r\n      raiseError(`No binding found for child path \"${childPath}\".`);\r\n    }\r\n    const parentPathInfo = getStructuredPathInfo(this.binding.toParentPathFromChildPath(pathInfo.pattern));\r\n    const engine = binding.engine;\r\n    const ref = getStatePropertyRef(parentPathInfo, listIndex ?? binding.bindingState.listIndex);\r\n    update(engine, null, async (updater, stateProxy) => {\r\n      stateProxy[SetByRefSymbol](ref, value);\r\n    });\r\n    return true;\r\n  }\r\n\r\n  startsWith(pathInfo: IStructuredPathInfo): boolean {\r\n    return this.binding.startsWithByChildPath(pathInfo) !== null;\r\n  }\r\n\r\n  getListIndexes(pathInfo:IStructuredPathInfo, listIndex:IListIndex | null): IListIndex[] | null {\r\n    const childPath = this.binding.startsWithByChildPath(pathInfo);\r\n    if (childPath === null) {\r\n      raiseError(`No child path found for path \"${pathInfo.toString()}\".`);\r\n    }\r\n    const binding = this.binding.bindingByChildPath.get(childPath);\r\n    if (typeof binding === \"undefined\") {\r\n      raiseError(`No binding found for child path \"${childPath}\".`);\r\n    }\r\n    const parentPathInfo = getStructuredPathInfo(this.binding.toParentPathFromChildPath(pathInfo.pattern));\r\n    return binding.engine.getListIndexes(parentPathInfo, listIndex);\r\n  }\r\n}\r\n\r\nexport function createComponentStateOutput(binding: IComponentStateBinding): IComponentStateOutput {\r\n  return new ComponentStateOutput(binding);\r\n}","import { createBindContent } from \"../DataBinding/BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../DataBinding/types\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { IState, IStructiveState } from \"../StateClass/types\";\r\nimport { ComponentType, IComponentConfig, IComponentStatic, StructiveComponent } from \"../WebComponents/types\";\r\nimport { attachShadow } from \"./attachShadow.js\";\r\nimport { ISaveInfoByResolvedPathInfo, IComponentEngine } from \"./types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, SetByRefSymbol, SetCacheableSymbol } from \"../StateClass/symbols.js\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { createReadonlyStateProxy } from \"../StateClass/createReadonlyStateProxy.js\";\r\nimport { IComponentStateBinding } from \"../ComponentStateBinding/types.js\";\r\nimport { createComponentStateBinding } from \"../ComponentStateBinding/createComponentStateBinding.js\";\r\nimport { createComponentStateInput } from \"../ComponentStateInput/createComponentStateInput.js\";\r\nimport { createComponentStateOutput } from \"../ComponentStateOutput/createComponentStateOutput.js\";\r\nimport { IComponentStateInput } from \"../ComponentStateInput/types.js\";\r\nimport { IComponentStateOutput } from \"../ComponentStateOutput/types.js\";\r\nimport { AssignStateSymbol } from \"../ComponentStateInput/symbols.js\";\r\nimport { IListIndex } from \"../ListIndex/types.js\";\r\nimport { IPathManager } from \"../PathManager/types.js\";\r\nimport { update } from \"../Updater/Updater.js\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IPathNode } from \"../PathTree/types.js\";\r\nimport { RESERVED_WORD_SET } from \"../constants.js\";\r\nimport { addPathNode } from \"../PathTree/PathNode.js\";\r\n\r\n/**\r\n * ComponentEngineクラスは、Structiveコンポーネントの状態管理・依存関係管理・\r\n * バインディング・ライフサイクル・レンダリングなどの中核的な処理を担うエンジンです。\r\n *\r\n * 主な役割:\r\n * - 状態インスタンスやプロキシの生成・管理\r\n * - テンプレート・スタイルシート・フィルター・バインディング情報の管理\r\n * - 依存関係グラフ（dependentTree）の構築と管理\r\n * - バインディング情報やリスト情報の保存・取得\r\n * - ライフサイクル（connectedCallback/disconnectedCallback）処理\r\n * - Shadow DOMやスタイルシートの適用\r\n * - 状態プロパティの取得・設定\r\n * - バインディングの追加・存在判定・リスト管理\r\n *\r\n * 構造・設計上の特徴:\r\n * - 状態や依存関係、バインディング情報を効率的に管理するためのキャッシュやマップを多用\r\n * - テンプレートやリスト構造の多重管理に対応\r\n * - 非同期初期化やUpdaterによるバッチ的な状態更新設計\r\n * - 疎結合な設計で、各種ユーティリティやファクトリ関数と連携\r\n *\r\n * 典型的なWeb Componentsのライフサイクルやリアクティブな状態管理を、Structive独自の構造で実現しています。\r\n */\r\nexport class ComponentEngine implements IComponentEngine {\r\n  type          : ComponentType = 'autonomous';\r\n  config        : IComponentConfig;\r\n  template      : HTMLTemplateElement;\r\n  styleSheet    : CSSStyleSheet;\r\n  stateClass    : IStructiveState;\r\n  state         : IState;\r\n  inputFilters  : FilterWithOptions;\r\n  outputFilters : FilterWithOptions;\r\n  #bindContent  :IBindContent | null = null;\r\n  get bindContent(): IBindContent {\r\n    if (this.#bindContent === null) {\r\n      raiseError(\"bindContent is not initialized yet\");\r\n    }\r\n    return this.#bindContent;\r\n  }\r\n  baseClass     : typeof HTMLElement = HTMLElement;\r\n  owner         : StructiveComponent;\r\n\r\n  bindingsByListIndex : WeakMap<IListIndex, Set<IBinding>> = new WeakMap();\r\n\r\n  bindingsByComponent: WeakMap<StructiveComponent, Set<IBinding>> = new WeakMap();\r\n  structiveChildComponents: Set<StructiveComponent> = new Set();\r\n\r\n  #waitForInitialize : PromiseWithResolvers<void> = Promise.withResolvers<void>();\r\n  #waitForDisconnected: PromiseWithResolvers<void> | null = null;\r\n  \r\n  #stateBinding: IComponentStateBinding = createComponentStateBinding();\r\n  stateInput: IComponentStateInput;\r\n  stateOutput: IComponentStateOutput;\r\n  #blockPlaceholder: Comment | null = null; // ブロックプレースホルダー\r\n  #blockParentNode: Node | null = null; // ブロックプレースホルダーの親ノード\r\n  #ignoreDissconnectedCallback: boolean = false; // disconnectedCallbackを無視するフラグ\r\n\r\n  constructor(config: IComponentConfig, owner: StructiveComponent) {\r\n    this.config = config;\r\n    if (this.config.extends) {\r\n      this.type = 'builtin';\r\n    }\r\n    const componentClass = owner.constructor as IComponentStatic;\r\n    this.template = componentClass.template;\r\n    this.styleSheet = componentClass.styleSheet;\r\n    this.stateClass = componentClass.stateClass;\r\n    this.state = new this.stateClass();\r\n    this.inputFilters = componentClass.inputFilters;\r\n    this.outputFilters = componentClass.outputFilters;\r\n    this.owner =  owner;\r\n    this.stateInput = createComponentStateInput(this, this.#stateBinding);\r\n    this.stateOutput = createComponentStateOutput(this.#stateBinding);\r\n  }\r\n\r\n  get pathManager(): IPathManager {\r\n    return (this.owner.constructor as IComponentStatic).pathManager;\r\n  }\r\n\r\n  setup(): void {\r\n    for(const path in this.state) {\r\n      if (RESERVED_WORD_SET.has(path) || this.pathManager.alls.has(path)) {\r\n        continue;\r\n      }\r\n      this.pathManager.alls.add(path);\r\n      addPathNode(this.pathManager.rootNode, path);\r\n    }\r\n    const componentClass = this.owner.constructor as IComponentStatic;\r\n    const rootRef = getStatePropertyRef(getStructuredPathInfo(''), null);\r\n    this.#bindContent = createBindContent(null, componentClass.id, this, rootRef); // this.stateArrayPropertyNamePatternsが変更になる可能性がある\r\n  }\r\n\r\n  get waitForInitialize(): PromiseWithResolvers<void> {\r\n    return this.#waitForInitialize;\r\n  }\r\n\r\n  async connectedCallback(): Promise<void> {\r\n    await this.#waitForDisconnected?.promise; // disconnectedCallbackが呼ばれている場合は待つ\r\n    await this.owner.parentStructiveComponent?.waitForInitialize.promise;\r\n    // コンポーネントの状態を初期化する\r\n    if (this.owner.dataset.state) {\r\n      // data-state属性から状態を取得する\r\n      try {\r\n        const json = JSON.parse(this.owner.dataset.state);\r\n        this.stateInput[AssignStateSymbol](json);\r\n      } catch(e) {\r\n        raiseError(\"Failed to parse state from dataset\");\r\n      }\r\n    }\r\n    const parentComponent = this.owner.parentStructiveComponent;\r\n    if (parentComponent) {\r\n      // 親コンポーネントの状態をバインドする\r\n      parentComponent.registerChildComponent(this.owner);\r\n      // 親コンポーネントの状態を子コンポーネントにバインドする\r\n      this.#stateBinding.bind(parentComponent, this.owner);\r\n    }\r\n    if (this.config.enableWebComponents) {\r\n      attachShadow(this.owner, this.config, this.styleSheet);\r\n    } else {\r\n      this.#blockParentNode = this.owner.parentNode;\r\n      this.#blockPlaceholder = document.createComment(\"Structive block placeholder\");\r\n      try {\r\n        this.#ignoreDissconnectedCallback = true; // disconnectedCallbackを無視するフラグを立てる\r\n        this.owner.replaceWith(this.#blockPlaceholder); // disconnectCallbackが呼ばれてしまう\r\n      } finally {\r\n        this.#ignoreDissconnectedCallback = false;\r\n      }\r\n    }\r\n\r\n    if (this.config.enableWebComponents) {\r\n      // Shadow DOMにバインドコンテンツをマウントする\r\n      this.bindContent.mount(this.owner.shadowRoot ?? this.owner);\r\n    } else {\r\n      // ブロックプレースホルダーの親ノードにバインドコンテンツをマウントする\r\n      const parentNode = this.#blockParentNode ?? raiseError(\"Block parent node is not set\");\r\n      this.bindContent.mountAfter(parentNode, this.#blockPlaceholder);\r\n    }\r\n\r\n    await update(this, null, async (updater, stateProxy) => {\r\n      // 状態の初期レンダリングを行う\r\n      for(const path of this.pathManager.alls) {\r\n        const info = getStructuredPathInfo(path);\r\n        if (info.pathSegments.length !== 1) continue; // ルートプロパティのみ\r\n        if (this.pathManager.funcs.has(path)) continue; // 関数は除外\r\n        const ref = getStatePropertyRef(info, null);\r\n        updater.enqueueRef(ref);\r\n      }\r\n      await stateProxy[ConnectedCallbackSymbol]();\r\n    });\r\n\r\n    // レンダリングが終わってから実行する\r\n    queueMicrotask(() => {\r\n      this.#waitForInitialize.resolve();\r\n    });\r\n  }\r\n\r\n  async disconnectedCallback(): Promise<void> {\r\n    this.#waitForDisconnected = Promise.withResolvers<void>();\r\n    try {\r\n      if (this.#ignoreDissconnectedCallback) return; // disconnectedCallbackを無視するフラグが立っている場合は何もしない\r\n      await update(this, null, async (updater, stateProxy) => {\r\n        await stateProxy[DisconnectedCallbackSymbol]();\r\n      });\r\n      // 親コンポーネントから登録を解除する\r\n      this.owner.parentStructiveComponent?.unregisterChildComponent(this.owner);\r\n      if (!this.config.enableWebComponents) {\r\n        this.#blockPlaceholder?.remove();\r\n        this.#blockPlaceholder = null;\r\n        this.#blockParentNode = null;\r\n      }\r\n    } finally {\r\n      this.#waitForDisconnected.resolve(); // disconnectedCallbackが呼ばれたことを通知   \r\n    }\r\n  }\r\n\r\n  #saveInfoByStructuredPathId: { [id:number]: ISaveInfoByResolvedPathInfo } = {};\r\n  #saveInfoByResolvedPathInfoIdByListIndex: WeakMap<IListIndex, { [id:number]: ISaveInfoByResolvedPathInfo }> = new WeakMap();\r\n\r\n  createSaveInfo():ISaveInfoByResolvedPathInfo {\r\n    return {\r\n      list          : null,\r\n      listIndexes   : null,\r\n      bindings      : [],\r\n    }\r\n  }\r\n\r\n  getSaveInfoByStatePropertyRef(info:IStructuredPathInfo, listIndex:IListIndex | null): ISaveInfoByResolvedPathInfo {\r\n    if (listIndex === null) {\r\n      let saveInfo = this.#saveInfoByStructuredPathId[info.id];\r\n      if (typeof saveInfo === \"undefined\") {\r\n        saveInfo = this.createSaveInfo();\r\n        this.#saveInfoByStructuredPathId[info.id] = saveInfo;\r\n      }\r\n      return saveInfo;\r\n    } else {\r\n      let saveInfoByResolvedPathInfoId = this.#saveInfoByResolvedPathInfoIdByListIndex.get(listIndex);\r\n      if (typeof saveInfoByResolvedPathInfoId === \"undefined\") {\r\n        saveInfoByResolvedPathInfoId = {};\r\n        this.#saveInfoByResolvedPathInfoIdByListIndex.set(listIndex, saveInfoByResolvedPathInfoId);\r\n      }\r\n      let saveInfo = saveInfoByResolvedPathInfoId[info.id];\r\n      if (typeof saveInfo === \"undefined\") {\r\n        saveInfo = this.createSaveInfo();\r\n        saveInfoByResolvedPathInfoId[info.id] = saveInfo;\r\n      }\r\n      return saveInfo;\r\n    }\r\n  }\r\n  \r\n  saveBinding(\r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex | null, \r\n    binding  : IBinding\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.bindings.push(binding);\r\n  }\r\n\r\n  saveListIndexes(\r\n    info              : IStructuredPathInfo, \r\n    listIndex         : IListIndex | null, \r\n    saveListIndexes   : IListIndex[]\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.listIndexes = saveListIndexes;\r\n  }\r\n\r\n  saveList(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null, \r\n    list     :any[]\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.list = list;\r\n  }\r\n\r\n  saveListAndListIndexes(\r\n    info              : IStructuredPathInfo, \r\n    listIndex         : IListIndex | null,\r\n    list              : any[] | null,\r\n    listIndexes       : IListIndex[] | null\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.list = list;\r\n    saveInfo.listIndexes = listIndexes;\r\n  }\r\n\r\n  getBindings(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null\r\n  ): IBinding[] {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return saveInfo.bindings;\r\n  }\r\n\r\n  getListIndexes(info:IStructuredPathInfo, listIndex:IListIndex | null): IListIndex[] | null {\r\n    if (this.stateOutput.startsWith(info)) {\r\n      return this.stateOutput.getListIndexes(info, listIndex);\r\n    }\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return saveInfo.listIndexes;\r\n  }\r\n    \r\n  getList(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null\r\n  ): any[] | null {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return saveInfo.list;\r\n  }\r\n\r\n  getListAndListIndexes(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null\r\n  ): [any[] | null, IListIndex[] | null] {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return [saveInfo.list, saveInfo.listIndexes];\r\n  }\r\n\r\n  getPropertyValue(info: IStructuredPathInfo, listIndex:IListIndex | null): any {\r\n    // プロパティの値を取得する\r\n    const ref = getStatePropertyRef(info, listIndex);\r\n    const stateProxy = createReadonlyStateProxy(this, this.state);\r\n    return stateProxy[GetByRefSymbol](ref);\r\n  }\r\n  setPropertyValue(info: IStructuredPathInfo, listIndex:IListIndex | null, value: any): void {\r\n    // プロパティの値を設定する\r\n    const ref = getStatePropertyRef(info, listIndex);\r\n    update(this, null, async (updater, stateProxy) => {\r\n      stateProxy[SetByRefSymbol](ref, value);\r\n    });\r\n  }\r\n  // Structive子コンポーネントを登録する\r\n  registerChildComponent(component: StructiveComponent): void {\r\n    this.structiveChildComponents.add(component);\r\n  }\r\n  unregisterChildComponent(component: StructiveComponent): void {\r\n    this.structiveChildComponents.delete(component);\r\n  }\r\n  \r\n}\r\n\r\nexport function createComponentEngine(config: IComponentConfig, component: StructiveComponent): IComponentEngine {\r\n  return new ComponentEngine(config, component);\r\n}","/**\r\n * replaceMustacheWithTemplateTag.ts\r\n *\r\n * Mustache構文（{{if:条件}}, {{for:式}}, {{endif}}, {{endfor}}, {{elseif:条件}}, {{else}} など）を\r\n * <template>タグやコメントノードに変換するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - HTML文字列内のMustache構文を正規表現で検出し、<template data-bind=\"...\">やコメントノードに変換\r\n * - if/for/endif/endfor/elseif/elseなどの制御構文をネスト対応で<template>タグに変換\r\n * - 通常の埋め込み式（{{expr}}）はコメントノード（<!--embed:expr-->）に変換\r\n *\r\n * 設計ポイント:\r\n * - stackでネスト構造を管理し、endif/endfor/elseif/elseの対応関係を厳密にチェック\r\n * - 不正なネストや対応しない構文にはraiseErrorで例外を発生\r\n * - elseif/elseはnot条件のtemplateを自動生成し、条件分岐を表現\r\n * - コメントノードへの変換で埋め込み式の安全なDOM挿入を実現\r\n */\r\nimport { COMMENT_EMBED_MARK } from \"../constants.js\";\r\nimport { raiseError } from \"../utils.js\";\r\n\r\nconst MUSTACHE_REGEXP = /\\{\\{([^\\}]+)\\}\\}/g;\r\nconst MUSTACHE_TYPES:Set<string> = new Set(['if', 'for', 'endif', 'endfor', 'elseif', 'else']);\r\n\r\ntype MustacheType = 'if' | 'for' | 'endif' | 'endfor' | 'elseif' | 'else';\r\ntype MustacheInfo = {\r\n  type: MustacheType;\r\n  remain: string; // after first ':'\r\n  expr: string;\r\n}\r\n\r\nexport function replaceMustacheWithTemplateTag(html: string): string {\r\n  const stack:MustacheInfo[] = [];\r\n  return html.replaceAll(MUSTACHE_REGEXP, (match, expr) => {\r\n    expr = expr.trim();\r\n    const [ type ] = expr.split(':');\r\n    if (!MUSTACHE_TYPES.has(type)) {\r\n      // embed\r\n      return `<!--${COMMENT_EMBED_MARK}${expr}-->`;\r\n    }\r\n    const remain = expr.slice(type.length + 1).trim();\r\n    const currentInfo:MustacheInfo = { type, expr, remain };\r\n    if (type === 'if' || type === 'for') {\r\n      stack.push(currentInfo);\r\n      return `<template data-bind=\"${expr}\">`;\r\n    } else if (type === 'endif') {\r\n      const endTags = [];\r\n      do {\r\n        const info = stack.pop() ?? raiseError('replaceMustacheToTemplateOrEmbed: endif without if');\r\n        if (info.type === 'if') {\r\n          endTags.push('</template>');\r\n          break;\r\n        } else if (info.type === 'elseif') {\r\n          endTags.push('</template>');\r\n        } else {\r\n          raiseError('replaceMustacheToTemplateOrEmbed: endif without if');\r\n        }\r\n      } while(true);\r\n      return endTags.join('');\r\n    } else if (type === 'endfor') {\r\n      const info = stack.pop() ?? raiseError('replaceMustacheToTemplateOrEmbed: endif without if');\r\n      if (info.type === 'for') {\r\n        return '</template>';\r\n      } else {\r\n        raiseError('replaceMustacheToTemplateOrEmbed: endfor without for');\r\n      }\r\n    } else if (type === 'elseif') {\r\n      const lastInfo = stack.at(-1) ?? raiseError('replaceMustacheToTemplateOrEmbed: elseif without if');\r\n      if (lastInfo.type === 'if' || lastInfo.type === 'elseif') {\r\n        stack.push(currentInfo);\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\"><template data-bind=\"if:${remain}\">`;\r\n      } else {\r\n        raiseError('replaceMustacheToTemplateOrEmbed: elseif without if');\r\n      }\r\n    } else if (type === 'else') {\r\n      const lastInfo = stack.at(-1) ?? raiseError('replaceMustacheToTemplateOrEmbed: else without if');\r\n      if (lastInfo.type === 'if') {\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\">`;\r\n      } else {\r\n        raiseError('replaceMustacheToTemplateOrEmbed: else without if');\r\n      }\r\n    } else {\r\n      raiseError('replaceMustacheToTemplateOrEmbed: unknown type');\r\n    }\r\n  });\r\n}\r\n\r\n\r\n\r\n","/**\r\n * replaceTemplateTagWithComment.ts\r\n *\r\n * <template>タグをコメントノードに置換し、テンプレートを再帰的に登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - 指定したHTMLTemplateElementをコメントノード（<!--template:id-->）に置換\r\n * - SVG内のtemplateタグは通常のtemplate要素に変換し、属性や子ノードを引き継ぐ\r\n * - テンプレート内の入れ子templateも再帰的に置換・登録\r\n * - registerTemplateでテンプレートをID付きで管理\r\n *\r\n * 設計ポイント:\r\n * - テンプレートの階層構造を維持しつつ、DOM上はコメントノードでマーク\r\n * - SVG対応や属性引き継ぎなど、汎用的なテンプレート処理に対応\r\n * - generateIdでユニークIDを割り当て、テンプレート管理を一元化\r\n */\r\nimport { COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants.js\";\r\nimport { generateId } from \"../GlobalId/generateId.js\";\r\nimport { registerTemplate } from \"./registerTemplate.js\";\r\n\r\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\r\n\r\nexport function replaceTemplateTagWithComment(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number = id\r\n):number {\r\n  // テンプレートの親ノードが存在する場合は、テンプレートをコメントノードに置き換える\r\n  template.parentNode?.replaceChild(document.createComment(`${COMMENT_TEMPLATE_MARK}${id}`), template);\r\n  if (template.namespaceURI === SVG_NS) {\r\n    // SVGタグ内のtemplateタグを想定\r\n    const newTemplate = document.createElement(\"template\");\r\n    const childNodes = Array.from(template.childNodes);\r\n    for(let i = 0; i < childNodes.length; i++) {\r\n      const childNode = childNodes[i];\r\n      newTemplate.content.appendChild(childNode);\r\n    }\r\n    const bindText = template.getAttribute(DATA_BIND_ATTRIBUTE);\r\n    newTemplate.setAttribute(DATA_BIND_ATTRIBUTE, bindText ?? \"\");\r\n    template = newTemplate;\r\n  }\r\n  template.content.querySelectorAll(\"template\").forEach(template => {\r\n    replaceTemplateTagWithComment(generateId(), template, rootId);\r\n  });\r\n  registerTemplate(id, template, rootId);\r\n  return id;\r\n}\r\n","/**\r\n * registerHtml.ts\r\n *\r\n * HTML文字列をテンプレートとして登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - 指定IDでHTMLテンプレートを生成し、data-id属性を付与\r\n * - Mustache構文（{{ }})をテンプレートタグに変換（replaceMustacheWithTemplateTagを利用）\r\n * - テンプレートタグをコメントに置換（replaceTemplateTagWithCommentを利用）\r\n *\r\n * 設計ポイント:\r\n * - テンプレートの動的生成・管理や、構文変換による柔軟なテンプレート処理に対応\r\n * - テンプレートはdocument.createElement(\"template\")で生成し、data-idで識別\r\n */\r\nimport { replaceMustacheWithTemplateTag } from \"./replaceMustacheWithTemplateTag.js\";\r\nimport { replaceTemplateTagWithComment } from \"./replaceTemplateTagWithComment.js\";\r\n\r\nexport function registerHtml(id: number, html:string) {\r\n  const template = document.createElement(\"template\");\r\n  template.dataset.id = id.toString();\r\n  template.innerHTML = replaceMustacheWithTemplateTag(html);\r\n  replaceTemplateTagWithComment(id, template);\r\n}","/**\r\n * createAccessorFunctions.ts\r\n *\r\n * Stateプロパティのパス情報（IStructuredPathInfo）から、動的なgetter/setter関数を生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - パス情報とgetter集合から、最適なアクセサ関数（get/set）を動的に生成\r\n * - ワイルドカード（*）やネストしたプロパティパスにも対応\r\n * - パスやセグメントのバリデーションも実施\r\n *\r\n * 設計ポイント:\r\n * - matchPathsから最長一致のgetterパスを探索し、そこからの相対パスでアクセサを構築\r\n * - パスが一致しない場合はinfo.pathSegmentsから直接アクセサを生成\r\n * - new Functionで高速なgetter/setterを動的生成\r\n * - パスやセグメント名は正規表現で厳密にチェックし、安全性を担保\r\n */\r\nimport { getStructuredPathInfo } from \"./getStructuredPathInfo\";\r\nimport { IAccessorFunctions, IStructuredPathInfo } from \"./types\";\r\n\r\nconst checkSegmentRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\r\nconst checkPathRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*(\\.[a-zA-Z_$][0-9a-zA-Z_$]*|\\.\\*)*$/;\r\n\r\nexport function createAccessorFunctions(info: IStructuredPathInfo, getters: Set<string>): IAccessorFunctions {\r\n  const matchPaths = new Set(info.cumulativePaths).intersection(getters);\r\n  let len = -1;\r\n  let matchPath = '';\r\n  for(const curPath of matchPaths) {\r\n    const pathSegments = curPath.split('.');\r\n    if (pathSegments.length === 1) {\r\n      continue;\r\n    }\r\n    if (pathSegments.length > len) {\r\n      len = pathSegments.length;\r\n      matchPath = curPath;\r\n    }\r\n  }\r\n  if (matchPath.length > 0) {\r\n    if (!checkPathRegexp.test(matchPath)) {\r\n      throw new Error(`Invalid path: ${matchPath}`);\r\n    }\r\n    const matchInfo = getStructuredPathInfo(matchPath);\r\n    const segments = [];\r\n    let count = matchInfo.wildcardCount;\r\n    for(let i = matchInfo.pathSegments.length; i < info.pathSegments.length; i++) {\r\n      const segment = info.pathSegments[i];\r\n      if (segment === '*') {\r\n        segments.push(\"[this.$\" + (count + 1) + \"]\");\r\n        count++;\r\n      } else {\r\n        if (!checkSegmentRegexp.test(segment)) {\r\n          throw new Error(`Invalid segment name: ${segment}`);\r\n        }\r\n        segments.push(\".\" + segment);\r\n      }\r\n    }\r\n    const path = segments.join('');\r\n    return {\r\n      get : new Function('', `return this[\"${matchPath}\"]${path};`) as ()=> any,\r\n      set : new Function('value', `this[\"${matchPath}\"]${path} = value;`) as (value: any) => void,\r\n    }\r\n  } else {\r\n    const segments = [];\r\n    let count = 0;\r\n    for(let i = 0; i < info.pathSegments.length; i++) {\r\n      const segment = info.pathSegments[i];\r\n      if (segment === '*') {\r\n        segments.push(\"[this.$\" + (count + 1) + \"]\");\r\n        count++;\r\n      } else {\r\n        if (!checkSegmentRegexp.test(segment)) {\r\n          throw new Error(`Invalid segment name: ${segment}`);\r\n        }\r\n        segments.push((segments.length > 0 ? \".\" : \"\") + segment);\r\n      }\r\n    }\r\n    const path = segments.join('');\r\n    return {\r\n      get : new Function('', `return this.${path};`) as ()=> any,\r\n      set : new Function('value', `this.${path} = value;`) as (value: any) => void,\r\n    }\r\n  }\r\n\r\n}\r\n","import { getListPathsSetById, getPathsSetById } from \"../BindingBuilder/registerDataBindAttributes\";\r\nimport { RESERVED_WORD_SET } from \"../constants\";\r\nimport { addPathNode, createRootNode } from \"../PathTree/PathNode\";\r\nimport { IPathNode } from \"../PathTree/types\";\r\nimport { createAccessorFunctions } from \"../StateProperty/createAccessorFunctions\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { Constructor } from \"../types\";\r\nimport { StructiveComponentClass } from \"../WebComponents/types\";\r\nimport { Dependencies, IPathManager } from \"./types\";\r\n\r\nclass PathManager implements IPathManager {\r\n  alls: Set<string> = new Set<string>();\r\n  lists: Set<string> = new Set<string>();\r\n  elements: Set<string> = new Set<string>();\r\n  funcs: Set<string> = new Set<string>();\r\n  getters: Set<string> = new Set<string>();\r\n  setters: Set<string> = new Set<string>();\r\n  optimizes: Set<string> = new Set<string>();\r\n  staticDependencies: Dependencies<string> = new Map<string, Set<string>>();\r\n  dynamicDependencies: Dependencies<string> = new Map<string, Set<string>>();\r\n  rootNode: IPathNode = createRootNode();\r\n  #id: number;\r\n  #stateClass: Constructor<any>;\r\n\r\n  constructor(componentClass: StructiveComponentClass) {\r\n    this.#id = componentClass.id;\r\n    this.#stateClass = componentClass.stateClass;\r\n    const alls = getPathsSetById(this.#id);\r\n    for(const path of alls) {\r\n      const info = getStructuredPathInfo(path);\r\n      this.alls = this.alls.union(info.cumulativePathSet);\r\n    }\r\n    const lists = getListPathsSetById(this.#id);\r\n    this.lists = this.lists.union(lists);\r\n    for(const listPath of lists) {\r\n      const elementPath = listPath + \".*\";\r\n      this.elements.add(elementPath);\r\n    }\r\n    let currentProto = this.#stateClass.prototype;\r\n    while (currentProto && currentProto !== Object.prototype) {\r\n      const getters = Object.getOwnPropertyDescriptors(currentProto);\r\n      if (getters) {\r\n        for (const [key, desc] of Object.entries(getters)) {\r\n          if (RESERVED_WORD_SET.has(key)) {\r\n            continue;\r\n          }\r\n          if (typeof desc.value === \"function\") {\r\n            this.funcs.add(key);\r\n            continue;\r\n          }\r\n          const hasGetter = (desc as PropertyDescriptor).get !== undefined;\r\n          const hasSetter = (desc as PropertyDescriptor).set !== undefined;\r\n          const info = getStructuredPathInfo(key);\r\n          this.alls = this.alls.union(info.cumulativePathSet);\r\n          if (hasGetter) {\r\n            this.getters.add(key);\r\n          }\r\n          if (hasSetter) {\r\n            this.setters.add(key);\r\n          }\r\n        }\r\n      }\r\n      currentProto = Object.getPrototypeOf(currentProto);\r\n    }\r\n    // 最適化対象のパスを決定し、最適化する\r\n    for(const path of this.alls) {\r\n      if (this.getters.has(path)) {\r\n        continue;\r\n      }\r\n      if (this.setters.has(path)) {\r\n        continue;\r\n      }\r\n      const info = getStructuredPathInfo(path);\r\n      if (info.pathSegments.length === 1) {\r\n        continue;\r\n      }\r\n      const funcs = createAccessorFunctions(info, this.getters);\r\n      Object.defineProperty(this.#stateClass.prototype, path, {\r\n        get: funcs.get,\r\n        set: funcs.set,\r\n        enumerable: true,\r\n        configurable: true,\r\n      });\r\n      this.optimizes.add(path);\r\n    }\r\n    // 静的依存関係の設定\r\n    for(const path of this.alls) {\r\n      addPathNode(this.rootNode, path);\r\n      const info = getStructuredPathInfo(path);\r\n      if (info.parentPath) {\r\n        this.staticDependencies.get(info.parentPath)?.add(path) ?? \r\n          this.staticDependencies.set(info.parentPath, new Set([path]));\r\n      }\r\n    }\r\n  }\r\n\r\n  addDynamicDependency(target: string, source: string) {\r\n    this.dynamicDependencies.get(source)?.add(target) ?? \r\n      this.dynamicDependencies.set(source, new Set([target]));\r\n  }\r\n}\r\n\r\nexport function createPathManager(componentClass: StructiveComponentClass): IPathManager {\r\n  return new PathManager(componentClass);\r\n}","/**\r\n * createComponentClass.ts\r\n *\r\n * StructiveのWeb Components用カスタム要素クラスを動的に生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - ユーザー定義のcomponentData（stateClass, html, css等）からWeb Componentsクラスを生成\r\n * - StateClass/テンプレート/CSS/バインディング情報などをIDで一元管理・登録\r\n * - 独自のget/setトラップやバインディング、親子コンポーネント探索、フィルター拡張など多機能な基盤を提供\r\n * - 静的プロパティでテンプレート・スタイル・StateClass・フィルター・getter情報などにアクセス可能\r\n * - defineメソッドでカスタム要素として登録\r\n *\r\n * 設計ポイント:\r\n * - findStructiveParentで親Structiveコンポーネントを探索し、階層的な状態管理を実現\r\n * - getter/setter/バインディング最適化やアクセサ自動生成（optimizeAccessor）に対応\r\n * - テンプレート・CSS・StateClass・バインディング情報をIDで一元管理し、再利用性・拡張性を確保\r\n * - フィルターやバインディング情報も静的プロパティで柔軟に拡張可能\r\n */\r\nimport { inputBuiltinFilters, outputBuiltinFilters } from \"../Filter/builtinFilters.js\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { generateId } from \"../GlobalId/generateId.js\";\r\nimport { getStateClassById, registerStateClass } from \"../StateClass/registerStateClass.js\";\r\nimport { getStyleSheetById } from \"../StyleSheet/registerStyleSheet.js\";\r\nimport { registerCss } from \"../StyleSheet/regsiterCss.js\";\r\nimport { createComponentEngine } from \"../ComponentEngine/ComponentEngine.js\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types.js\";\r\nimport { registerHtml } from \"../Template/registerHtml.js\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { getBaseClass } from \"./getBaseClass.js\";\r\nimport { getComponentConfig } from \"./getComponentConfig.js\";\r\nimport { IComponent, IUserComponentData, IUserConfig, StructiveComponentClass, StructiveComponent } from \"./types\";\r\nimport { getListPathsSetById, getPathsSetById } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { IStructiveState } from \"../StateClass/types\";\r\nimport { IBinding } from \"../DataBinding/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { createAccessorFunctions } from \"../StateProperty/createAccessorFunctions.js\";\r\nimport { config as globalConfig } from \"./getGlobalConfig.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IComponentStateInput } from \"../ComponentStateInput/types.js\";\r\nimport { findStructiveParent } from \"./findStructiveParent.js\";\r\nimport { IPathManager } from \"../PathManager/types.js\";\r\nimport { createPathManager } from \"../PathManager/PathManager.js\";\r\n\r\n\r\nexport function createComponentClass(componentData: IUserComponentData): StructiveComponentClass {\r\n  const config = (componentData.stateClass.$config ?? {})as IUserConfig;\r\n  const componentConfig = getComponentConfig(config);\r\n  const id = generateId();\r\n  const { html, css, stateClass } = componentData;\r\n  const inputFilters:FilterWithOptions = Object.assign({}, inputBuiltinFilters);\r\n  const outputFilters:FilterWithOptions = Object.assign({}, outputBuiltinFilters);\r\n  stateClass.$isStructive = true;\r\n  registerHtml(id, html);\r\n  registerCss(id, css);\r\n  registerStateClass(id, stateClass);\r\n  const baseClass = getBaseClass(componentConfig.extends);\r\n  const extendTagName = componentConfig.extends;\r\n  return class extends baseClass implements IComponent {\r\n    #engine: IComponentEngine;\r\n\r\n    constructor() {\r\n      super();\r\n      this.#engine = createComponentEngine(componentConfig, this as StructiveComponent);\r\n      this.#engine.setup();\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.#engine.connectedCallback();\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.#engine.disconnectedCallback();\r\n    }\r\n\r\n    #parentStructiveComponent: StructiveComponent | null | undefined;\r\n    get parentStructiveComponent(): StructiveComponent | null {\r\n      if (typeof this.#parentStructiveComponent === \"undefined\") {\r\n        this.#parentStructiveComponent = findStructiveParent(this as StructiveComponent);\r\n      }\r\n      return this.#parentStructiveComponent;\r\n    }\r\n\r\n    get state(): IComponentStateInput {\r\n      return this.#engine.stateInput;\r\n    }\r\n\r\n    get isStructive(): boolean {\r\n      return this.#engine.stateClass.$isStructive ?? false;\r\n    }\r\n\r\n    get waitForInitialize(): PromiseWithResolvers<void> {\r\n      return this.#engine.waitForInitialize;\r\n    }\r\n\r\n    getBindingsFromChild(component: IComponent): Set<IBinding> | null {\r\n      return this.#engine.bindingsByComponent.get(component as StructiveComponent) ?? null;\r\n    }\r\n\r\n    registerChildComponent(component:StructiveComponent): void {\r\n      this.#engine.registerChildComponent(component);\r\n    }\r\n    unregisterChildComponent(component:StructiveComponent): void {\r\n      this.#engine.unregisterChildComponent(component);\r\n    }\r\n    static define(tagName:string) {\r\n      if (extendTagName) {\r\n        customElements.define(tagName, this, { extends: extendTagName });\r\n      } else {\r\n        customElements.define(tagName, this);\r\n      }\r\n    }\r\n\r\n    static get id():number {\r\n      return id;\r\n    }\r\n    static #html:string = html;\r\n    static get html():string {\r\n      return this.#html;\r\n    }\r\n    static set html(value:string) {\r\n      this.#html = value;\r\n      registerHtml(this.id, value);\r\n      this.#template = null;\r\n      this.#pathManager = null; // パス情報をリセット\r\n    }\r\n\r\n    static #css:string = css;\r\n    static get css() {\r\n      return this.#css;\r\n    }\r\n    static set css(value:string) {\r\n      this.#css = value;\r\n      registerCss(this.id, value);\r\n      this.#styleSheet = null;\r\n    }\r\n    static #template: HTMLTemplateElement | null = null;\r\n    static get template():HTMLTemplateElement {\r\n      if (!this.#template) {\r\n        this.#template = getTemplateById(this.id);\r\n      }\r\n      return this.#template;\r\n    }\r\n    static #styleSheet: CSSStyleSheet | null = null;\r\n    static get styleSheet():CSSStyleSheet {\r\n      if (!this.#styleSheet) {\r\n        this.#styleSheet = getStyleSheetById(this.id);\r\n      }\r\n      return this.#styleSheet;\r\n    }\r\n    static #stateClass: IStructiveState | null = null;\r\n    static get stateClass():IStructiveState {\r\n      if (!this.#stateClass) {\r\n        this.#stateClass = getStateClassById(this.id) as IStructiveState;\r\n      }\r\n      return this.#stateClass;\r\n    }\r\n    static #inputFilters:FilterWithOptions = inputFilters;\r\n    static get inputFilters():FilterWithOptions {\r\n      return this.#inputFilters;\r\n    }\r\n    static #outputFilters:FilterWithOptions = outputFilters;\r\n    static get outputFilters():FilterWithOptions {\r\n      return this.#outputFilters;\r\n    }\r\n    static #pathManager: IPathManager | null = null;\r\n    static get pathManager(): IPathManager {\r\n      if (!this.#pathManager) {\r\n        this.#pathManager = createPathManager(this as StructiveComponentClass);\r\n      }\r\n      return this.#pathManager;\r\n    }\r\n\r\n  } as StructiveComponentClass;\r\n}\r\n","/**\r\n * getComponentConfig.ts\r\n *\r\n * ユーザー設定（IUserConfig）とグローバル設定を統合し、コンポーネントの設定（IComponentConfig）を生成するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - getGlobalConfigでグローバル設定を取得\r\n * - ユーザー設定が優先され、未指定の場合はグローバル設定値を利用\r\n * - enableShadowDomやextendsなどの設定値を一元的に返却\r\n *\r\n * 設計ポイント:\r\n * - ユーザーごとの個別設定と全体のデフォルト設定を柔軟に統合\r\n * - 設定値のデフォルト化や拡張性を考慮した設計\r\n */\r\nimport { getGlobalConfig } from \"./getGlobalConfig.js\";\r\nimport { IUserConfig, IComponentConfig } from \"./types\";\r\n\r\nexport function getComponentConfig(userConfig: IUserConfig): IComponentConfig {\r\n  const globalConfig = getGlobalConfig();\r\n  return {\r\n    enableWebComponents: typeof userConfig.enableWebComponents === \"undefined\" ? true : userConfig.enableWebComponents,\r\n    enableShadowDom    : userConfig.enableShadowDom ?? globalConfig.enableShadowDom,\r\n    extends            : userConfig.extends ?? null,\r\n  };\r\n}","/**\r\n * getBaseClass.ts\r\n *\r\n * 指定したタグ名（extendTagName）から、その要素のコンストラクタ（基底クラス）を取得するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - extendTagNameが指定されていれば、そのタグのHTMLElementコンストラクタを返す\r\n * - 指定がなければHTMLElementを返す\r\n *\r\n * 設計ポイント:\r\n * - カスタム要素の継承元クラスを動的に取得し、柔軟なWeb Components拡張に対応\r\n */\r\nimport { Constructor } from \"../types\";\r\n\r\nexport function getBaseClass(extendTagName: string | null):Constructor<HTMLElement> {\r\n  return extendTagName ? (document.createElement(extendTagName).constructor as Constructor<HTMLElement>) : HTMLElement;\r\n}","/**\r\n * createSingleFileComponent.ts\r\n *\r\n * Structive用のシングルファイルコンポーネント（SFC）をパースし、各要素（HTML, CSS, StateClass）を抽出・生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - テキストから<template>・<script type=\"module\">・<style>を抽出し、それぞれを分離\r\n * - <script type=\"module\">はBase64エンコードして動的importし、StateClassとして利用\r\n * - {{...}}埋め込み式は一時的にコメントノード化してHTMLパース時の消失を防止し、復元\r\n * - 各要素（html, css, stateClass, text）をIUserComponentDataとして返却\r\n *\r\n * 設計ポイント:\r\n * - escapeEmbed/unescapeEmbedでMustache構文の安全なパースを実現\r\n * - scriptはdata:URL経由で安全に動的import\r\n * - テンプレート・スクリプト・スタイルを柔軟に分離・管理できる設計\r\n */\r\nimport { IStructiveState } from \"../StateClass/types\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nfunction escapeEmbed(html: string): string {\r\n  return html.replaceAll(/\\{\\{([^\\}]+)\\}\\}/g, (match, expr) => {\r\n    return `<!--{{${expr}}}-->`;\r\n  });\r\n}\r\n\r\nfunction unescapeEmbed(html:string):string {\r\n  return html.replaceAll(/<!--\\{\\{([^\\}]+)\\}\\}-->/g, (match, expr) => {\r\n    return `{{${expr}}}`;\r\n  });\r\n}\r\n\r\nexport async function createSingleFileComponent(text: string): Promise<IUserComponentData> {\r\n  const template = document.createElement(\"template\");\r\n  template.innerHTML = escapeEmbed(text);\r\n\r\n  const html = template.content.querySelector(\"template\");\r\n  html?.remove();\r\n\r\n  const script = template.content.querySelector(\"script[type=module]\") as HTMLScriptElement;\r\n  const b64 = btoa(String.fromCodePoint(...new TextEncoder().encode(script.text)));\r\n  const scriptModule = script ? await import(\"data:application/javascript;base64,\" + b64) : {};\r\n//  const scriptModule = script ? await import(\"data:text/javascript;charset=utf-8,\" + script.text) : {};\r\n  script?.remove();\r\n\r\n  const style = template.content.querySelector(\"style\");\r\n  style?.remove();\r\n\r\n  const stateClass = (scriptModule.default ?? class {}) as IStructiveState;\r\n  \r\n  return {\r\n    text,\r\n    html      : unescapeEmbed(html?.innerHTML ?? \"\").trim(),\r\n    css       : style?.textContent ?? \"\",\r\n    stateClass,\r\n  }\r\n}","/**\r\n * loadSingleFileComponent.ts\r\n *\r\n * 指定パスのシングルファイルコンポーネント（SFC）をfetchし、パースしてIUserComponentDataとして返すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - fetchで指定パスのSFCファイルを取得\r\n * - テキストとして読み込み、createSingleFileComponentでパース\r\n * - パース結果（IUserComponentData）を返却\r\n *\r\n * 設計ポイント:\r\n * - import.meta.resolveを利用し、パス解決の柔軟性を確保\r\n * - 非同期処理で動的なコンポーネントロードに対応\r\n */\r\nimport { createSingleFileComponent } from \"./createSingleFileComponent.js\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nexport async function loadSingleFileComponent(path: string): Promise<IUserComponentData> {\r\n  const response = await fetch(import.meta.resolve(path));\r\n  const text = await response.text();\r\n  return createSingleFileComponent(text);\r\n}\r\n","/**\r\n * registerComponentClass.ts\r\n *\r\n * StructiveのWeb Componentsクラスを指定したタグ名でカスタム要素として登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - registerComponentClass: 渡されたcomponentClassをtagNameでdefineメソッドを使って登録\r\n *\r\n * 設計ポイント:\r\n * - Web Componentsのカスタム要素登録を簡潔にラップし、再利用性を高める設計\r\n */\r\nimport { StructiveComponentClass } from \"./types\";\r\n\r\nexport function registerComponentClass(tagName: string, componentClass: StructiveComponentClass) {\r\n  componentClass.define(tagName);\r\n}","/**\r\n * loadImportmap.ts\r\n *\r\n * HTML内の<script type=\"importmap\">タグからimportmap情報を取得・統合するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - 複数のimportmapスクリプトタグを走査し、全てのimportsをマージしてIImportMap型で返却\r\n *\r\n * 設計ポイント:\r\n * - scriptタグのinnerHTMLをJSON.parseでパースし、importsプロパティを統合\r\n * - importmap.importsが複数存在する場合もObject.assignでマージ\r\n * - importmap仕様に準拠し、柔軟なimportエイリアス管理を実現\r\n */\r\nimport { IImportMap } from \"./types\";\r\n\r\nexport function loadImportmap():IImportMap {\r\n  const importmap: IImportMap = {};\r\n  document.querySelectorAll(\"script[type='importmap']\").forEach(script => {\r\n    const scriptImportmap = JSON.parse(script.innerHTML);\r\n    if (scriptImportmap.imports) {\r\n      importmap.imports = Object.assign(importmap.imports || {}, scriptImportmap.imports);\r\n    }\r\n  });\r\n  return importmap;\r\n}\r\n\r\n","/**\r\n * Router.ts\r\n *\r\n * シングルページアプリケーション（SPA）向けのカスタムエレメント Router の実装です。\r\n *\r\n * 主な役割:\r\n * - ルート定義（entryRoute）に基づき、URLパスに応じてカスタム要素を動的に生成・表示\r\n * - pushState/popstateイベントを利用した履歴管理とルーティング制御\r\n * - ルートパラメータの抽出とカスタム要素への受け渡し\r\n * - 404ページ（未定義ルート時）の表示\r\n *\r\n * 設計ポイント:\r\n * - entryRouteでルートパスとカスタム要素タグ名のペアを登録\r\n * - popstateイベントでURL変更時に自動で再描画\r\n * - ルートパスのパラメータ（:id等）も正規表現で抽出し、data-state属性で渡す\r\n * - getRouterでグローバルなRouterインスタンスを取得可能\r\n */\r\nimport { isLazyLoadComponent, loadLazyLoadComponent } from \"../WebComponents/loadFromImportMap\";\r\nimport { IRouter } from \"./types\";\r\n\r\nconst DEFAULT_ROUTE_PATH = '/'; // Default route path\r\nconst ROUTE_PATH_PREFIX = 'routes:'; // Prefix for route paths\r\n/**\r\n * example:\r\n * ```ts\r\n * entryRoute('my-view', '/my-view/:id');\r\n */\r\nconst routeEntries: Array<[string, string]> = [];\r\n\r\nlet globalRouter : Router | null = null;\r\n\r\nexport class Router extends HTMLElement implements IRouter {\r\n  originalPathName = window.location.pathname; // Store the original path name\r\n  originalFileName = window.location.pathname.split('/').pop() || ''; // Store the original file name\r\n  basePath = document.querySelector('base')?.href.replace(window.location.origin, \"\") || DEFAULT_ROUTE_PATH;\r\n\r\n  _popstateHandler: (event: PopStateEvent) => void;\r\n  constructor() {\r\n    super();\r\n    this._popstateHandler = this.popstateHandler.bind(this);\r\n  }\r\n\r\n  connectedCallback() {\r\n    globalRouter = this;\r\n    this.innerHTML = '<slot name=\"content\"></slot>';\r\n    window.addEventListener('popstate', this._popstateHandler);\r\n    window.dispatchEvent(new Event(\"popstate\")); // Dispatch popstate event to trigger the initial render\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    window.removeEventListener('popstate', this._popstateHandler);\r\n    globalRouter = null;\r\n  }\r\n\r\n  popstateHandler(event: PopStateEvent) {\r\n    event.preventDefault();\r\n    this.render();\r\n  }\r\n\r\n  navigate(to: string) {\r\n    const toPath = to[0] === '/' ? (this.basePath + to.slice(1)) : to; // Ensure the path starts with '/'\r\n    history.pushState({}, '', toPath);\r\n    this.render();\r\n  }\r\n\r\n  render() {\r\n    // スロットコンテントをクリア\r\n    const slotChildren = Array.from(this.childNodes).filter(\r\n      n => (n as HTMLElement).getAttribute?.('slot') === 'content'\r\n    );\r\n    slotChildren.forEach(n => this.removeChild(n));\r\n\r\n    const paths = window.location.pathname.split('/');\r\n    if (paths.at(-1) === this.originalFileName) {\r\n      paths[paths.length - 1] = ''; // Ensure the last path is empty for root\r\n    }\r\n    const pathName = paths.join('/');\r\n    const replacedPath = pathName.replace(this.basePath, ''); // Remove base path and ensure default route\r\n    const currentPath = replacedPath[0] !== '/' ? '/' + replacedPath : replacedPath; // Ensure the path starts with '/'\r\n    let tagName: string | undefined = undefined;\r\n    let params: Record<string, string> = {};\r\n    // Check if the routePath matches any of the defined routes\r\n    for (const [path, tag] of routeEntries) {\r\n      const regex = new RegExp(\"^\" + path.replace(/:[^\\s/]+/g, '([^/]+)') + \"$\");\r\n      if (regex.test(currentPath)) {\r\n        tagName = tag;\r\n        // Extract the parameters from the routePath\r\n        const matches = currentPath.match(regex);\r\n        if (matches) {\r\n          const keys = path.match(/:[^\\s/]+/g) || [];\r\n          keys.forEach((key, index) => {\r\n            params[key.substring(1)] = matches[index + 1]; // +1 to skip the full match\r\n          });\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    if (tagName) {\r\n      // If a route matches, create the custom element and set its state\r\n      // Create the custom element with the tag name\r\n      // project the custom element into the router slot\r\n      const customElement = document.createElement(tagName) as HTMLElement;\r\n      customElement.setAttribute('data-state', JSON.stringify(params));\r\n      customElement.setAttribute('slot', 'content');\r\n      this.appendChild(customElement);\r\n      if (isLazyLoadComponent(tagName)) {\r\n        loadLazyLoadComponent(tagName); // Load lazy load component if necessary\r\n      }\r\n    } else {\r\n      // If no route matches, show 404 content\r\n      const messageElement = document.createElement('h1') as HTMLElement;\r\n      messageElement.setAttribute('slot', 'content');\r\n      messageElement.textContent = '404 Not Found';\r\n      this.appendChild(messageElement);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport function entryRoute(tagName: string, routePath: string): void {\r\n  if (routePath.startsWith(ROUTE_PATH_PREFIX)) {\r\n    routePath = routePath.substring(ROUTE_PATH_PREFIX.length); // Remove 'routes:' prefix\r\n  }\r\n  routeEntries.push([routePath, tagName]);\r\n}\r\n\r\nexport function getRouter(): Router | null {\r\n  return globalRouter;\r\n}\r\n\r\n","/**\r\n * MainWrapper.ts\r\n *\r\n * アプリ全体のレイアウトやルーティングを管理するカスタムエレメント MainWrapper の実装です。\r\n *\r\n * 主な役割:\r\n * - Shadow DOMの有効化やレイアウトテンプレートの動的読み込み\r\n * - レイアウトテンプレートやスタイルの適用\r\n * - ルーター要素（routerTagName）の動的追加\r\n *\r\n * 設計ポイント:\r\n * - config.enableShadowDom でShadow DOMの有効/無効を切り替え\r\n * - config.layoutPath が指定されていればfetchでレイアウトHTMLを取得し、テンプレート・スタイルを適用\r\n * - スタイルはadoptedStyleSheetsでShadowRootまたはdocumentに適用\r\n * - レイアウトが指定されていない場合はデフォルトのslotを挿入\r\n * - config.enableRouter が有効な場合はrouter要素をslotに追加\r\n */\r\nimport { raiseError } from \"../utils\";\r\nimport { config } from \"../WebComponents/getGlobalConfig\";\r\n\r\nconst SLOT_KEY = \"router\";\r\nconst DEFAULT_LAYOUT = `<slot name=\"${SLOT_KEY}\"></slot>`;\r\n\r\nexport class MainWrapper extends HTMLElement {\r\n  constructor() {\r\n    super();\r\n    if (config.enableShadowDom) {\r\n      this.attachShadow({ mode: 'open' });\r\n    }\r\n  }\r\n\r\n  async connectedCallback() {\r\n    await this.loadLayout();\r\n    this.render();\r\n  }\r\n\r\n  get root(): ShadowRoot | HTMLElement {\r\n    return this.shadowRoot ?? this;\r\n  }\r\n\r\n  async loadLayout() {\r\n    if (config.layoutPath) {\r\n      const response = await fetch(config.layoutPath);\r\n      if (response.ok) {\r\n        const layoutText = await response.text();\r\n        const workTemplate = document.createElement(\"template\");\r\n        workTemplate.innerHTML = layoutText;\r\n      \r\n        const template = workTemplate.content.querySelector(\"template\");\r\n        const style = workTemplate.content.querySelector(\"style\") as CSSStyleSheet | null;\r\n      \r\n        this.root.appendChild(template?.content ?? document.createDocumentFragment());\r\n        if (style) {\r\n          const shadowRootOrDocument = this.shadowRoot ?? document;\r\n          const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n          if (!styleSheets.includes(style)) {\r\n            shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, style];\r\n          }\r\n        }\r\n      } else {\r\n        raiseError(`Failed to load layout from ${config.layoutPath}`);\r\n      }\r\n    } else {\r\n      this.root.innerHTML = DEFAULT_LAYOUT;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    // add router\r\n    if (config.enableRouter) {\r\n      const router = document.createElement(config.routerTagName);\r\n      router.setAttribute('slot', SLOT_KEY);\r\n      this.root.appendChild(router);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * exports.ts\r\n *\r\n * Structiveの主要なエントリーポイント・APIを外部公開するモジュールです。\r\n *\r\n * 主な役割:\r\n * - registerSingleFileComponents, bootstrap, config などの主要APIをエクスポート\r\n * - defineComponents: SFC群をまとめて登録し、autoInitが有効なら自動で初期化\r\n * - bootstrapStructive: 初期化処理を一度だけ実行\r\n *\r\n * 設計ポイント:\r\n * - グローバル設定(config)を外部から参照・変更可能\r\n * - 初期化処理の多重実行を防止し、安全な起動を保証\r\n */\r\nimport { registerSingleFileComponents } from \"./WebComponents/registerSingleFIleComponents.js\";\r\nimport { bootstrap } from \"./bootstrap.js\";\r\nimport { config as _config } from \"./WebComponents/getGlobalConfig.js\";\r\nimport { IConfig } from \"./WebComponents/types\";\r\n\r\nexport const config: IConfig = _config;\r\n\r\nlet initialized = false;\r\nexport async function defineComponents(singleFileComponents: Record<string, string>):Promise<void> {\r\n  await registerSingleFileComponents(singleFileComponents);\r\n  if (config.autoInit) {\r\n    await bootstrapStructive();\r\n  }\r\n}\r\n\r\nexport async function bootstrapStructive():Promise<void> {\r\n  if (!initialized) {\r\n    await bootstrap();\r\n    initialized = true;\r\n  }\r\n}\r\n\r\n","/**\r\n * registerSingleFileComponents.ts\r\n *\r\n * 複数のシングルファイルコンポーネント（SFC）をまとめてStructiveのWeb Componentsとして登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - singleFileComponents（tagNameとパスのマップ）を走査し、各SFCを非同期で取得・パース\r\n * - enableRouterが有効な場合はentryRouteでルーティング情報も登録\r\n * - createComponentClassでWeb Componentsクラスを生成し、registerComponentClassでカスタム要素として登録\r\n *\r\n * 設計ポイント:\r\n * - SFCのロードからWeb Components登録、ルーティング登録までを一括で自動化\r\n * - 非同期処理で複数コンポーネントの動的登録に対応\r\n * - ルートパス\"/root\"の正規化や、@routesプレフィックスの除去など柔軟なパス処理\r\n */\r\nimport { entryRoute } from \"../Router/Router.js\";\r\nimport { createComponentClass } from \"./createComponentClass.js\";\r\nimport { config } from \"./getGlobalConfig.js\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent.js\";\r\nimport { registerComponentClass } from \"./registerComponentClass.js\";\r\nimport { IUserComponentData, SingleFileComponents } from \"./types\";\r\n\r\nexport async function registerSingleFileComponents(singleFileComponents:SingleFileComponents):Promise<void> {\r\n  for(const [ tagName, path ] of Object.entries(singleFileComponents)) {\r\n    let componentData : IUserComponentData | null = null;\r\n    if (config.enableRouter) {\r\n      const routePath = path.startsWith(\"@routes\") ? path.slice(7) : path; // remove the prefix 'routes:'\r\n      entryRoute(tagName, routePath === \"/root\" ? \"/\" : routePath); // routing\r\n    }\r\n    componentData = await loadSingleFileComponent(path);\r\n    const componentClass = createComponentClass(componentData);\r\n    registerComponentClass(tagName, componentClass);\r\n  }\r\n}","/**\r\n * bootstrap.ts\r\n *\r\n * Structiveアプリケーションの初期化処理を行うエントリーポイントです。\r\n *\r\n * 主な役割:\r\n * - グローバル設定(config)に従い、必要なコンポーネントやルーター、メインラッパーを登録・初期化\r\n * - autoLoadFromImportMapが有効な場合はimportmapからルートやコンポーネントを動的ロード\r\n * - enableRouterが有効な場合はRouterコンポーネントをカスタム要素として登録\r\n * - enableMainWrapperが有効な場合はMainWrapperをカスタム要素として登録し、autoInsertMainWrapperが有効ならbodyに自動挿入\r\n *\r\n * 設計ポイント:\r\n * - 設定値に応じて初期化処理を柔軟に制御\r\n * - importmapやカスタム要素の登録、DOMへの自動挿入など、Structiveの起動に必要な処理を一元化\r\n */\r\nimport { MainWrapper } from \"./MainWrapper/MainWrapper.js\";\r\nimport { Router } from \"./Router/Router.js\";\r\nimport { config } from \"./WebComponents/getGlobalConfig.js\";\r\nimport { loadFromImportMap } from \"./WebComponents/loadFromImportMap.js\";\r\n\r\nexport async function bootstrap(): Promise<void> {\r\n  if (config.autoLoadFromImportMap) {\r\n    await loadFromImportMap();\r\n  }\r\n\r\n  if (config.enableRouter) {\r\n    customElements.define(config.routerTagName, Router);\r\n  }\r\n\r\n  if (config.enableMainWrapper) {\r\n    customElements.define(config.mainTagName, MainWrapper);\r\n    if (config.autoInsertMainWrapper) {\r\n      const mainWrapper = document.createElement(config.mainTagName);\r\n      document.body.appendChild(mainWrapper);\r\n    }\r\n  }\r\n}"],"names":["globalConfig","debug","locale","enableShadowDom","enableMainWrapper","enableRouter","autoInsertMainWrapper","autoInit","mainTagName","routerTagName","layoutPath","autoLoadFromImportMap","optimizeList","optimizeListElements","optimizeAccessor","getGlobalConfig","config","optionsRequired","fnName","Error","optionMustBeNumber","valueMustBeNumber","valueMustBeDate","builtinFilters","eq","options","opt","value","optValue","Number","isNaN","ne","not","valueMustBeBoolean","lt","le","gt","ge","inc","dec","mul","div","fix","toFixed","toLocaleString","uc","toString","toUpperCase","lc","toLowerCase","cap","v","length","charAt","slice","trim","substr","opt1","opt1Value","opt2","opt2Value","pad","padStart","rep","repeat","rev","split","reverse","join","int","parseInt","float","parseFloat","round","Math","pow","floor","ceil","percent","date","Date","toLocaleDateString","time","toLocaleTimeString","datetime","ymd","year","getFullYear","month","getMonth","day","getDate","falsy","truthy","defaults","boolean","Boolean","number","string","String","null","outputBuiltinFilters","inputBuiltinFilters","id","generateId","raiseError","message","stateClassById","styleSheetById","registerCss","css","styleSheet","CSSStyleSheet","replaceSync","registerStyleSheet","resolveNodeFromPath","root","path","node","i","childNodes","textToFilter","filters","text","filter","name","cache","Map","createFilters","texts","result","get","push","set","BindingNode","binding","decorates","bindContents","this","subName","constructor","init","assignValue","updateElements","listIndexes","values","notifyRedraw","refs","applyChange","renderer","updatedBindings","has","filteredValue","bindingState","getFilteredValue","readonlyState","add","isSelectElement","HTMLSelectElement","isFor","BindingNodeAttribute","super","setAttribute","BindingNodeCheckbox","Array","isArray","element","checked","map","_val","includes","BindingNodeClassList","className","BindingNodeClassName","classList","remove","DATA_BIND_ATTRIBUTE","COMMENT_EMBED_MARK","COMMENT_TEMPLATE_MARK","RESERVED_WORD_SET","Set","_cache","StructuredPathInfo","static","sid","pattern","pathSegments","lastSegment","cumulativePaths","cumulativePathSet","cumulativeInfos","cumulativeInfoSet","wildcardPaths","wildcardPathSet","wildcardInfos","indexByWildcardPath","wildcardInfoSet","wildcardParentPaths","wildcardParentPathSet","wildcardParentInfos","wildcardParentInfoSet","lastWildcardPath","lastWildcardInfo","parentPath","parentInfo","wildcardCount","children","getPattern","_pattern","getStructuredPathInfo","currentPatternPath","prevPatternPath","structuredPath","info","ResolvedPathInfo","elements","paths","wildcardType","wildcardIndexes","tmpPatternElements","incompleteCount","completeCount","lastPath","getResolvedPathInfo","nameInfo","getContextListIndex","handler","ref","refStack","refIndex","listIndex","index","at","getListIndex","resolvedPath","receiver","parentListIndex","wildcardParentPattern","engine","getListIndexes","symbolName","GetByRefSymbol","Symbol","for","SetByRefSymbol","SetCacheableSymbol","ConnectedCallbackSymbol","DisconnectedCallbackSymbol","StatePropertyRef","listIndexRef","deref","key","WeakRef","createRefKey","refByInfoByListIndex","WeakMap","refByInfoByNull","getStatePropertyRef","refByInfo","checkDependency","lastInfo","pathManager","getters","setters","addDynamicDependency","setStatePropertyRef","callback","getByRefWritable","target","stateOutput","startsWith","intersection","size","Reflect","parentRef","parentValue","setByRef","updater","enqueueRef","resolveWritable","prop","indexes","trackDependency","indexByIndexName","getWritable","resolve","wildcardPattern","walkWildcardPattern","wildardIndexPos","indexPos","parentIndexes","results","concat","resultIndexes","resultValues","getAllWritable","to","getRouter","navigate","owner","resolvedInfo","async","call","connectedCallback","disconnectedCallback","StateHandler$1","lastTrackingStack","trackingStack","fill","trackingIndex","loopContext","trapGet","trapSet","useWritableStateProxy","state","StateHandler","stateProxy","Proxy","asyncSetStatePropertyRef","setLoopContext","version","ListIndex","pos","position","dirty","varName","createListIndex","NodePath","currentPath","childNodeByName","level","find","segments","segIndex","currentSegment","childNode","appendChild","childName","findPathNodeByPath","rootNode","nodeCache","cachedNode","addPathNode","parentNode","getByRefReadonly","cacheable","lists","calcListDiff","resolveReadonly","getReadonly","getAllReadonly","setCacheable","createReadonlyStateProxy","Renderer","trackedRefs","listDiffByRef","render","items","clear","renderItem","_newListValue","undefined","isNewValue","listDiff","oldListValue","oldListIndexes","getListAndListIndexes","newListValue","oldIndexes","_oldListValue","_oldIndexes","newIndexes","removes","adds","listIndexByListValue","overwrites","changeIndexes","newValue","newListIndex","delete","saveListAndListIndexes","bindings","getBindings","childInfo","diff","childRef","deps","dynamicDependencies","depPath","depInfo","infos","walk","nextInfo","subListIndex","depRef","depNode","Updater","queue","updating","rendering","queueMicrotask","beginUpdate","update","BindingNodeEvent","addEventListener","e","parentBindContent","currentLoopContext","serialize","context","preventDefault","stopPropagation","func","getValue","apply","createBindingNodeEvent","filterTexts","filterFns","BindingNodeBlock","textContent","BindingNodeIf","bindContent","trueBindContents","falseBindContents","blankRef","createBindContent","mountAfter","unmount","EMPTY_SET","BindingNodeFor","bindContentByListIndex","bindContentPool","bindContentLastIndex","loopInfo","assignListIndex","loopRef","deleteBindContent","clearListIndex","poolLength","loopPath","newBindContents","removeBindContentsSet","isAllRemove","isParentNodeHasOnlyThisNode","parentChildNodes","from","lastContent","firstNode","nodeType","Node","TEXT_NODE","nextSibling","lastNode","previousSibling","getLastNode","append","lastBindContent","isAllAppend","fragmentParentNode","document","createDocumentFragment","fragmentFirstNode","firstChildNode","beforeNode","insertBefore","createBindingNodeFor","DEFAULT_PROPERTY","defaultPropertyByElementType","radio","checkbox","button","getDefaultPropertyByNodeType","HTMLElement","HTMLTextAreaElement","HTMLOptionElement","HTMLButtonElement","HTMLAnchorElement","HTMLFormElement","HTMLInputElement","type","SVGElement","Text","Template","defaultEventByName","selected","BindingNodeProperty","defaultName","getDefaultName","eventName","updateStateValue","createBindingNodeProperty","BindingNodeRadio","BindingNodeStyle","style","setProperty","AssignStateSymbol","NotifyRedrawSymbol","parentStructiveComponentByStructiveComponent","BindingNodeComponent","parentComponent","component","bindingsByComponent","notifyRefs","thisAt","newRef","nodePropertyConstructorByNameByIsComment","class","if","nodePropertyConstructorByFirstName","attr","getBindingNodeCreator","propertyName","isComment","Comment","isElement","Element","fn","bindingNodeCreatorByName","nameElements","bindingNodeCreatorByFirstName","_getBindingNodeCreator","BindingState","saveBinding","writeState","BindingStateIndex","indexNumber","bindingsByListIndex","ereg","RegExp","getBindingStateCreator","test","createBindingStateIndex","createBindingState","nodeTypeByNodeKey","getNodeType","nodeKey","createNodeKey","getNodeTypeByNode","s","re","decode","m","exec","decodeURIComponent","parseFilter","parseProperty","property","parseExpressions","expression","bindExpression","decoratesExpression","nodePropertyText","statePropertyText","nodeProperty","inputFilterTexts","stateProperty","outputFilterTexts","parseExpression","removeAttributeFromElement","removeAttribute","removeAttributeByNodeType","replaceTextNodeFn","textNode","createTextNode","replaceChild","DataBindAttributes","nodePath","bindTexts","creatorByText","getAttribute","getTemplateById","getDataBindText","removeDataBindAttribute","replaceTextNodeFromComment","routeIndexes","indexOf","getAbsoluteNodePath","parseBindText","bindText","creator","createBindingNode","getNodesHavingDataBind","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","SHOW_COMMENT","acceptNode","hasAttribute","FILTER_ACCEPT","FILTER_SKIP","isCommentNode","nextNode","currentNode","listDataBindAttributesById","listPathsSetById","pathsSetById","getDataBindAttributesFromTemplate","content","createDataBindAttributes","templateById","registerTemplate","template","rootId","forEach","nodeValue","removeChild","dataBindAttributes","listPaths","attribute","j","registerDataBindAttributes","Binding","bindingNode","inputFilters","outputFilters","createBinding","LoopContext","parentLoopContext","currentBindContent","parentBinding","unshift","createContent","fragment","importNode","Object","keys","lazyLoadComponentAliasByTagName","lazyLoadElements","querySelectorAll","loadLazyLoadComponent","tagName","createBindings","attributes","getDataBindAttributesById","BindContent","isMounted","lastChildNode","lastBinding","mount","mountBefore","afterNode","parentElement","attachShadow","extends","createElement","mode","canHaveShadowRoot","shadowRoot","adoptedStyleSheets","shadowRootOrDocument","ShadowRoot","getParentShadowRoot","styleSheets","ComponentStateBinding","parentPaths","childPaths","childPathByParentPath","parentPathByChildPath","bindingByParentPath","bindingByChildPath","WeakSet","addBinding","childPath","getChildPath","getParentPath","toParentPathFromChildPath","matchPaths","matchPathArray","longestMatchPath","remainPath","matchParentPath","toChildPathFromParentPath","matchChildPath","startsWithByChildPath","childPathInfo","matches","bind","childComponent","getBindingsFromChild","ComponentStateInputHandler","componentStateBinding","assignState","object","entries","parentPathRef","childListIndex","getPropertyValue","setPropertyValue","ComponentStateOutput","pathInfo","parentPathInfo","ComponentEngine","stateClass","baseClass","structiveChildComponents","waitForInitialize","Promise","withResolvers","waitForDisconnected","stateBinding","createComponentStateBinding","stateInput","blockPlaceholder","blockParentNode","ignoreDissconnectedCallback","componentClass","createComponentStateInput","setup","alls","rootRef","promise","parentStructiveComponent","dataset","json","JSON","parse","registerChildComponent","enableWebComponents","createComment","replaceWith","funcs","unregisterChildComponent","saveInfoByStructuredPathId","saveInfoByResolvedPathInfoIdByListIndex","createSaveInfo","list","getSaveInfoByStatePropertyRef","saveInfo","saveInfoByResolvedPathInfoId","saveListIndexes","saveList","getList","MUSTACHE_REGEXP","MUSTACHE_TYPES","SVG_NS","replaceTemplateTagWithComment","namespaceURI","newTemplate","registerHtml","html","innerHTML","stack","replaceAll","match","expr","remain","currentInfo","endTags","pop","replaceMustacheWithTemplateTag","checkSegmentRegexp","checkPathRegexp","createAccessorFunctions","len","matchPath","curPath","matchInfo","count","segment","Function","PathManager","optimizes","staticDependencies","createRootNode","getPathsSetById","union","getListPathsSetById","listPath","elementPath","currentProto","prototype","getOwnPropertyDescriptors","desc","hasGetter","hasSetter","getPrototypeOf","defineProperty","enumerable","configurable","source","createComponentClass","componentData","componentConfig","userConfig","Dn","getComponentConfig","$config","Me","Ee","assign","$isStructive","registerStateClass","extendTagName","getBaseClass","createComponentEngine","el","isStructive","define","customElements","getStyleSheetById","getStateClassById","unescapeEmbed","loadSingleFileComponent","response","fetch","escapeEmbed","querySelector","script","b64","btoa","fromCodePoint","TextEncoder","encode","scriptModule","import","default","createSingleFileComponent","registerComponentClass","ROUTES_KEY","COMPONENTS_KEY","LAZY_LOAD_SUFFIX","loadFromImportMap","importmap","scriptImportmap","imports","loadImportmap","loadAliasByTagName","alias","isLazyLoad","endsWith","replace","entryRoute","console","warn","ROUTE_PATH_PREFIX","routeEntries","globalRouter","Router","originalPathName","window","location","pathname","originalFileName","basePath","href","origin","_popstateHandler","popstateHandler","dispatchEvent","Event","removeEventListener","event","toPath","history","pushState","n","replacedPath","params","tag","regex","substring","customElement","stringify","hasOwnProperty","isLazyLoadComponent","messageElement","routePath","SLOT_KEY","DEFAULT_LAYOUT","MainWrapper","loadLayout","ok","layoutText","workTemplate","router","_config","initialized","defineComponents","singleFileComponents","registerSingleFileComponents","bootstrapStructive","mainWrapper","body","bootstrap"],"mappings":"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"}