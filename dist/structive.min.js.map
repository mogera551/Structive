{"version":3,"file":"structive.min.js","sources":["../src/Router/Router.ts","../src/WebComponents/getGlobalConfig.ts","../src/Filter/errorMessages.ts","../src/Filter/builtinFilters.ts","../src/GlobalId/generateId.ts","../src/utils.ts","../src/StateClass/registerStateClass.ts","../src/StyleSheet/registerStyleSheet.ts","../src/StyleSheet/regsiterCss.ts","../src/BindingBuilder/createFilters.ts","../src/DataBinding/BindingNode/BindingNode.ts","../src/DataBinding/BindingNode/BindingNodeAttribute.ts","../src/DataBinding/BindingNode/BindingNodeCheckbox.ts","../src/DataBinding/BindingNode/BindingNodeClassList.ts","../src/DataBinding/BindingNode/BindingNodeClassName.ts","../src/DataBinding/BindingNode/BindingNodeEvent.ts","../src/constants.ts","../src/DataBinding/BindingNode/BindingNodeBlock.ts","../src/DataBinding/BindingNode/BindingNodeIf.ts","../src/DataBinding/BindingNode/BindingNodeFor.ts","../src/BindingBuilder/getDefaultName.ts","../src/DataBinding/BindingNode/BindingNodeProperty.ts","../src/DataBinding/BindingNode/BindingNodeRadio.ts","../src/DataBinding/BindingNode/BindingNodeStyle.ts","../src/ComponentState/symbols.ts","../src/DataBinding/BindingNode/BindingNodeComponent.ts","../src/BindingBuilder/getBindingNodeCreator.ts","../src/StateClass/symbols.ts","../src/StateProperty/getStructuredPathInfo.ts","../src/DataBinding/BindingState/BindingState.ts","../src/DataBinding/BindingState/BindingStateIndex.ts","../src/BindingBuilder/getBindingStateCreator.ts","../src/BindingBuilder/getNodeType.ts","../src/BindingBuilder/parseBindText.ts","../src/BindingBuilder/removeDataBindAttribute.ts","../src/BindingBuilder/replaceTextNodeFromComment.ts","../src/BindingBuilder/createDataBindAttributes.ts","../src/BindingBuilder/getDataBindText.ts","../src/BindingBuilder/getAbsoluteNodePath.ts","../src/BindingBuilder/getNodesHavingDataBind.ts","../src/BindingBuilder/registerDataBindAttributes.ts","../src/Template/registerTemplate.ts","../src/Template/removeEmptyTextNodes.ts","../src/DataBinding/Binding.ts","../src/LoopContext/createLoopContext.ts","../src/Updater/render.ts","../src/DataBinding/BindContent.ts","../src/BindingBuilder/resolveNodeFromPath.ts","../src/DependencyWalker/createDependencyEdge.ts","../src/DependencyWalker/createDependencyWalker.ts","../src/ListIndex/createListIndex.ts","../src/ListWalker/listWalker.ts","../src/StatePropertyRef/getStatePropertyRef.ts","../src/Updater/restructListIndex.ts","../src/Updater/updater.ts","../src/ComponentEngine/attachShadow.ts","../src/ComponentEngine/canHaveShadowRoot.ts","../src/StateClass/buildListIndexTree.ts","../src/StateProperty/getResolvedPathInfo.ts","../src/StateClass/methods/getContextListIndex.ts","../src/StateClass/methods/getListIndex.ts","../src/StateClass/methods/setStatePropertyRef.ts","../src/StateClass/methods/setTracking.ts","../src/StateClass/methods/getByRefReadonly.ts","../src/StateClass/apis/resolveReadonly.ts","../src/StateClass/apis/trackDependency.ts","../src/StateClass/traps/getReadonly.ts","../src/StateClass/apis/getAllReadonly.ts","../src/StateClass/methods/setCacheable.ts","../src/StateClass/createReadonlyStateProxy.ts","../src/StateClass/methods/getByRefWritable.ts","../src/StateClass/methods/setByRef.ts","../src/StateClass/apis/resolveWritable.ts","../src/StateClass/traps/getWritable.ts","../src/StateClass/apis/getAllWritable.ts","../src/StateClass/apis/connectedCallback.ts","../src/StateClass/apis/disconnectedCallback.ts","../src/StateClass/useWritableStateProxy.ts","../src/StateClass/traps/set.ts","../src/StateClass/methods/setLoopContext.ts","../src/StateClass/methods/asyncSetStatePropertyRef.ts","../src/ComponentEngine/ComponentEngine.ts","../src/Template/replaceMustacheWithTemplateTag.ts","../src/Template/replaceTemplateTagWithComment.ts","../src/Template/registerHtml.ts","../src/ComponentState/createComponentState.ts","../src/StateProperty/createAccessorFunctions.ts","../src/WebComponents/createComponentClass.ts","../src/WebComponents/getComponentConfig.ts","../src/WebComponents/getBaseClass.ts","../src/WebComponents/createSingleFileComponent.ts","../src/WebComponents/loadSingleFileComponent.ts","../src/WebComponents/registerComponentClass.ts","../src/MainWrapper/MainWrapper.ts","../src/WebComponents/loadFromImportMap.ts","../src/WebComponents/loadImportmap.ts","../src/exports.ts","../src/WebComponents/registerSingleFIleComponents.ts","../src/bootstrap.ts"],"sourcesContent":["/**\r\n * Router.ts\r\n *\r\n * シングルページアプリケーション（SPA）向けのカスタムエレメント Router の実装です。\r\n *\r\n * 主な役割:\r\n * - ルート定義（entryRoute）に基づき、URLパスに応じてカスタム要素を動的に生成・表示\r\n * - pushState/popstateイベントを利用した履歴管理とルーティング制御\r\n * - ルートパラメータの抽出とカスタム要素への受け渡し\r\n * - 404ページ（未定義ルート時）の表示\r\n *\r\n * 設計ポイント:\r\n * - entryRouteでルートパスとカスタム要素タグ名のペアを登録\r\n * - popstateイベントでURL変更時に自動で再描画\r\n * - ルートパスのパラメータ（:id等）も正規表現で抽出し、data-state属性で渡す\r\n * - getRouterでグローバルなRouterインスタンスを取得可能\r\n */\r\nimport { IRouter } from \"./types\";\r\n\r\nconst DEFAULT_ROUTE_PATH = '/'; // Default route path\r\nconst ROUTE_PATH_PREFIX = 'routes:'; // Prefix for route paths\r\n/**\r\n * example:\r\n * ```ts\r\n * entryRoute('my-view', '/my-view/:id');\r\n */\r\nconst routeEntries: Array<[string, string]> = [];\r\n\r\nlet globalRouter : Router | null = null;\r\n\r\nexport class Router extends HTMLElement implements IRouter {\r\n  _popstateHandler: (event: PopStateEvent) => void;\r\n  constructor() {\r\n    super();\r\n    this._popstateHandler = this.popstateHandler.bind(this);\r\n  }\r\n\r\n  connectedCallback() {\r\n    globalRouter = this;\r\n    this.innerHTML = '<slot name=\"content\"></slot>';\r\n    window.addEventListener('popstate', this._popstateHandler);\r\n    window.dispatchEvent(new Event(\"popstate\")); // Dispatch popstate event to trigger the initial render\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    window.removeEventListener('popstate', this._popstateHandler);\r\n    globalRouter = null;\r\n  }\r\n\r\n  popstateHandler(event: PopStateEvent) {\r\n    event.preventDefault();\r\n    this.render();\r\n  }\r\n\r\n  navigate(to: string) {\r\n    history.pushState({}, '', to);\r\n    this.render();\r\n  }\r\n\r\n  render() {\r\n    // スロットコンテントをクリア\r\n    const slotChildren = Array.from(this.childNodes).filter(\r\n      n => (n as HTMLElement).getAttribute?.('slot') === 'content'\r\n    );\r\n    slotChildren.forEach(n => this.removeChild(n));\r\n\r\n    const routePath = window.location.pathname || DEFAULT_ROUTE_PATH;\r\n    let tagName: string | undefined = undefined;\r\n    let params: Record<string, string> = {};\r\n    // Check if the routePath matches any of the defined routes\r\n    for (const [path, tag] of routeEntries) {\r\n      const regex = new RegExp(path.replace(/:[^\\s/]+/g, '([^/]+)'));\r\n      if (regex.test(routePath)) {\r\n        tagName = tag;\r\n        // Extract the parameters from the routePath\r\n        const matches = routePath.match(regex);\r\n        if (matches) {\r\n          const keys = path.match(/:[^\\s/]+/g) || [];\r\n          keys.forEach((key, index) => {\r\n            params[key.substring(1)] = matches[index + 1]; // +1 to skip the full match\r\n          });\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    if (tagName) {\r\n      // If a route matches, create the custom element and set its state\r\n      // Create the custom element with the tag name\r\n      // project the custom element into the router slot\r\n      const customElement = document.createElement(tagName) as HTMLElement;\r\n      customElement.setAttribute('data-state', JSON.stringify(params));\r\n      customElement.setAttribute('slot', 'content');\r\n      this.appendChild(customElement);\r\n    } else {\r\n      // If no route matches, show 404 content\r\n      const messageElement = document.createElement('h1') as HTMLElement;\r\n      messageElement.setAttribute('slot', 'content');\r\n      messageElement.textContent = '404 Not Found';\r\n      this.appendChild(messageElement);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport function entryRoute(tagName: string, routePath: string): void {\r\n  if (routePath.startsWith(ROUTE_PATH_PREFIX)) {\r\n    routePath = routePath.substring(ROUTE_PATH_PREFIX.length); // Remove 'routes:' prefix\r\n  }\r\n  routeEntries.push([routePath, tagName]);\r\n}\r\n\r\nexport function getRouter(): Router | null {\r\n  return globalRouter;\r\n}\r\n\r\n","/**\r\n * getGlobalConfig.ts\r\n *\r\n * Structive全体で利用するグローバル設定（IConfig）を定義・取得するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - globalConfig: デフォルトのグローバル設定値（debug, locale, enableShadowDom等）を定義\r\n * - getGlobalConfig: グローバル設定オブジェクトを返す関数\r\n * - config: getGlobalConfig()のエイリアスとして即時取得用にエクスポート\r\n *\r\n * 設計ポイント:\r\n * - コンポーネント全体で共通利用する設定値を一元管理\r\n * - デフォルト値を明示し、拡張やカスタマイズにも対応しやすい設計\r\n */\r\nimport { IConfig } from \"./types\";\r\n\r\nconst globalConfig: IConfig = {\r\n  \"debug\"                : false,\r\n  \"locale\"               : \"en-US\", // The locale of the component, ex. \"en-US\", default is \"en-US\"\r\n  \"enableShadowDom\"      : true,\r\n  \"enableMainWrapper\"    : true, // Whether to use the main wrapper or not\r\n  \"enableRouter\"         : true, // Whether to use the router or not\r\n  \"autoInsertMainWrapper\": false, // Whether to automatically insert the main wrapper or not\r\n  \"autoInit\"             : true, // Whether to automatically initialize the component or not\r\n  \"mainTagName\"          : \"app-main\", // The tag name of the main wrapper, default is \"app-main\"\r\n  \"routerTagName\"        : \"view-router\", // The tag name of the router, default is \"view-router\"\r\n  \"layoutPath\"           : \"\", // The path to the layout file, default is \"\"\r\n  \"autoLoadFromImportMap\": false, // Whether to automatically load the component from the import map or not\r\n  \"optimizeList\"         : true, // Whether to optimize the list or not\r\n  \"optimizeListElements\" : true, // Whether to optimize the list elements or not\r\n  \"optimizeAccessor\"     : true, // Whether to optimize the accessors or not\r\n};\r\n\r\n\r\nexport function getGlobalConfig():IConfig {\r\n  return globalConfig;\r\n}\r\n\r\nexport const config = getGlobalConfig();\r\n","/**\r\n * errorMessages.ts\r\n *\r\n * フィルタ関数などで利用するエラーメッセージ生成ユーティリティです。\r\n *\r\n * 主な役割:\r\n * - フィルタのオプションや値の型チェックで条件を満たさない場合に、分かりやすいエラーメッセージを投げる\r\n * - 関数名を引数に取り、どのフィルタでエラーが発生したかを明示\r\n *\r\n * 設計ポイント:\r\n * - optionsRequired: オプションが必須なフィルタで未指定時にエラー\r\n * - optionMustBeNumber: オプション値が数値でない場合にエラー\r\n * - valueMustBeNumber: 値が数値でない場合にエラー\r\n * - valueMustBeBoolean: 値がbooleanでない場合にエラー\r\n * - valueMustBeDate: 値がDateでない場合にエラー\r\n */\r\nexport function optionsRequired(fnName:string): never {\r\n  throw new Error(`${fnName} requires at least one option`);\r\n}\r\n\r\nexport function optionMustBeNumber(fnName:string): never {\r\n  throw new Error(`${fnName} requires a number as option`);\r\n}\r\n\r\nexport function valueMustBeNumber(fnName:string): never {\r\n  throw new Error(`${fnName} requires a number value`);\r\n}\r\n\r\nexport function valueMustBeBoolean(fnName:string): never {\r\n  throw new Error(`${fnName} requires a boolean value`);\r\n}\r\n\r\nexport function valueMustBeDate(fnName:string): never {\r\n  throw new Error(`${fnName} requires a date value`);\r\n}","/**\r\n * builtinFilters.ts\r\n *\r\n * Structiveで利用可能な組み込みフィルタ関数群の実装ファイルです。\r\n *\r\n * 主な役割:\r\n * - 数値・文字列・日付・真偽値などの変換・比較・整形・判定用フィルタを提供\r\n * - フィルタ名ごとにオプション付きの関数を定義し、バインディング時に柔軟に利用可能\r\n * - input/output両方のフィルタとして共通利用できる設計\r\n *\r\n * 設計ポイント:\r\n * - eq, ne, lt, gt, inc, fix, locale, uc, lc, cap, trim, slice, pad, int, float, round, date, time, ymd, falsy, truthy, defaults, boolean, number, string, null など多彩なフィルタを網羅\r\n * - オプション値の型チェックやエラーハンドリングも充実\r\n * - FilterWithOptions型でフィルタ関数群を一元管理し、拡張も容易\r\n * - builtinFilterFnでフィルタ名・オプションからフィルタ関数を動的に取得可能\r\n */\r\nimport { getGlobalConfig } from \"../WebComponents/getGlobalConfig.js\";\r\nimport { optionMustBeNumber, optionsRequired, valueMustBeBoolean, valueMustBeDate, valueMustBeNumber } from \"./errorMessages.js\";\r\nimport { FilterWithOptions } from \"./types\";\r\n\r\nconst config = getGlobalConfig();\r\n\r\nconst eq = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('eq');\r\n  return (value: any) => {\r\n    // 型を揃えて比較\r\n    if (typeof value === 'number') {\r\n      const optValue = Number(opt);\r\n      if (isNaN(optValue)) optionMustBeNumber('eq');\r\n      return value === optValue;\r\n    }\r\n    if (typeof value === 'string') {\r\n      return value === opt;\r\n    }\r\n    // その他は厳密等価\r\n    return value === opt;\r\n  }\r\n}\r\n\r\nconst ne = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('ne');\r\n  return (value: any) => {\r\n    // 型を揃えて比較\r\n    if (typeof value === 'number') {\r\n      const optValue = Number(opt);\r\n      if (isNaN(optValue)) optionMustBeNumber('eq');\r\n      return value !== optValue;\r\n    }\r\n    if (typeof value === 'string') {\r\n      return value !== opt;\r\n    }\r\n    // その他は厳密等価\r\n    return value !== opt;\r\n  }\r\n}\r\n\r\nconst not = (options?:string[]) => {\r\n  return (value: any) => {\r\n    if (typeof value !== 'boolean') valueMustBeBoolean('not');\r\n    return !value;\r\n  }\r\n}\r\n\r\nconst lt = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('lt');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('lt');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('lt');\r\n    return value < optValue;\r\n  }\r\n}\r\n\r\nconst le = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('le');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('le');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('le');\r\n    return value <= optValue;\r\n  }\r\n}\r\n\r\nconst gt = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('gt');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('gt');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('gt');\r\n    return value > optValue;\r\n  }\r\n}\r\n\r\nconst ge = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('ge');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('ge');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ge');\r\n    return value >= optValue;\r\n  }\r\n}\r\n\r\nconst inc = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('inc');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('inc');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('inc');\r\n    return value + optValue;\r\n  }\r\n}\r\n\r\nconst dec = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('dec');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('dec');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('dec');\r\n    return value - optValue;\r\n  }\r\n}\r\n\r\nconst mul = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('mul');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('mul');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('mul');\r\n    return value * optValue;\r\n  }\r\n}\r\n\r\nconst div = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('div');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('div');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('div');\r\n    return value / optValue;\r\n  }\r\n}\r\n\r\nconst fix = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('div');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('div');\r\n    return value.toFixed(optValue);\r\n  }\r\n}\r\n\r\nconst locale = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('locale');\r\n    return value.toLocaleString(opt);\r\n  }\r\n}\r\n\r\nconst uc = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().toUpperCase();\r\n  }\r\n}\r\n\r\nconst lc = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().toLowerCase();\r\n  }\r\n}\r\n\r\nconst cap = (options?:string[]) => {\r\n  return (value: any) => {\r\n    const v = value.toString();\r\n    if (v.length === 0) return v;\r\n    if (v.length === 1) return v.toUpperCase();\r\n    return v.charAt(0).toUpperCase() + v.slice(1);\r\n  }\r\n}\r\n\r\nconst trim = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().trim();\r\n  }\r\n}\r\n\r\nconst slice = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('slice');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('slice');\r\n  return (value: any) => {\r\n    return value.toString().slice(optValue);\r\n  }\r\n}\r\n\r\nconst substr = (options?:string[]) => {\r\n  const opt1 = options?.[0] ?? optionsRequired('substr');\r\n  const opt1Value = Number(opt1);\r\n  if (isNaN(opt1Value)) optionMustBeNumber('substr');\r\n  const opt2 = options?.[1] ?? optionsRequired('substr');\r\n  const opt2Value = Number(opt2);\r\n  if (isNaN(opt2Value)) optionMustBeNumber('substr');\r\n  return (value: any) => {\r\n    return value.toString().substr(opt1Value, opt2Value);\r\n  }\r\n}\r\n\r\nconst pad = (options?:string[]) => {\r\n  const opt1 = options?.[0] ?? optionsRequired('pad');\r\n  const opt1Value = Number(opt1);\r\n  if (isNaN(opt1Value)) optionMustBeNumber('pad');\r\n  const opt2 = options?.[1] ?? '0';\r\n  const opt2Value = opt2;\r\n  return (value: any) => {\r\n    return value.toString().padStart(opt1Value, opt2Value);\r\n  }\r\n}\r\n\r\nconst rep = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('rep');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('rep');\r\n  return (value: any) => {\r\n    return value.toString().repeat(optValue);\r\n  }\r\n}\r\n\r\nconst rev = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().split('').reverse().join('');\r\n  }\r\n}\r\n\r\nconst int = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return parseInt(value, 10);\r\n  }\r\n}\r\n\r\nconst float = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return parseFloat(value);\r\n  }\r\n}\r\n\r\nconst round = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('round');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('round');\r\n    return Math.round(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst floor = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('floor');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('floor');\r\n    return Math.floor(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst ceil = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('ceil');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ceil');\r\n    return Math.ceil(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst percent = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('percent');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('percent');\r\n    return value.toFixed(optValue) + '%';\r\n  }\r\n}\r\n\r\nconst date = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date))  valueMustBeDate('date');\r\n    return value.toLocaleDateString(config.locale);\r\n  }\r\n}\r\n\r\nconst time = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('time');\r\n    return value.toLocaleTimeString(config.locale);\r\n  }\r\n}\r\n\r\nconst datetime = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('datetime');\r\n    return value.toLocaleString(config.locale);\r\n  }\r\n}\r\n\r\nconst ymd = (options?:string[]) => {\r\n  const opt = options?.[0] ?? '-';\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('ymd');\r\n    const year = value.getFullYear().toString();\r\n    const month = (value.getMonth() + 1).toString().padStart(2, '0');\r\n    const day = value.getDate().toString().padStart(2, '0');\r\n    return `${year}${opt}${month}${opt}${day}`;\r\n  }\r\n}\r\n\r\nconst falsy = (options?:string[]) => {\r\n  return (value: any) => value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value);\r\n}\r\n\r\nconst truthy = (options?:string[]) => {\r\n  return (value: any) =>value !== false && value !== null && value !== undefined && value !== 0 && value !== '' && !Number.isNaN(value);\r\n}\r\n\r\nconst defaults = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('defaults');\r\n  return (value: any) => {\r\n    if (value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value)) return opt;\r\n    return value;\r\n  }\r\n}\r\n\r\nconst boolean = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return Boolean(value);\r\n  }\r\n}\r\n\r\nconst number = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return Number(value);\r\n  }\r\n}\r\n\r\nconst string = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return String(value);\r\n  }\r\n}\r\n\r\nconst _null = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return (value === \"\") ? null : value;\r\n  } \r\n}\r\n\r\nconst builtinFilters: FilterWithOptions = {\r\n  \"eq\": eq,\r\n  \"ne\": ne,\r\n  \"not\": not,\r\n\r\n  \"lt\": lt,\r\n  \"le\": le,\r\n  \"gt\": gt,\r\n  \"ge\": ge,\r\n\r\n  \"inc\": inc,\r\n  \"dec\": dec,\r\n  \"mul\": mul,\r\n  \"div\": div,\r\n\r\n  \"fix\": fix,\r\n  \"locale\": locale,\r\n  \"uc\": uc,\r\n  \"lc\": lc,\r\n  \"cap\": cap,\r\n  \"trim\": trim,\r\n  \"slice\": slice,\r\n  \"substr\": substr,\r\n  \"pad\": pad,\r\n  \"rep\": rep,\r\n  \"rev\": rev,\r\n\r\n  \"int\": int,\r\n  \"float\": float,\r\n  \"round\": round,\r\n  \"floor\": floor,\r\n  \"ceil\": ceil,\r\n  \"percent\": percent,\r\n\r\n  \"date\": date,\r\n  \"time\": time,\r\n  \"datetime\": datetime,\r\n  \"ymd\": ymd,\r\n\r\n  \"falsy\": falsy,\r\n  \"truthy\": truthy,\r\n  \"defaults\": defaults,\r\n\r\n  \"boolean\": boolean,\r\n  \"number\": number,\r\n  \"string\": string,\r\n  \"null\": _null,\r\n};\r\n\r\nexport const outputBuiltinFilters = builtinFilters;\r\nexport const inputBuiltinFilters = builtinFilters;\r\n\r\nexport const builtinFilterFn = (name:string, options: string[]) => (filters: FilterWithOptions) => {\r\n  const filter = filters[name];\r\n  if (!filter) throw new Error(`outputBuiltinFiltersFn: filter not found: ${name}`);\r\n  return filter(options);\r\n}\r\n\r\n","\r\nlet id = 0;\r\n\r\nexport function generateId(): number {\r\n  return ++id;\r\n}","\r\nexport function raiseError(message: string): never {\r\n  throw new Error(message);\r\n}\r\n","/**\r\n * registerStateClass.ts\r\n *\r\n * StateClassインスタンスをIDで登録・取得するための管理モジュールです。\r\n *\r\n * 主な役割:\r\n * - stateClassById: IDをキーにStateClassインスタンスを管理するレコード\r\n * - registerStateClass: 指定IDでStateClassインスタンスを登録\r\n * - getStateClassById: 指定IDのStateClassインスタンスを取得（未登録時はエラーを投げる）\r\n *\r\n * 設計ポイント:\r\n * - グローバルにStateClassインスタンスを一元管理し、ID経由で高速にアクセス可能\r\n * - 存在しないIDアクセス時はraiseErrorで明確な例外を発生\r\n */\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IStructiveState } from \"./types\";\r\n\r\nconst stateClassById: Record<number,IStructiveState> = {};\r\n\r\nexport function registerStateClass(id: number, stateClass: IStructiveState) {\r\n  stateClassById[id] = stateClass;\r\n}\r\n\r\nexport function getStateClassById(id: number): IStructiveState {\r\n  return stateClassById[id] ?? raiseError(`getStateClassById: stateClass not found: ${id}`);\r\n}\r\n","/**\r\n * registerStyleSheet.ts\r\n *\r\n * CSSStyleSheetインスタンスをIDで登録・取得するための管理モジュールです。\r\n *\r\n * 主な役割:\r\n * - styleSheetById: IDをキーにCSSStyleSheetインスタンスを管理するレコード\r\n * - registerStyleSheet: 指定IDでCSSStyleSheetインスタンスを登録\r\n * - getStyleSheetById: 指定IDのCSSStyleSheetインスタンスを取得（未登録時はエラーを投げる）\r\n *\r\n * 設計ポイント:\r\n * - グローバルにCSSStyleSheetインスタンスを一元管理し、ID経由で高速にアクセス可能\r\n * - 存在しないIDアクセス時はraiseErrorで明確な例外を発生\r\n */\r\nimport { raiseError } from \"../utils.js\";\r\n\r\nconst styleSheetById: Record<number,CSSStyleSheet> = {};\r\n\r\nexport function registerStyleSheet(id: number, css: CSSStyleSheet) {\r\n  styleSheetById[id] = css;\r\n}\r\n\r\nexport function getStyleSheetById(id: number): CSSStyleSheet {\r\n  return styleSheetById[id] ?? raiseError(`getStyleSheetById: stylesheet not found: ${id}`);\r\n}","/**\r\n * regsiterCss.ts\r\n *\r\n * CSS文字列をCSSStyleSheetとして生成し、IDで登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - CSS文字列からCSSStyleSheetインスタンスを生成\r\n * - registerStyleSheetを利用して、指定IDでCSSStyleSheetを登録\r\n *\r\n * 設計ポイント:\r\n * - styleSheet.replaceSyncで同期的にCSSを適用\r\n * - グローバルなスタイル管理や動的スタイル適用に利用可能\r\n */\r\nimport { registerStyleSheet } from \"./registerStyleSheet.js\";\r\n\r\nexport function registerCss(id: number, css: string) {\r\n  const styleSheet = new CSSStyleSheet();\r\n  styleSheet.replaceSync(css);\r\n  registerStyleSheet(id, styleSheet);\r\n}","import { FilterFn, Filters, FilterWithOptions } from \"../Filter/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IFilterText } from \"./types\";\r\n\r\n/**\r\n * フィルターテキスト（nameとoptionsを持つ）から、実際のフィルター関数（FilterFn）を生成する。\r\n * \r\n * - textToFilter: フィルターテキストから対応するフィルター関数を取得し、オプションを適用して返す。\r\n * - createFilters: フィルターテキスト配列からフィルター関数配列を生成し、同じ入力にはキャッシュを利用する。\r\n */\r\nfunction textToFilter(filters:FilterWithOptions, text: IFilterText): FilterFn {\r\n  const filter = filters[text.name];\r\n  if (!filter) raiseError(`outputBuiltinFiltersFn: filter not found: ${name}`);\r\n  return filter(text.options);\r\n}\r\n\r\nconst cache : Map<IFilterText[], Filters> = new Map();\r\n\r\n/**\r\n * フィルターテキスト配列（texts）からフィルター関数配列（Filters）を生成する。\r\n * すでに同じtextsがキャッシュされていればそれを返す。\r\n * \r\n * @param filters フィルター名→関数の辞書\r\n * @param texts   フィルターテキスト配列\r\n * @returns       フィルター関数配列\r\n */\r\nexport function createFilters(filters:FilterWithOptions, texts: IFilterText[]): Filters {\r\n  let result = cache.get(texts);\r\n  if (typeof result === \"undefined\") {\r\n    result = [];\r\n    for(let i = 0; i < texts.length; i++) {\r\n      result.push(textToFilter(filters, texts[i]));\r\n    }\r\n    cache.set(texts, result);\r\n  }\r\n  return result;\r\n}\r\n","import { Filters } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { IBindingNode } from \"./types\";\r\n\r\n/**\r\n * BindingNodeクラスは、1つのバインディング対象ノード（ElementやTextなど）に対する\r\n * バインディング処理の基底クラスです。\r\n *\r\n * 主な役割:\r\n * - ノード・プロパティ名・フィルタ・デコレータ・バインディング情報の保持\r\n * - バインディング値の更新（update）、値の割り当て（assignValue）のインターフェース提供\r\n * - 複数バインド内容（bindContents）の管理\r\n * - サブクラスでassignValueやupdateElementsを実装し、各種ノード・プロパティごとのバインディング処理を拡張\r\n *\r\n * 設計ポイント:\r\n * - assignValue, updateElementsは未実装（サブクラスでオーバーライド必須）\r\n * - isSelectElement, value, filteredValue, isForなどはサブクラスで用途に応じて拡張\r\n * - フィルタやデコレータ、バインド内容の管理も柔軟に対応\r\n */\r\nexport class BindingNode implements IBindingNode {\r\n  #binding: IBinding;\r\n  #node: Node;\r\n  #name: string;\r\n  #filters: Filters;\r\n  #decorates: string[];\r\n  #bindContents: Set<IBindContent> = new Set<IBindContent>();\r\n  get node(): Node {\r\n    return this.#node;\r\n  }\r\n  get name(): string {\r\n    return this.#name;\r\n  }\r\n  get subName(): string {\r\n    return this.#name;\r\n  }\r\n  get binding(): IBinding {\r\n    return this.#binding;\r\n  }\r\n  get decorates(): string[] {\r\n    return this.#decorates;\r\n  }\r\n  get filters(): Filters {\r\n    return this.#filters;\r\n  }\r\n  get bindContents(): Set<IBindContent> {\r\n    return this.#bindContents;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    this.#binding = binding;\r\n    this.#node = node;\r\n    this.#name = name;\r\n    this.#filters = filters;\r\n    this.#decorates = decorates;\r\n  }\r\n  init():void {\r\n    // サブクラスで初期化処理を実装可能\r\n  }\r\n  update(): void {\r\n    this.assignValue(this.binding.bindingState.filteredValue);\r\n  }\r\n  assignValue(value: any): void {\r\n    raiseError(`BindingNode: assignValue not implemented`);\r\n  }\r\n  updateElements(listIndexes: IListIndex[], values: any[]) {\r\n    raiseError(`BindingNode: updateElements not implemented`);\r\n  }\r\n  get isSelectElement(): boolean {\r\n    return this.node instanceof HTMLSelectElement;\r\n  }\r\n  get value():any {\r\n    return null;\r\n  }\r\n  get filteredValue():any {\r\n    return null;\r\n  }\r\n  get isFor(): boolean {\r\n    return false;\r\n  }\r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeAttributeクラスは、属性バインディング（例: attr.src, attr.alt など）を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - ノード属性名（subName）を抽出し、値を属性としてElementにセット\r\n * - null/undefined/NaNの場合は空文字列に変換してセット\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - nameから属性名（subName）を抽出（例: \"attr.src\" → \"src\"）\r\n * - assignValueで属性値を常に文字列として設定\r\n * - createBindingNodeAttributeファクトリでフィルタ適用済みインスタンスを生成\r\n */\r\nclass BindingNodeAttribute extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as Element;\r\n    element.setAttribute(this.subName, value.toString());\r\n  }\r\n}\r\n\r\n/**\r\n * 属性バインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeAttributeインスタンスを生成\r\n */\r\nexport const createBindingNodeAttribute: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeAttribute(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeCheckboxクラスは、チェックボックス（input[type=\"checkbox\"]）の\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値（配列）に現在のvalueが含まれているかどうかでchecked状態を制御\r\n * - 値が配列でない場合はエラーを投げる\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - assignValueで配列内にvalueが含まれていればchecked=true\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeCheckbox extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError(`BindingNodeCheckbox.update: value is not array`, );\r\n    }\r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value.map(_val => _val.toString()).includes(element.value);\r\n  }\r\n}\r\n\r\n/**\r\n * チェックボックス用バインディングノード生成ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeCheckboxインスタンスを生成\r\n */\r\nexport const createBindingNodeCheckbox: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeCheckbox(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeClassListクラスは、class属性（classList）のバインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値（配列）を空白区切りのclass属性値としてElementにセット\r\n * - 値が配列でない場合はエラーを投げる\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - assignValueで配列を受け取り、join(\" \")でclassNameに反映\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeClassList extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError(`BindingNodeClassList.update: value is not array`);\r\n    }\r\n    const element = this.node as Element;\r\n    element.className = value.join(\" \");\r\n  }\r\n}\r\n\r\n/**\r\n * classList用バインディングノード生成ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeClassListインスタンスを生成\r\n */\r\nexport const createBindingNodeClassList: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeClassList(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeClassNameクラスは、class属性の個別クラス名（例: class.active など）の\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値（boolean）に応じて、指定クラス名（subName）をElementに追加・削除\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - nameからクラス名（subName）を抽出（例: \"class.active\" → \"active\"）\r\n * - assignValueでboolean値のみ許容し、型が異なる場合はエラー\r\n * - trueならclassList.add、falseならclassList.removeでクラス操作\r\n * - ファクトリ関数でフィルタ適用済みインスタンスを生成\r\n */\r\nclass BindingNodeClassName extends BindingNode {\r\n  #subName: string;\r\n  get subName(): string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (typeof value !== \"boolean\") {\r\n      raiseError(`BindingNodeClassName.update: value is not boolean`);\r\n    }\r\n    const element = this.node as Element;\r\n    if (value) {\r\n      element.classList.add(this.subName);\r\n    } else {\r\n      element.classList.remove(this.subName);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * class名バインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeClassNameインスタンスを生成\r\n */\r\nexport const createBindingNodeClassName: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeClassName(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeEventクラスは、イベントバインディング（onClick, onInputなど）を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - 指定イベント（on～）に対して、バインディングされた関数をイベントリスナーとして登録\r\n * - デコレータ（preventDefault, stopPropagation）によるイベント制御に対応\r\n * - ループコンテキストやリストインデックスも引数としてイベントハンドラに渡す\r\n * - ハンドラ実行時はstateProxyを生成し、Updater経由で非同期的に状態を更新\r\n *\r\n * 設計ポイント:\r\n * - nameからイベント名（subName）を抽出し、addEventListenerで登録\r\n * - バインディング値が関数でない場合はエラー\r\n * - デコレータでpreventDefault/stopPropagationを柔軟に制御\r\n * - ループ内イベントにも対応し、リストインデックスを引数展開\r\n */\r\nclass BindingNodeEvent extends BindingNode {\r\n  #subName    : string;\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    this.#subName = this.name.slice(2); // on～\r\n    const element = node as HTMLElement;\r\n    element.addEventListener(this.subName, (e:Event) => this.handler(e));\r\n  }\r\n  get subName(): string {\r\n    return this.#subName;\r\n  }\r\n  update() {\r\n    // 何もしない（イベントバインディングは初期化時のみ）\r\n  }\r\n\r\n  async handler(e: Event) {\r\n    const engine = this.binding.engine;\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n    const indexes = loopContext?.serialize().map((context) => context.listIndex.index) ?? [];\r\n    const options = this.decorates;\r\n    const value = this.binding.bindingState.value;\r\n    const typeOfValue = typeof value;\r\n    if (typeOfValue !== \"function\") {\r\n      raiseError(`BindingNodeEvent: ${this.name} is not a function.`);\r\n    }\r\n    if (options.includes(\"preventDefault\")) {\r\n      e.preventDefault();\r\n    }\r\n    if (options.includes(\"stopPropagation\")) {\r\n      e.stopPropagation();\r\n    }\r\n    await engine.useWritableStateProxy(loopContext, async (stateProxy) => {\r\n      // stateProxyを生成し、バインディング値を実行\r\n      await Reflect.apply(value, stateProxy, [e, ...indexes]);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * イベントバインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeEventインスタンスを生成\r\n */\r\nexport const createBindingNodeEvent: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeEvent(binding, node, name, filterFns, decorates);\r\n  }\r\n","export const DATA_BIND_ATTRIBUTE = \"data-bind\";\r\nexport const COMMENT_EMBED_MARK = \"@@:\"; // 埋め込み変数のマーク\r\nexport const COMMENT_TEMPLATE_MARK = \"@@|\"; // テンプレートのマーク\r\n","import { COMMENT_TEMPLATE_MARK } from \"../../constants.js\";\r\nimport { Filters } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\n\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\n/**\r\n * BindingNodeBlockクラスは、テンプレートブロック（コメントノードによるテンプレート挿入部）を\r\n * バインディング対象とするためのバインディングノード実装です。\r\n *\r\n * 主な役割:\r\n * - コメントノード内のテンプレートIDを抽出し、idプロパティとして保持\r\n * - テンプレートブロックのバインディング処理の基盤となる\r\n *\r\n * 設計ポイント:\r\n * - コメントノードのテキストからテンプレートIDを抽出（COMMENT_TEMPLATE_MARK以降を数値変換）\r\n * - IDが取得できない場合はエラーを投げる\r\n * - 他のBindingNode系クラスと同様、フィルタやデコレータにも対応\r\n */\r\nexport class BindingNodeBlock extends BindingNode {\r\n  #id: number;\r\n  get id(): number {\r\n    return this.#id;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const id = this.node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN) ?? raiseError(\"BindingNodeBlock.id: invalid node\");\r\n    this.#id = Number(id);\r\n  }\r\n    \r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindContent } from \"../BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeIfクラスは、ifバインディング（条件付き描画）を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値（boolean）に応じて、BindContent（描画内容）のマウント・アンマウントを制御\r\n * - true/false時のBindContent集合を管理し、現在の描画状態をbindContentsで取得可能\r\n *\r\n * 設計ポイント:\r\n * - assignValueでboolean型以外が渡された場合はエラー\r\n * - trueならBindContentをrender・mount、falseならunmount\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeIf extends BindingNodeBlock {\r\n  #bindContent: IBindContent;\r\n  #trueBindContents: Set<IBindContent>;\r\n  #falseBindContents: Set<IBindContent> = new Set();\r\n  #bindContents: Set<IBindContent>;\r\n\r\n  get bindContents(): Set<IBindContent> {\r\n    return this.#bindContents;\r\n  }\r\n\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    this.#bindContent = createBindContent(\r\n      this.binding, \r\n      this.id, \r\n      this.binding.engine, \r\n      \"\", \r\n      null\r\n    );\r\n    this.#trueBindContents = this.#bindContents = new Set([this.#bindContent]);\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (typeof value !== \"boolean\") {\r\n      raiseError(`BindingNodeIf.update: value is not boolean`);\r\n    }\r\n    const parentNode = this.node.parentNode;\r\n    if (parentNode == null) {\r\n      raiseError(`BindingNodeIf.update: parentNode is null`);\r\n    }\r\n    if (value) {\r\n      this.#bindContent.render();\r\n      this.#bindContent.mountAfter(parentNode, this.node.nextSibling);\r\n      this.#bindContents = this.#trueBindContents;\r\n    } else {\r\n      this.#bindContent.unmount();\r\n      this.#bindContents = this.#falseBindContents;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * ifバインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeIfインスタンスを生成\r\n */\r\nexport const createBindingNodeIf: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeIf(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindContent } from \"../BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeForクラスは、forバインディング（配列やリストの繰り返し描画）を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - リストデータの各要素ごとにBindContent（バインディングコンテキスト）を生成・管理\r\n * - 配列の差分検出により、必要なBindContentの生成・再利用・削除・再描画を最適化\r\n * - DOM上での要素の並び替えや再利用、アンマウント・マウント処理を効率的に行う\r\n * - プール機構によりBindContentの再利用を促進し、パフォーマンスを向上\r\n *\r\n * 設計ポイント:\r\n * - assignValueでリストの差分を検出し、BindContentの生成・削除・再利用を管理\r\n * - updateElementsでリストの並び替えやSWAP処理にも対応\r\n * - BindContentのプール・インデックス管理でGCやDOM操作の最小化を図る\r\n * - バインディング状態やリストインデックス情報をエンジンに保存し、再描画や依存解決を容易にする\r\n *\r\n * ファクトリ関数 createBindingNodeFor でフィルタ・デコレータ適用済みインスタンスを生成\r\n */\r\nclass BindingNodeFor extends BindingNodeBlock {\r\n  #bindContentsSet       : Set<IBindContent> = new Set<IBindContent>();\r\n  #bindContentByListIndex: WeakMap<IListIndex, IBindContent> = new WeakMap();\r\n  #bindContentPool       : IBindContent[] = [];\r\n  #bindContentLastIndex  : number = 0;\r\n  #lastListIndexSet      : Set<IListIndex> = new Set<IListIndex>();\r\n\r\n  get bindContents(): Set<IBindContent> {\r\n    return this.#bindContentsSet;\r\n  }\r\n\r\n  get isFor(): boolean {\r\n    return true;\r\n  }\r\n\r\n  init() {\r\n  }\r\n\r\n  createBindContent(listIndex: IListIndex): IBindContent {\r\n    let bindContent: IBindContent;\r\n    if (this.#bindContentLastIndex >= 0) {\r\n      // プールの最後の要素を取得して、プールの長さをあとで縮減する\r\n      // 作るたびにプールを縮減すると、パフォーマンスが悪化するため\r\n      // プールの長さを縮減するのは、全ての要素を作った後に行う\r\n      bindContent = this.#bindContentPool[this.#bindContentLastIndex];\r\n      this.#bindContentLastIndex--;\r\n      bindContent.assignListIndex(listIndex);\r\n    } else {\r\n      bindContent = createBindContent(\r\n        this.binding, \r\n        this.id, \r\n        this.binding.engine, \r\n        this.binding.bindingState.pattern + \".*\", \r\n        listIndex);\r\n    }\r\n    // 登録\r\n    this.#bindContentByListIndex.set(listIndex, bindContent);\r\n    return bindContent;\r\n  }\r\n\r\n  deleteBindContent(bindContent: IBindContent): void {\r\n    bindContent.unmount();\r\n    bindContent.loopContext?.clearListIndex();\r\n  }\r\n\r\n  get bindContentLastIndex():number {\r\n    return this.#bindContentLastIndex;\r\n  }\r\n  set bindContentLastIndex(value:number) {\r\n    this.#bindContentLastIndex = value;\r\n  }\r\n\r\n  get poolLength():number {\r\n    return this.#bindContentPool.length;\r\n  }\r\n  set poolLength(length: number) {\r\n    if (length < 0) {\r\n      raiseError(`BindingNodeFor.setPoolLength: length is negative`);\r\n    }\r\n    this.#bindContentPool.length = length;\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError(`BindingNodeFor.assignValue: value is not array`);\r\n    }\r\n    const listIndexesSet = this.binding.engine.getListIndexesSet(\r\n      this.binding.bindingState.info, \r\n      this.binding.bindingState.listIndex\r\n    );\r\n    if (listIndexesSet === null) {\r\n      raiseError(`BindingNodeFor.assignValue: listIndexes is not found`);\r\n    }\r\n    const newBindContensSet = new Set<IBindContent>();\r\n    let lastBindContent = null;\r\n    // 削除を先にする\r\n    const removeBindContentsSet = new Set<IBindContent>();\r\n    const diff = this.#lastListIndexSet.difference(listIndexesSet);\r\n    for(const listIndex of diff) {\r\n      const bindContent = this.#bindContentByListIndex.get(listIndex);\r\n      if (bindContent) {\r\n        this.deleteBindContent(bindContent);\r\n        removeBindContentsSet.add(bindContent);\r\n      }\r\n    }\r\n    this.#bindContentPool.push(...removeBindContentsSet);\r\n\r\n    const parentNode = this.node.parentNode ?? raiseError(`BindingNodeFor.update: parentNode is null`);\r\n    const firstNode = this.node;\r\n\r\n    this.bindContentLastIndex = this.poolLength - 1;\r\n    for(const listIndex of listIndexesSet) {\r\n      const lastNode = lastBindContent?.getLastNode(parentNode) ?? firstNode;\r\n      let bindContent = this.#bindContentByListIndex.get(listIndex);\r\n      if (typeof bindContent === \"undefined\") {\r\n        bindContent = this.createBindContent(listIndex);\r\n        bindContent.render();\r\n        bindContent.mountAfter(parentNode, lastNode);\r\n      } else {\r\n        if (lastNode?.nextSibling !== bindContent.firstChildNode) {\r\n          bindContent.mountAfter(parentNode, lastNode);\r\n        }\r\n      }\r\n      newBindContensSet.add(bindContent);\r\n      lastBindContent = bindContent;\r\n    }\r\n    // プールの長さを更新する\r\n    // プールの長さは、プールの最後の要素のインデックス+1であるため、\r\n    this.poolLength = this.bindContentLastIndex + 1;\r\n    this.#bindContentsSet = newBindContensSet;\r\n    this.#lastListIndexSet = new Set<IListIndex>(listIndexesSet);\r\n  }\r\n\r\n  /**\r\n   * SWAP処理を想定\r\n   * \r\n   * @param listIndexes \r\n   * @param values \r\n   * @returns \r\n   */\r\n  updateElements(listIndexes: IListIndex[], values: any[]) {\r\n    if (typeof values[0] !== \"object\") return;\r\n    const engine = this.binding.engine;\r\n    const oldListValues = \r\n      engine.getList(\r\n        this.binding.bindingState.info, \r\n        this.binding.bindingState.listIndex\r\n      ) ?? raiseError(`BindingNodeFor.updateElements: oldValues is not found`); \r\n    const parentNode = this.node.parentNode ?? raiseError(`BindingNodeFor.update: parentNode is null`);\r\n\r\n    // DOMから削除\r\n    const currentBindContents = Array.from(this.#bindContentsSet);\r\n    const targetBindContents: IBindContent[] = [];\r\n    for(let i = 0; i < listIndexes.length; i++) {\r\n      const listIndex = listIndexes[i];\r\n      const bindContent = currentBindContents[listIndex.index];\r\n      bindContent.unmount();\r\n      targetBindContents.push(bindContent);\r\n    }\r\n\r\n    // DOMに追加、listIndexを更新\r\n    for(let i = 0; i < listIndexes.length; i++) {\r\n      const listIndex = listIndexes[i];\r\n      const index = listIndex.index;\r\n\r\n      const lastBindContent = currentBindContents[index - 1] ?? null;\r\n      const lastNode = lastBindContent?.lastChildNode ?? this.node;\r\n\r\n      const oldValue = oldListValues[index];\r\n      const targetIndex = values.indexOf(oldValue);\r\n      const prevBindContent = targetBindContents[targetIndex];\r\n\r\n      if (typeof prevBindContent === \"undefined\") {\r\n        // 入れ替えるBindContentがない場合は再描画\r\n        const bindContent = targetBindContents[index];\r\n        bindContent.render();\r\n        bindContent.mountAfter(parentNode, lastNode);\r\n      } else {\r\n        prevBindContent.assignListIndex(listIndex);\r\n        prevBindContent.mountAfter(parentNode, lastNode);\r\n        this.#bindContentByListIndex.set(listIndex, prevBindContent);\r\n        currentBindContents[index] = prevBindContent;\r\n      }\r\n      if (targetIndex >= 0) {\r\n        values[targetIndex] = -1;\r\n      }\r\n    }\r\n    this.#bindContentsSet = new Set<IBindContent>(currentBindContents);\r\n    engine.saveList(\r\n      this.binding.bindingState.info, \r\n      this.binding.bindingState.listIndex, \r\n      this.binding.bindingState.value.slice(0)\r\n    );\r\n  }\r\n}\r\n\r\nexport const createBindingNodeFor: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeFor(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { NodeType } from \"./types\";\r\n\r\nconst DEFAULT_PROPERTY = \"textContent\";\r\n\r\ntype DefaultPropertyByElementType = {\r\n  [key:string]: string;\r\n}\r\n\r\nconst defaultPropertyByElementType:DefaultPropertyByElementType = {\r\n  \"radio\"   : \"checked\",\r\n  \"checkbox\": \"checked\",\r\n  \"button\"  : \"onclick\",\r\n}\r\n\r\n/**\r\n * HTML要素のデフォルトプロパティを取得\r\n */\r\nconst getDefaultPropertyHTMLElement = (node:Node):string => \r\n  node instanceof HTMLSelectElement || node instanceof HTMLTextAreaElement || node instanceof HTMLOptionElement ? \"value\" : \r\n  node instanceof HTMLButtonElement ? \"onclick\" : \r\n  node instanceof HTMLAnchorElement ? \"onclick\" : \r\n  node instanceof HTMLFormElement ? \"onsubmit\" : \r\n  node instanceof HTMLInputElement ? (defaultPropertyByElementType[node.type] ?? \"value\") :\r\n  DEFAULT_PROPERTY;\r\n\r\ntype DefaultPropertyByKey = {\r\n  [key:string]: string | undefined;\r\n}\r\n\r\nconst _cache: DefaultPropertyByKey = {};\r\n\r\nconst textContentProperty = (node:Node):string => DEFAULT_PROPERTY;\r\n\r\ntype GetDefaultPropertyByNodeType = {\r\n  [key in NodeType]: ((node:Node)=>string) | undefined;\r\n}\r\n\r\nconst getDefaultPropertyByNodeType: GetDefaultPropertyByNodeType = {\r\n  HTMLElement: getDefaultPropertyHTMLElement,\r\n  SVGElement : undefined,\r\n  Text       : textContentProperty,\r\n  Template   : undefined,\r\n}\r\n\r\n/**\r\n * バインド情報でノードプロパティが省略された場合に、ノード種別・要素タイプごとに\r\n * 適切なデフォルトプロパティ名（例: textContent, value, checked, onclick など）を返すユーティリティ関数。\r\n *\r\n * - HTMLInputElementやHTMLSelectElementなど、要素ごとに最適なプロパティを判定\r\n * - input要素はtype属性（radio, checkboxなど）も考慮\r\n * - 一度判定した組み合わせはキャッシュし、パフォーマンス向上\r\n *\r\n * @param node     対象ノード\r\n * @param nodeType ノードタイプ（\"HTMLElement\" | \"SVGElement\" | \"Text\" | \"Template\"）\r\n * @returns        デフォルトのプロパティ名（例: \"value\", \"checked\", \"textContent\" など）\r\n */\r\nexport function getDefaultName(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n): string | undefined {\r\n  const key = node.constructor.name + \"\\t\" + ((node as HTMLInputElement).type ?? \"\"); // type attribute\r\n  return _cache[key] ?? (_cache[key] = getDefaultPropertyByNodeType[nodeType]?.(node));\r\n}\r\n  ","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { getDefaultName } from \"../../BindingBuilder/getDefaultName.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nfunction isTwoWayBindable(element: HTMLElement): boolean {\r\n  return element instanceof HTMLInputElement || \r\n    element instanceof HTMLTextAreaElement || \r\n    element instanceof HTMLSelectElement;\r\n}\r\n\r\nconst defaultEventByName: {[key:string]: string} = {\r\n  \"value\"   : \"input\",\r\n  \"checked\" : \"change\",\r\n  \"selected\": \"change\",\r\n};\r\n\r\n/**\r\n * BindingNodePropertyクラスは、ノードのプロパティ（value, checked, selected など）への\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - ノードプロパティへの値の割り当て・取得\r\n * - 双方向バインディング（input, changeイベント等）に対応\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - デフォルトプロパティ名と一致し、かつ双方向バインディング可能な要素の場合のみイベントリスナーを登録\r\n * - デコレータでイベント名を指定可能（onInput, onChangeなど）\r\n * - イベント発火時はUpdater経由でstateを非同期的に更新\r\n * - assignValueでnull/undefined/NaNは空文字列に変換してセット\r\n */\r\nclass BindingNodeProperty extends BindingNode {\r\n  get value(): any {\r\n    // @ts-ignore\r\n    return this.node[this.name];\r\n  }\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for(let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n\r\n    const isElement = this.node instanceof HTMLElement;\r\n    if (!isElement) return;\r\n    if (!isTwoWayBindable(this.node)) return;\r\n    const defaultName = getDefaultName(this.node, \"HTMLElement\");\r\n    if (defaultName !== this.name) return;\r\n    if (decorates.length > 1) raiseError(`BindingNodeProperty: ${this.name} has multiple decorators`);\r\n    const event = (decorates[0]?.startsWith(\"on\") ? decorates[0]?.slice(2) : decorates[0]) ?? null;\r\n    const eventName = event ?? defaultEventByName[this.name] ?? \"readonly\";\r\n    if (eventName === \"readonly\" || eventName === \"ro\") return;\r\n\r\n    // 双方向バインディング: イベント発火時にstateを更新\r\n    const engine = this.binding.engine;\r\n    this.node.addEventListener(eventName, async () => {\r\n      const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n      const value = this.filteredValue;\r\n      await engine.useWritableStateProxy(loopContext, async (stateProxy) => {\r\n        // stateProxyを生成し、バインディング値を更新\r\n        binding.updateStateValue(stateProxy, value);\r\n      });\r\n    });\r\n  }\r\n\r\n  init() {\r\n    // サブクラスで初期化処理を実装可能\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    // @ts-ignore\r\n    this.node[this.name] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * プロパティバインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodePropertyインスタンスを生成\r\n */\r\nexport const createBindingNodeProperty: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeProperty(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeRadioクラスは、ラジオボタン（input[type=\"radio\"]）の\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値とinput要素のvalueが一致していればchecked=trueにする\r\n * - null/undefined/NaNの場合は空文字列に変換して比較\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - assignValueで値を文字列化し、input要素のvalueと比較してcheckedを制御\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeRadio extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value.toString() === element.value.toString();\r\n  }\r\n}\r\n\r\n/**\r\n * ラジオボタン用バインディングノード生成ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeRadioインスタンスを生成\r\n */\r\nexport const createBindingNodeRadio: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeRadio(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeStyleクラスは、style属性（インラインスタイル）のバインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値を指定のCSSプロパティ（subName）としてHTMLElementにセット\r\n * - null/undefined/NaNの場合は空文字列に変換してセット\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - nameからCSSプロパティ名（subName）を抽出（例: \"style.color\" → \"color\"）\r\n * - assignValueで値を文字列化し、style.setPropertyで反映\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeStyle extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as HTMLElement;\r\n    element.style.setProperty(this.subName, value.toString());\r\n  }\r\n}\r\n\r\n/**\r\n * style属性バインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeStyleインスタンスを生成\r\n */\r\nexport const createBindingNodeStyle: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeStyle(binding, node, name, filterFns, decorates);\r\n  }\r\n","\r\nconst symbolName = \"componentState\";\r\n\r\nexport const RenderSymbol : unique symbol = Symbol.for(`${symbolName}.render`);\r\nexport const BindParentComponentSymbol : unique symbol = Symbol.for(`${symbolName}.bindParentComponent`);\r\nexport const NamesSymbol : unique symbol = Symbol.for(`${symbolName}.names`);\r\nexport const GetPropertyValueFromChildSymbol : unique symbol = Symbol.for(`${symbolName}.GetPropertyValueFromChild`);\r\nexport const SetPropertyValueFromChildSymbol : unique symbol = Symbol.for(`${symbolName}.SetPropertyValueFromChild`);\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { RenderSymbol } from \"../../ComponentState/symbols.js\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { StructiveComponent } from \"../../WebComponents/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeComponentクラスは、StructiveComponent（カスタムコンポーネント）への\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング対象のコンポーネントのstateプロパティ（subName）に値を反映\r\n * - バインディング情報をコンポーネント単位で管理（bindingsByComponentに登録）\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - nameからstateプロパティ名（subName）を抽出（例: \"state.foo\" → \"foo\"）\r\n * - assignValueでコンポーネントのstateに値をセット（RenderSymbol経由で反映）\r\n * - 初期化時にbindingsByComponentへバインディング情報を登録\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeComponent extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n\r\n  init(): void {\r\n    const engine = this.binding.engine;\r\n    let bindings = engine.bindingsByComponent.get(this.node as StructiveComponent);\r\n    if (typeof bindings === \"undefined\") {\r\n      engine.bindingsByComponent.set(this.node as StructiveComponent, bindings = new Set<IBinding>());\r\n    }\r\n    bindings.add(this.binding);\r\n  }\r\n\r\n  assignValue(value: any): void {\r\n    const component = this.node as StructiveComponent;\r\n    component.state[RenderSymbol](this.subName, value);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * コンポーネント用バインディングノード生成ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeComponentインスタンスを生成\r\n */\r\nexport const createBindingNodeComponent: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeComponent(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createBindingNodeAttribute } from \"../DataBinding/BindingNode/BindingNodeAttribute.js\";\r\nimport { createBindingNodeCheckbox } from \"../DataBinding/BindingNode/BindingNodeCheckbox.js\";\r\nimport { createBindingNodeClassList } from \"../DataBinding/BindingNode/BindingNodeClassList.js\";\r\nimport { createBindingNodeClassName } from \"../DataBinding/BindingNode/BindingNodeClassName.js\";\r\nimport { createBindingNodeEvent } from \"../DataBinding/BindingNode/BindingNodeEvent.js\";\r\nimport { createBindingNodeIf } from \"../DataBinding/BindingNode/BindingNodeIf.js\";\r\nimport { createBindingNodeFor } from \"../DataBinding/BindingNode/BindingNodeFor.js\";\r\nimport { createBindingNodeProperty } from \"../DataBinding/BindingNode/BindingNodeProperty.js\";\r\nimport { createBindingNodeRadio } from \"../DataBinding/BindingNode/BindingNodeRadio.js\";\r\nimport { createBindingNodeStyle } from \"../DataBinding/BindingNode/BindingNodeStyle.js\";\r\nimport { CreateBindingNodeByNodeFn, CreateBindingNodeFn } from \"../DataBinding/BindingNode/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IFilterText } from \"./types\";\r\nimport { createBindingNodeComponent } from \"../DataBinding/BindingNode/BindingNodeComponent.js\";\r\n\r\ntype NodePropertyConstructorByName = {[key:string]:CreateBindingNodeFn};\r\ntype NodePropertyConstructorByNameByIsComment = {[key:number]:NodePropertyConstructorByName};\r\n\r\nconst nodePropertyConstructorByNameByIsComment:NodePropertyConstructorByNameByIsComment = {\r\n  0: {\r\n    \"class\"   : createBindingNodeClassList,\r\n    \"checkbox\": createBindingNodeCheckbox,\r\n    \"radio\"   : createBindingNodeRadio,\r\n  },\r\n  1: {\r\n    \"if\" : createBindingNodeIf,\r\n  },\r\n};\r\n\r\ntype NodePropertyConstructorByFirstName = {[key:string]:CreateBindingNodeFn};\r\n\r\nconst nodePropertyConstructorByFirstName:NodePropertyConstructorByFirstName = {\r\n  \"class\": createBindingNodeClassName,\r\n  \"attr\" : createBindingNodeAttribute,\r\n  \"style\": createBindingNodeStyle,\r\n  \"state\": createBindingNodeComponent,\r\n//  \"popover\": PopoverTarget,\r\n//  \"commandfor\": CommandForTarget,\r\n};\r\n\r\n/**\r\n * バインディング対象ノードのプロパティ名やノード種別（Element/Comment）に応じて、\r\n * 適切なバインディングノード生成関数（CreateBindingNodeFn）を返すユーティリティ。\r\n *\r\n * - ノード種別やプロパティ名ごとに専用の生成関数をマッピング\r\n * - コメントノードや特殊プロパティ（for/if等）にも対応\r\n * - プロパティ名の先頭や\"on\"でイベントバインディングも判別\r\n * - 一度判定した組み合わせはキャッシュし、パフォーマンス向上\r\n *\r\n * これにより、テンプレートのdata-bindやコメントバインディングの各種ケースに柔軟に対応できる。\r\n */\r\nfunction _getBindingNodeCreator(isComment:boolean, isElement: boolean, propertyName: string): CreateBindingNodeFn {\r\n  // コメント/エレメント種別とプロパティ名で専用の生成関数を優先的に取得\r\n  const bindingNodeCreatorByName = nodePropertyConstructorByNameByIsComment[isComment ? 1 : 0][propertyName];\r\n  if (typeof bindingNodeCreatorByName !== \"undefined\") {\r\n    return bindingNodeCreatorByName;\r\n  }\r\n  // コメントノードでforの場合は専用関数\r\n  if (isComment && propertyName === \"for\") {\r\n    return createBindingNodeFor;\r\n  }\r\n  // コメントノードで未対応プロパティはエラー\r\n  if (isComment) {\r\n    raiseError(`getBindingNodeCreator: unknown node property ${propertyName}`);\r\n  }\r\n  // プロパティ名の先頭で判別（class.attr.style.state等）\r\n  const nameElements = propertyName.split(\".\");\r\n  const bindingNodeCreatorByFirstName = nodePropertyConstructorByFirstName[nameElements[0]];\r\n  if (typeof bindingNodeCreatorByFirstName !== \"undefined\") {\r\n    return bindingNodeCreatorByFirstName;\r\n  }\r\n  // エレメントノードでonから始まる場合はイベントバインディング\r\n  if (isElement) {\r\n    if (propertyName.startsWith(\"on\")) {\r\n      return createBindingNodeEvent;\r\n    } else {\r\n      return createBindingNodeProperty;\r\n    }\r\n  } else {\r\n    // それ以外は汎用プロパティバインディング\r\n    return createBindingNodeProperty;\r\n  }\r\n}\r\n\r\nconst _cache: {[key:string]:CreateBindingNodeFn} = {};\r\n\r\n/**\r\n * ノード・プロパティ名・フィルタ・デコレータ情報から\r\n * 適切なバインディングノード生成関数を取得し、呼び出すファクトリ関数。\r\n * \r\n * @param node         バインディング対象ノード\r\n * @param propertyName バインディングプロパティ名\r\n * @param filterTexts  フィルタ情報\r\n * @param decorates    デコレータ情報\r\n * @returns            バインディングノード生成関数の実行結果\r\n */\r\nexport function getBindingNodeCreator(\r\n  node        : Node, \r\n  propertyName: string,\r\n  filterTexts : IFilterText[],\r\n  decorates   : string[]\r\n): CreateBindingNodeByNodeFn {\r\n  const isComment = node instanceof Comment;\r\n  const isElement = node instanceof Element;\r\n  const key = isComment + \"\\t\" + isElement + \"\\t\" + propertyName;\r\n  // キャッシュを利用して生成関数を取得\r\n  const fn = _cache[key] ?? (_cache[key] = _getBindingNodeCreator(isComment, isElement, propertyName));\r\n  return fn(propertyName, filterTexts, decorates);\r\n}\r\n","\r\nconst symbolName = \"state\";\r\n\r\nexport const GetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.GetByRef`);\r\nexport const SetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.SetByRef`);\r\nexport const SetCacheableSymbol        : unique symbol = Symbol.for(`${symbolName}.SetCacheable`);\r\nexport const ConnectedCallbackSymbol   : unique symbol = Symbol.for(`${symbolName}.ConnectedCallback`);\r\nexport const DisconnectedCallbackSymbol: unique symbol = Symbol.for(`${symbolName}.DisconnectedCallback`);\r\n","/**\r\n * getStructuredPathInfo.ts\r\n *\r\n * Stateプロパティのパス文字列から、詳細な構造化パス情報（IStructuredPathInfo）を生成・キャッシュするユーティリティです。\r\n *\r\n * 主な役割:\r\n * - パス文字列を分割し、各セグメントやワイルドカード（*）の位置・親子関係などを解析\r\n * - cumulativePaths/wildcardPaths/parentPathなど、パス階層やワイルドカード階層の情報を構造化\r\n * - 解析結果をIStructuredPathInfoとしてキャッシュし、再利用性とパフォーマンスを両立\r\n * - reservedWords（予約語）チェックで安全性を担保\r\n *\r\n * 設計ポイント:\r\n * - パスごとにキャッシュし、同じパスへの複数回アクセスでも高速に取得可能\r\n * - ワイルドカードや親子関係、階層構造を厳密に解析し、バインディングや多重ループに最適化\r\n * - childrenプロパティでパス階層のツリー構造も構築\r\n * - 予約語や危険なパスはraiseErrorで例外を発生\r\n */\r\nimport { raiseError } from '../utils.js';\r\nimport { IStructuredPathInfo } from './types';\r\n\r\n/**\r\n * プロパティ名に\"constructor\"や\"toString\"などの予約語やオブジェクトのプロパティ名を\r\n * 上書きするような名前も指定できるように、Mapを検討したが、そもそもそのような名前を\r\n * 指定することはないと考え、Mapを使わないことにした。\r\n */\r\nconst _cache: { [key:string]: IStructuredPathInfo } = {};\r\n//const _cache: Map<string, IStructuredPathInfo> = new Map();\r\n\r\n/**\r\n * パターン情報を取得します\r\n * @param pattern パターン\r\n * @returns {IPatternInfo} パターン情報\r\n */\r\nclass StructuredPathInfo implements IStructuredPathInfo {\r\n  static id : number = 0;\r\n  id = ++StructuredPathInfo.id;\r\n  pattern;\r\n  pathSegments;\r\n  lastSegment;\r\n  cumulativePaths;\r\n  cumulativePathSet;\r\n  cumulativeInfos;\r\n  cumulativeInfoSet;\r\n  wildcardPaths;\r\n  wildcardPathSet;\r\n  wildcardInfos;\r\n  indexByWildcardPath;\r\n  wildcardInfoSet;\r\n  wildcardParentPaths;\r\n  wildcardParentPathSet;\r\n  wildcardParentInfos;\r\n  wildcardParentInfoSet;\r\n  lastWildcardPath;\r\n  lastWildcardInfo;\r\n  parentPath;\r\n  parentInfo;\r\n  wildcardCount;\r\n  children = {};\r\n\r\n  constructor(pattern: string) {\r\n    const getPattern = (_pattern: string): IStructuredPathInfo => {\r\n      return (pattern === _pattern) ? this : getStructuredPathInfo(_pattern);\r\n    };\r\n    const pathSegments = pattern.split(\".\");\r\n    const cumulativePaths = [];\r\n    const cumulativeInfos: IStructuredPathInfo[] = [];\r\n    const wildcardPaths = [];\r\n    const indexByWildcardPath: Record<string, number> = {};\r\n    const wildcardInfos = [];\r\n    const wildcardParentPaths = [];\r\n    const wildcardParentInfos = [];\r\n    let currentPatternPath = \"\", prevPatternPath = \"\";\r\n    let wildcardCount = 0;\r\n    for(let i = 0; i < pathSegments.length; i++) {\r\n      currentPatternPath += pathSegments[i];\r\n      if (pathSegments[i] === \"*\") {\r\n        wildcardPaths.push(currentPatternPath);\r\n        indexByWildcardPath[currentPatternPath] = wildcardCount;\r\n        wildcardInfos.push(getPattern(currentPatternPath));\r\n        wildcardParentPaths.push(prevPatternPath);\r\n        wildcardParentInfos.push(getPattern(prevPatternPath));\r\n        wildcardCount++;\r\n      }\r\n      cumulativePaths.push(currentPatternPath);\r\n      cumulativeInfos.push(getPattern(currentPatternPath));\r\n      prevPatternPath = currentPatternPath;\r\n      currentPatternPath += \".\";\r\n    }\r\n    const lastWildcardPath = wildcardPaths.length > 0 ? wildcardPaths[wildcardPaths.length - 1] : null;\r\n    const parentPath = cumulativePaths.length > 1 ? cumulativePaths[cumulativePaths.length - 2] : null;\r\n    this.pattern = pattern;\r\n    this.pathSegments = pathSegments;\r\n    this.lastSegment = pathSegments[pathSegments.length - 1];\r\n    this.cumulativePaths = cumulativePaths;\r\n    this.cumulativePathSet = new Set(cumulativePaths);\r\n    this.cumulativeInfos = cumulativeInfos;\r\n    this.cumulativeInfoSet = new Set(cumulativeInfos);\r\n    this.wildcardPaths = wildcardPaths;\r\n    this.wildcardPathSet = new Set(wildcardPaths);\r\n    this.indexByWildcardPath = indexByWildcardPath;\r\n    this.wildcardInfos = wildcardInfos;\r\n    this.wildcardInfoSet = new Set(wildcardInfos);\r\n    this.wildcardParentPaths = wildcardParentPaths;\r\n    this.wildcardParentPathSet = new Set(wildcardParentPaths);\r\n    this.wildcardParentInfos = wildcardParentInfos;\r\n    this.wildcardParentInfoSet = new Set(wildcardParentInfos);\r\n    this.lastWildcardPath = lastWildcardPath;\r\n    this.lastWildcardInfo = lastWildcardPath ? getPattern(lastWildcardPath) : null;\r\n    this.parentPath = parentPath;\r\n    this.parentInfo = parentPath ? getPattern(parentPath) : null;\r\n    this.wildcardCount = wildcardCount;\r\n    if (this.parentInfo) {\r\n      this.parentInfo.children[this.lastSegment] = this;\r\n    }\r\n  }\r\n}\r\n\r\nconst reservedWords = new Set([\r\n  \"constructor\", \"prototype\", \"__proto__\", \"toString\",\r\n  \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",\r\n  \"watch\", \"unwatch\", \"eval\", \"arguments\",\r\n  \"let\", \"var\", \"const\", \"class\", \"function\",\r\n  \"null\", \"true\", \"false\", \"new\", \"return\",\r\n]);\r\n\r\nexport function getStructuredPathInfo(structuredPath: string): IStructuredPathInfo {\r\n  let info: IStructuredPathInfo | undefined;\r\n  info = _cache[structuredPath];\r\n  if (typeof info !== \"undefined\") {\r\n    return info;\r\n  }\r\n  if (reservedWords.has(structuredPath)) {\r\n    raiseError(`getStructuredPathInfo: pattern is reserved word: ${structuredPath}`);\r\n  }\r\n  return (_cache[structuredPath] = new StructuredPathInfo(structuredPath));\r\n}\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { GetByRefSymbol, SetByRefSymbol } from \"../../StateClass/symbols.js\";\r\nimport { IReadonlyStateProxy, IWritableStateProxy } from \"../../StateClass/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\n/**\r\n * BindingStateクラスは、バインディング対象の状態（State）プロパティへのアクセス・更新・フィルタ適用を担当する実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング対象の状態プロパティ（pattern, info）やリストインデックス（listIndex）を管理\r\n * - get valueで現在の値を取得し、get filteredValueでフィルタ適用後の値を取得\r\n * - initでリストバインディング時のループコンテキストやインデックス参照を初期化\r\n * - assignValueで状態プロキシに値を書き込む（双方向バインディング対応）\r\n * - バインディング情報をエンジンに登録し、依存解決や再描画を効率化\r\n *\r\n * 設計ポイント:\r\n * - ワイルドカードパス（配列バインディング等）にも対応し、ループごとのインデックス管理が可能\r\n * - フィルタ適用は配列で柔軟に対応\r\n * - createBindingStateファクトリでフィルタ適用済みインスタンスを生成\r\n */\r\nclass BindingState implements IBindingState {\r\n  #binding     : IBinding;\r\n  #pattern     : string;\r\n  #info        : IStructuredPathInfo;\r\n  #listIndexRef: WeakRef<IListIndex> | null = null;\r\n  #state       : IReadonlyStateProxy;\r\n  #filters     : Filters;\r\n  get pattern(): string {\r\n    return this.#pattern;\r\n  }\r\n  get info() {\r\n    return this.#info;\r\n  }\r\n  get listIndex() {\r\n    if (this.#listIndexRef === null) return null;\r\n    return this.#listIndexRef.deref() ?? raiseError(\"listIndex is null\");\r\n  }\r\n  get state() {\r\n    return this.#state;\r\n  }\r\n  get filters() {\r\n    return this.#filters;\r\n  }\r\n  get binding() {\r\n    return this.#binding;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    state  : IReadonlyStateProxy, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this.#binding = binding;\r\n    this.#pattern = pattern;\r\n    this.#info = getStructuredPathInfo(pattern);\r\n    this.#state = state;\r\n    this.#filters = filters;\r\n  }\r\n  get value(): any {\r\n    return this.#state[GetByRefSymbol](this.info, this.listIndex);\r\n  }\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for(let i = 0; i < this.#filters.length; i++) {\r\n      value = this.#filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  init(): void {\r\n    if (this.info.wildcardCount > 0) {\r\n      const lastWildcardPath = this.info.lastWildcardPath ?? \r\n        raiseError(`BindingState.init: wildcardLastParentPath is null`);\r\n      const loopContext = this.binding.parentBindContent.loopContext?.find(lastWildcardPath) ?? \r\n        raiseError(`BindingState.init: loopContext is null`);\r\n      this.#listIndexRef = loopContext.listIndexRef;\r\n    }\r\n    this.binding.engine.saveBinding(this.info, this.listIndex, this.binding);\r\n  }\r\n  assignValue(writeState: IWritableStateProxy, value: any) {\r\n    writeState[SetByRefSymbol](this.info, this.listIndex, value);\r\n  }\r\n}\r\n\r\nexport const createBindingState: CreateBindingStateFn = \r\n(name: string, filterTexts: IFilterText[]) => \r\n  (binding:IBinding, state: IReadonlyStateProxy, filters:FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts); // ToDo:ここは、メモ化できる\r\n    return new BindingState(binding, state, name, filterFns);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IReadonlyStateProxy, IWritableStateProxy } from \"../../StateClass/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\n/**\r\n * BindingStateIndexクラスは、forバインディング等のループ内で利用される\r\n * インデックス値（$1, $2, ...）のバインディング状態を管理する実装です。\r\n *\r\n * 主な役割:\r\n * - ループコンテキストからインデックス値を取得し、value/filteredValueで参照可能にする\r\n * - バインディング時にbindingsByListIndexへ自身を登録し、依存解決や再描画を効率化\r\n * - フィルタ適用にも対応\r\n *\r\n * 設計ポイント:\r\n * - pattern（例: \"$1\"）からインデックス番号を抽出し、ループコンテキストから該当インデックスを取得\r\n * - initでループコンテキストやlistIndexRefを初期化し、バインディング情報をエンジンに登録\r\n * - assignValueは未実装（インデックスは書き換え不可のため）\r\n * - createBindingStateIndexファクトリでフィルタ適用済みインスタンスを生成\r\n */\r\nclass BindingStateIndex implements IBindingState {\r\n  #binding     : IBinding;\r\n  #indexNumber : number;\r\n  #listIndexRef: WeakRef<IListIndex> | null = null;\r\n  #state       : IReadonlyStateProxy;\r\n  #filters     : Filters;\r\n  get pattern(): string {\r\n    return raiseError(\"Not implemented\");\r\n  }\r\n  get info() {\r\n    return raiseError(\"Not implemented\");\r\n  }\r\n  get listIndex() {\r\n    if (this.#listIndexRef === null) return null;\r\n    return this.#listIndexRef.deref() ?? raiseError(\"listIndex is null\");\r\n  }\r\n  get state() {\r\n    return this.#state;\r\n  }\r\n  get filters() {\r\n    return this.#filters;\r\n  }\r\n  get binding() {\r\n    return this.#binding;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    state  : IReadonlyStateProxy, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this.#binding = binding;\r\n    const indexNumber = Number(pattern.slice(1));\r\n    if (isNaN(indexNumber)) {\r\n      raiseError(\"BindingStateIndex: pattern is not a number\");\r\n    }\r\n    this.#indexNumber = indexNumber;\r\n    this.#state = state;\r\n    this.#filters = filters;\r\n  }\r\n  get value(): any {\r\n    return this.listIndex?.index ?? raiseError(\"listIndex is null\");\r\n  }\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for(let i = 0; i < this.#filters.length; i++) {\r\n      value = this.#filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  init(): void {\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext ??\r\n      raiseError(`BindingState.init: loopContext is null`);\r\n    const loopContexts = loopContext.serialize();\r\n    this.#listIndexRef = loopContexts[this.#indexNumber - 1].listIndexRef ??\r\n      raiseError(`BindingState.init: listIndexRef is null`);\r\n    const listIndex = this.listIndex ?? raiseError(\"listIndex is null\");\r\n    const bindings = this.binding.engine.bindingsByListIndex.get(listIndex);\r\n    if (bindings === undefined) {\r\n      this.binding.engine.bindingsByListIndex.set(listIndex, new Set([this.binding]));\r\n    } else {\r\n      bindings.add(this.binding);\r\n    }\r\n  }\r\n  assignValue(writeState:IWritableStateProxy, value:any): void {\r\n    raiseError(\"BindingStateIndex: assignValue is not implemented\");\r\n  }\r\n}\r\n\r\nexport const createBindingStateIndex: CreateBindingStateFn = \r\n(name: string, filterTexts: IFilterText[]) => \r\n  (binding:IBinding, state: IReadonlyStateProxy, filters:FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts); // ToDo:ここは、メモ化できる\r\n\r\n    return new BindingStateIndex(binding, state, name, filterFns);\r\n  }\r\n","import { createBindingState } from \"../DataBinding/BindingState/BindingState.js\";\r\nimport { createBindingStateIndex } from \"../DataBinding/BindingState/BindingStateIndex.js\";\r\nimport { CreateBindingStateByStateFn } from \"../DataBinding/BindingState/types\";\r\nimport { IFilterText } from \"./types\";\r\n\r\nconst ereg = new RegExp(/^\\$\\d+$/);\r\n\r\n/**\r\n * バインディング対象の状態プロパティ名とフィルタ情報から、\r\n * 適切なバインディング状態生成関数（CreateBindingStateByStateFn）を返すユーティリティ。\r\n *\r\n * - プロパティ名が \"$数字\"（例: \"$1\"）の場合は createBindingStateIndex を使用（インデックスバインディング用）\r\n * - それ以外は通常の createBindingState を使用\r\n *\r\n * @param name        バインディング対象の状態プロパティ名\r\n * @param filterTexts フィルタ情報\r\n * @returns           バインディング状態生成関数\r\n */\r\nexport function getBindingStateCreator(\r\n  name       : string, \r\n  filterTexts: IFilterText[]\r\n): CreateBindingStateByStateFn {\r\n  if (ereg.test(name)) {\r\n    // \"$数字\"形式の場合はインデックスバインディング用の生成関数を返す\r\n    return createBindingStateIndex(name, filterTexts);\r\n  } else {\r\n    // 通常のプロパティ名の場合は標準の生成関数を返す\r\n    return createBindingState(name, filterTexts);\r\n  }\r\n}","import { raiseError } from \"../utils.js\";\r\nimport { NodeType } from \"./types\";\r\n\r\nconst createNodeKey = (node:Node):string => node.constructor.name + \"\\t\" + ((node instanceof Comment) ? (node.textContent?.[2] ?? \"\") : \"\");\r\n\r\ntype NodeTypeByNodeKey = {\r\n  [nodeKey:string]:NodeType;\r\n};\r\n\r\nconst nodeTypeByNodeKey:NodeTypeByNodeKey = {};\r\n\r\nconst getNodeTypeByNode = (node:Node):NodeType =>\r\n  (node instanceof Comment && node.textContent?.[2] === \":\") ? \"Text\" : \r\n  (node instanceof HTMLElement) ? \"HTMLElement\" :\r\n  (node instanceof Comment && node.textContent?.[2] === \"|\") ? \"Template\" : \r\n  (node instanceof SVGElement) ? \"SVGElement\" : raiseError(`Unknown NodeType: ${node.nodeType}`);\r\n\r\n/**\r\n * ノードのタイプ（\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\"）を判定・キャッシュするユーティリティ関数。\r\n *\r\n * - コメントノードの場合、3文字目が \":\" なら \"Text\"、\"|\" なら \"Template\" と判定\r\n * - HTMLElement, SVGElement もそれぞれ判定\r\n * - 未知のノード型はエラー\r\n * - ノードごとに一意なキー（constructor名＋コメント種別）でキャッシュし、再判定を省略\r\n *\r\n * @param node    判定対象のノード\r\n * @param nodeKey キャッシュ用のノードキー（省略時は自動生成）\r\n * @returns       ノードタイプ（NodeType）\r\n */\r\nexport function getNodeType(\r\n  node   : Node, \r\n  nodeKey: string = createNodeKey(node)\r\n): NodeType {\r\n  return nodeTypeByNodeKey[nodeKey] ?? (nodeTypeByNodeKey[nodeKey] = getNodeTypeByNode(node));\r\n}\r\n","import { IFilterText, IBindText } from \"./types\";\r\n\r\nconst trim = (s:string):string => s.trim();\r\n\r\nconst has = (s:string):boolean => s.length > 0; // check length\r\n\r\nconst re = new RegExp(/^#(.*)#$/);\r\nconst decode = (s:string):string => {\r\n  const m = re.exec(s);\r\n  return m ? decodeURIComponent(m[1]) : s;\r\n};\r\n\r\n/**\r\n * parse filter part\r\n * \"eq,100|falsey\" ---> [Filter(eq, [100]), Filter(falsey)]\r\n */\r\nconst parseFilter = (text:string): IFilterText => {\r\n  const [name, ...options] = text.split(\",\").map(trim);\r\n  return {name, options:options.map(decode)};\r\n};\r\n\r\ntype ReturnParseStateProperty = {property:string,filters:IFilterText[]};\r\n/**\r\n * parse expression\r\n * \"value|eq,100|falsey\" ---> [\"value\", Filter[]]\r\n */\r\nconst parseProperty = (text:string): ReturnParseStateProperty => {\r\n  const [property, ...filterTexts] = text.split(\"|\").map(trim);\r\n  return {property, filters:filterTexts.map(parseFilter)};\r\n};\r\n\r\n/**\r\n * parse expressions\r\n * \"textContent:value|eq,100|falsey\" ---> [\"textContent\", \"value\", Filter[eq, falsey]]\r\n */\r\nconst parseExpression = (expression:string): IBindText => {\r\n  const [ bindExpression, decoratesExpression = null ] = expression.split(\"@\").map(trim);\r\n  const decorates = decoratesExpression ? decoratesExpression.split(\",\").map(trim) : [];\r\n  const [nodePropertyText, statePropertyText] = bindExpression.split(\":\").map(trim);\r\n  const { property:nodeProperty, filters:inputFilterTexts } = parseProperty(nodePropertyText);\r\n  const { property:stateProperty, filters:outputFilterTexts } = parseProperty(statePropertyText);\r\n  return { nodeProperty, stateProperty, inputFilterTexts, outputFilterTexts, decorates };\r\n};\r\n\r\n/**\r\n * parse bind text and return BindText[]\r\n */\r\nconst parseExpressions = (text:string): IBindText[] => {\r\n  return text.split(\";\").map(trim).filter(has).map(s => parseExpression(s));\r\n};\r\n\r\nconst cache:{[key:string]: IBindText[]} = {};\r\n\r\n/**\r\n * バインドテキスト（data-bind属性やコメント等から取得した文字列）を解析し、\r\n * バインディング情報（IBindText[]）に変換するユーティリティ関数群。\r\n *\r\n * - フィルターやデコレータ、プロパティ名などをパースし、構造化データとして返す\r\n * - \"textContent:value|eq,100|falsey@decorate1,decorate2\" のような複雑な記法にも対応\r\n * - セミコロン区切りで複数バインドもサポート\r\n * - パース結果はキャッシュし、同じ入力の再解析を防止\r\n *\r\n * @param text バインドテキスト\r\n * @returns    解析済みバインディング情報（IBindText[]）\r\n */\r\nexport function parseBindText(\r\n  text: string\r\n): IBindText[] {\r\n  if (text.trim() === \"\") {\r\n    return [];\r\n  }\r\n  return cache[text] ?? (cache[text] = parseExpressions(text));\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\nconst DATASET_BIND_PROPERTY = 'data-bind';\r\n\r\nconst removeAttributeFromElement = (node:Node):void => {\r\n  const element = node as Element;\r\n  element.removeAttribute(DATASET_BIND_PROPERTY);\r\n}\r\n\r\ntype RemoveAttributeByNodeType = {\r\n  [key in NodeType]: ((node:Node)=>void) | undefined;\r\n}\r\n\r\nconst removeAttributeByNodeType:RemoveAttributeByNodeType = {\r\n  HTMLElement: removeAttributeFromElement,\r\n  SVGElement : removeAttributeFromElement,\r\n  Text       : undefined,\r\n  Template   : undefined,\r\n}\r\n\r\n/**\r\n * 指定ノードから data-bind 属性を削除するユーティリティ関数。\r\n *\r\n * - ノードタイプ（HTMLElement, SVGElement）の場合のみ data-bind 属性を削除\r\n * - Text, Template ノードは対象外\r\n *\r\n * @param node     対象ノード\r\n * @param nodeType ノードタイプ（\"HTMLElement\" | \"SVGElement\" | \"Text\" | \"Template\"）\r\n * @returns        なし\r\n */\r\nexport function removeDataBindAttribute(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n):void {\r\n  return removeAttributeByNodeType[nodeType]?.(node);\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\nconst replaceTextNodeText = (node:Node):Node => {\r\n  const textNode = document.createTextNode(\"\");\r\n  node.parentNode?.replaceChild(textNode, node);\r\n  return textNode;\r\n}\r\n\r\ntype ReplaceTextNodeFn = {\r\n  [key in NodeType]: ((node:Node)=>Node) | undefined;\r\n}\r\n\r\nconst replaceTextNodeFn:ReplaceTextNodeFn = {\r\n  Text       : replaceTextNodeText,\r\n  HTMLElement: undefined,\r\n  Template   : undefined,\r\n  SVGElement : undefined\r\n}\r\n\r\n/**\r\n * コメントノードをテキストノードに置き換えるユーティリティ関数。\r\n *\r\n * - ノードタイプが \"Text\" の場合のみ、コメントノードを空のテキストノードに置換する\r\n * - それ以外のノードタイプ（HTMLElement, Template, SVGElement）は何もしない\r\n *\r\n * @param node     対象ノード\r\n * @param nodeType ノードタイプ（\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\"）\r\n * @returns        置換後のノード（または元のノード）\r\n */\r\nexport function replaceTextNodeFromComment(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n): Node {\r\n  return replaceTextNodeFn[nodeType]?.(node) ?? node;\r\n}\r\n","import { getAbsoluteNodePath } from \"./getAbsoluteNodePath.js\";\r\nimport { getBindingNodeCreator } from \"./getBindingNodeCreator.js\";\r\nimport { getBindingStateCreator } from \"./getBindingStateCreator.js\";\r\nimport { getDataBindText } from \"./getDataBindText.js\";\r\nimport { getNodeType } from \"./getNodeType.js\";\r\nimport { parseBindText } from \"./parseBindText.js\";\r\nimport { removeDataBindAttribute } from \"./removeDataBindAttribute.js\";\r\nimport { replaceTextNodeFromComment } from \"./replaceTextNodeFromComment.js\";\r\nimport { IBindingCreator, IBindText, IDataBindAttributes, NodePath, NodeType } from \"./types\";\r\n\r\n/**\r\n * DataBindAttributesクラスは、DOMノードからバインディング情報を抽出・解析し、\r\n * バインディング生成に必要な情報（ノード種別・パス・バインドテキスト・クリエイター）を管理します。\r\n *\r\n * - ノード種別やパスを特定\r\n * - data-bind属性やコメントノードからバインドテキストを取得・解析\r\n * - バインドテキストごとにバインディング生成関数（ノード用・状態用）を用意\r\n * - data-bind属性やコメントノードはパース後に削除・置換\r\n *\r\n * これにより、テンプレート内のバインディング定義を一元的に管理し、後続のバインディング構築処理を効率化します。\r\n */\r\nclass DataBindAttributes implements IDataBindAttributes {\r\n  nodeType     : NodeType; // ノードの種別\r\n  nodePath     : NodePath; // ノードのルート\r\n  bindTexts    : IBindText[]; // BINDテキストの解析結果\r\n  creatorByText: Map<IBindText, IBindingCreator> = new Map(); // BINDテキストからバインディングクリエイターを取得\r\n  constructor(node: Node) {\r\n    this.nodeType = getNodeType(node);\r\n    const text = getDataBindText(this.nodeType, node);\r\n\r\n    // コメントノードの場合はTextノードに置換（template.contentが書き換わる点に注意）\r\n    node = replaceTextNodeFromComment(node, this.nodeType);\r\n\r\n    // data-bind属性を削除（パース後は不要なため）\r\n    removeDataBindAttribute(node, this.nodeType);\r\n\r\n    this.nodePath = getAbsoluteNodePath(node);\r\n    this.bindTexts = parseBindText(text);\r\n\r\n    // 各バインドテキストごとにバインディング生成関数を用意\r\n    for(let i = 0; i < this.bindTexts.length; i++) {\r\n      const bindText = this.bindTexts[i];\r\n      const creator: IBindingCreator = {\r\n        createBindingNode : getBindingNodeCreator(\r\n          node, \r\n          bindText.nodeProperty, \r\n          bindText.inputFilterTexts,\r\n          bindText.decorates\r\n        ),\r\n        createBindingState: getBindingStateCreator(\r\n          bindText.stateProperty, \r\n          bindText.outputFilterTexts\r\n        ),\r\n      }\r\n      this.creatorByText.set(bindText, creator);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * 指定ノードからDataBindAttributesインスタンスを生成するファクトリ関数。\r\n */\r\nexport function createDataBindAttributes(node: Node): IDataBindAttributes {\r\n  return new DataBindAttributes(node);\r\n}","import { COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants.js\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { NodeType } from \"./types\";\r\n\r\nconst COMMENT_EMBED_MARK_LEN = COMMENT_EMBED_MARK.length;\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\n/**\r\n * ノード種別ごとにdata-bindテキスト（バインディング定義文字列）を取得するユーティリティ関数。\r\n *\r\n * - Textノード: コメントマーク以降のテキストを取得し、\"textContent:\"を付与\r\n * - HTMLElement: data-bind属性値を取得\r\n * - Templateノード: コメントマーク以降のIDからテンプレートを取得し、そのdata-bind属性値を取得\r\n * - SVGElement: data-bind属性値を取得\r\n *\r\n * @param nodeType ノード種別（\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\"）\r\n * @param node     対象ノード\r\n * @returns        バインディング定義文字列\r\n */\r\nexport function getDataBindText(nodeType: NodeType, node: Node): string {\r\n  switch (nodeType) {\r\n    case \"Text\": {\r\n      const text = node.textContent?.slice(COMMENT_EMBED_MARK_LEN).trim() ?? \"\";\r\n      return \"textContent:\" + text;\r\n    }\r\n    case \"HTMLElement\": {\r\n      return (node as HTMLElement).getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    case \"Template\": {\r\n      const text = node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN).trim();\r\n      const id = Number(text);\r\n      const template = getTemplateById(id) ?? raiseError(`Template not found: ${text}`);\r\n      return template.getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    case \"SVGElement\": {\r\n      return (node as SVGElement).getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    default:\r\n      return \"\";\r\n  }\r\n}","import { NodePath } from \"./types\";\r\n\r\n/**\r\n * 指定ノードの「親からのインデックス」をルートまで辿り、絶対パス（NodePath）として返すユーティリティ関数。\r\n *\r\n * 例: ルートから見て [0, 2, 1] のような配列を返す。\r\n *     これは「親→子→孫…」とたどったときの各階層でのインデックスを表す。\r\n *\r\n * @param node 対象のDOMノード\r\n * @returns    ルートからこのノードまでのインデックス配列（NodePath）\r\n */\r\nexport function getAbsoluteNodePath(node: Node): NodePath {\r\n  let routeIndexes: NodePath = [];\r\n  while(node.parentNode !== null) {\r\n    const childNodes = Array.from(node.parentNode.childNodes) as Node[];\r\n    routeIndexes = [ childNodes.indexOf(node), ...routeIndexes ];\r\n    node = node.parentNode;\r\n  }\r\n  return routeIndexes;\r\n}","import { DATA_BIND_ATTRIBUTE, COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK } from \"../constants.js\";\r\n\r\n/**\r\n * \"@@:\"もしくは\"@@|\"で始まるコメントノードを取得する\r\n */\r\nfunction isCommentNode(node: Node): boolean {\r\n  return node instanceof Comment && (\r\n    (node.textContent?.indexOf(COMMENT_EMBED_MARK) === 0) || (node.textContent?.indexOf(COMMENT_TEMPLATE_MARK) === 0)\r\n  );\r\n} \r\n\r\n/**\r\n * 指定ノード以下のツリーから「data-bind属性を持つ要素」または\r\n * 「特定のマーク（@@: または @@|）で始まるコメントノード」をすべて取得するユーティリティ関数。\r\n *\r\n * - Elementノードの場合: data-bind属性があるものだけを抽出\r\n * - Commentノードの場合: COMMENT_EMBED_MARK または COMMENT_TEMPLATE_MARK で始まるものだけを抽出\r\n * - DOMツリー全体をTreeWalkerで効率的に走査\r\n *\r\n * @param root 探索の起点となるノード\r\n * @returns    条件に合致したノードの配列\r\n */\r\nexport function getNodesHavingDataBind(root: Node): Node[] {\r\n  const nodes: Node[] = [];\r\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, {\r\n    acceptNode(node:Node) {\r\n      return (node instanceof Element) ? \r\n        (node.hasAttribute(DATA_BIND_ATTRIBUTE) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP)\r\n        : (isCommentNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\r\n    }\r\n  });\r\n  while (walker.nextNode()) {\r\n    nodes.push(walker.currentNode);\r\n  }\r\n  return nodes;\r\n}\r\n\r\n","import { createDataBindAttributes } from \"./createDataBindAttributes.js\";\r\nimport { getNodesHavingDataBind } from \"./getNodesHavingDataBind.js\";\r\nimport { IDataBindAttributes } from \"./types\";\r\n\r\nconst listDataBindAttributesById: {[key:number]:IDataBindAttributes[]} = {};\r\n\r\nconst listPathsSetById: {[key:number]:Set<string>} = {};\r\n\r\nconst pathsSetById: {[key:number]:Set<string>} = {};\r\n\r\nfunction getDataBindAttributesFromTemplate(content: DocumentFragment): IDataBindAttributes[] {\r\n  const nodes = getNodesHavingDataBind(content);\r\n  return nodes.map(node => createDataBindAttributes(node));\r\n}\r\n\r\n/**\r\n * テンプレート（DocumentFragment）内のバインディング情報（data-bind属性やコメント）を解析・登録し、\r\n * 各テンプレートIDごとにバインディング属性情報・状態パス集合を管理するユーティリティ。\r\n *\r\n * - getNodesHavingDataBindで対象ノードを抽出し、createDataBindAttributesで解析\r\n * - 各テンプレートIDごとにバインディング属性リスト・状態パス集合・リストパス集合をキャッシュ\r\n * - forバインディング（ループ）のstatePropertyはlistPathsにも登録\r\n *\r\n * @param id      テンプレートID\r\n * @param content テンプレートのDocumentFragment\r\n * @param rootId  ルートテンプレートID（省略時はidと同じ）\r\n * @returns       解析済みバインディング属性リスト\r\n */\r\nexport function registerDataBindAttributes(\r\n  id     : number, \r\n  content: DocumentFragment,\r\n  rootId : number = id\r\n): IDataBindAttributes[] {\r\n  const dataBindAttributes = getDataBindAttributesFromTemplate(content);\r\n  const paths = pathsSetById[rootId] ?? (pathsSetById[rootId] = new Set<string>());\r\n  const listPaths = listPathsSetById[rootId] ?? (listPathsSetById[rootId] = new Set<string>());\r\n  for(let i = 0; i < dataBindAttributes.length; i++) {\r\n    const attribute = dataBindAttributes[i];\r\n    for(let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      paths.add(bindText.stateProperty);\r\n      if (bindText.nodeProperty === \"for\") {\r\n        listPaths.add(bindText.stateProperty);\r\n      }\r\n    }\r\n  }\r\n  return listDataBindAttributesById[id] = dataBindAttributes;\r\n}\r\n\r\n/**\r\n * テンプレートIDからバインディング属性リストを取得\r\n */\r\nexport const getDataBindAttributesById = (id: number): IDataBindAttributes[] => {\r\n  return listDataBindAttributesById[id];\r\n}\r\n\r\n/**\r\n * テンプレートIDからforバインディングのstateProperty集合を取得\r\n */\r\nexport const getListPathsSetById = (id: number): Set<string> => {\r\n  return listPathsSetById[id] ?? [];\r\n};\r\n\r\n/**\r\n * テンプレートIDから全バインディングのstateProperty集合を取得\r\n */\r\nexport const getPathsSetById = (id: number): Set<string> => {\r\n  return pathsSetById[id] ?? [];\r\n};","/**\r\n * registerTemplate.ts\r\n *\r\n * HTMLTemplateElementをIDで登録・取得するための管理モジュールです。\r\n *\r\n * 主な役割:\r\n * - templateById: IDをキーにHTMLTemplateElementを管理するレコード\r\n * - registerTemplate: 指定IDでテンプレートを登録し、空テキストノード除去やデータバインド属性の登録も実行\r\n * - getTemplateById: 指定IDのテンプレートを取得（未登録時はエラーを投げる）\r\n *\r\n * 設計ポイント:\r\n * - テンプレート登録時にremoveEmptyTextNodesで空テキストノードを除去し、クリーンなDOMを維持\r\n * - registerDataBindAttributesでデータバインド属性を自動付与\r\n * - グローバルにテンプレートを一元管理し、ID経由で高速にアクセス可能\r\n * - 存在しないIDアクセス時はraiseErrorで明確な例外を発生\r\n */\r\nimport { registerDataBindAttributes } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { removeEmptyTextNodes } from \"./removeEmptyTextNodes.js\";\r\n\r\nconst templateById:Record<number, HTMLTemplateElement> = {};\r\n\r\nexport function registerTemplate(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number\r\n): number {\r\n  removeEmptyTextNodes(template.content);\r\n  registerDataBindAttributes(id, template.content, rootId);  \r\n  templateById[id] = template;\r\n  return id;\r\n}\r\n\r\nexport function getTemplateById(id: number): HTMLTemplateElement {\r\n  return templateById[id] ?? raiseError(`getTemplateById: template not found: ${id}`);\r\n}","/**\r\n * removeEmptyTextNodes.ts\r\n *\r\n * DocumentFragment内の空テキストノードを削除するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - content（DocumentFragment）の直下にある空白のみのテキストノードを検出し、削除する\r\n *\r\n * 設計ポイント:\r\n * - childNodesをArray.fromで配列化し、forEachで全ノードを走査\r\n * - nodeTypeがTEXT_NODEかつ、nodeValueが空白のみの場合にremoveChildで削除\r\n * - テンプレート処理やクリーンなDOM生成時に利用\r\n */\r\nexport function removeEmptyTextNodes(content:DocumentFragment):void {\r\n  Array.from(content.childNodes).forEach(node => {\r\n    if (node.nodeType === Node.TEXT_NODE && !(node.nodeValue ?? \"\").trim()) {\r\n      content.removeChild(node);\r\n    }\r\n  });  \r\n}\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IReadonlyStateProxy, IWritableStateProxy } from \"../StateClass/types\";\r\nimport { CreateBindingNodeByNodeFn, IBindingNode } from \"./BindingNode/types\";\r\nimport { CreateBindingStateByStateFn, IBindingState } from \"./BindingState/types\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\n\r\n/**\r\n * Bindingクラスは、1つのバインディング（ノードと状態の対応）を管理する中核的な実装です。\r\n *\r\n * 主な役割:\r\n * - DOMノードと状態（State）を結びつけるバインディングノード（bindingNode）とバインディング状態（bindingState）の生成・管理\r\n * - バインディングの初期化（init）、再描画（render）、状態値の更新（updateStateValue）などの処理を提供\r\n * - バージョン管理により、不要な再描画を防止\r\n *\r\n * 設計ポイント:\r\n * - createBindingNode, createBindingStateファクトリで柔軟なバインディング構造に対応\r\n * - renderでバージョン差分がある場合のみバインディングノードを更新\r\n * - 双方向バインディング時はupdateStateValueで状態プロキシに値を反映\r\n * - createBinding関数で一貫したバインディング生成を提供\r\n */\r\nclass Binding implements IBinding {\r\n  parentBindContent: IBindContent;\r\n  node             : Node;\r\n  engine           : IComponentEngine;\r\n  bindingNode      : IBindingNode;\r\n  bindingState     : IBindingState;\r\n  version          : number | undefined;\r\n  constructor(\r\n    parentBindContent : IBindContent,\r\n    node              : Node,\r\n    engine            : IComponentEngine,\r\n    createBindingNode : CreateBindingNodeByNodeFn, \r\n    createBindingState: CreateBindingStateByStateFn,\r\n  ) {\r\n    this.parentBindContent = parentBindContent\r\n    this.node = node;\r\n    this.engine = engine\r\n    this.bindingNode = createBindingNode(this, node, engine.inputFilters);\r\n    this.bindingState = createBindingState(this, engine.readonlyState, engine.outputFilters);\r\n  }\r\n\r\n  get bindContents() {\r\n    return this.bindingNode.bindContents;\r\n  }\r\n\r\n  init() {\r\n    this.bindingNode.init();\r\n    this.bindingState.init();\r\n  }\r\n\r\n  render() {\r\n    if (this.version !== this.engine.updater.version) {\r\n      try {\r\n        this.bindingNode.update();\r\n      } finally {\r\n        this.version = this.engine.updater.version;\r\n      }\r\n    }\r\n  }\r\n\r\n  updateStateValue(writeState:IWritableStateProxy, value: any) {\r\n    return this.bindingState.assignValue(writeState, value);\r\n  }\r\n}\r\n\r\n/**\r\n * バインディング生成用ファクトリ関数\r\n * - 各種ファクトリ・エンジン・ノード情報からBindingインスタンスを生成\r\n */\r\nexport function createBinding(\r\n  parentBindContent : IBindContent,\r\n  node              : Node, \r\n  engine            : IComponentEngine, \r\n  createBindingNode : CreateBindingNodeByNodeFn, \r\n  createBindingState: CreateBindingStateByStateFn\r\n): IBinding {\r\n  return new Binding(\r\n    parentBindContent, \r\n    node, \r\n    engine, \r\n    createBindingNode, \r\n    createBindingState\r\n  );\r\n}","/**\r\n * createLoopContext.ts\r\n *\r\n * ループバインディング（for等）で利用するLoopContext（ループコンテキスト）管理クラスとファクトリ関数の実装です。\r\n *\r\n * 主な役割:\r\n * - ループごとのプロパティパス・インデックス・BindContentを紐付けて管理\r\n * - 親ループコンテキストの探索やキャッシュ、インデックスの再割り当て・クリアなどを提供\r\n * - ループ階層をたどるwalk/serializeや、名前でのfind検索も可能\r\n *\r\n * 設計ポイント:\r\n * - WeakRefでlistIndexを保持し、GCフレンドリーな設計\r\n * - parentLoopContextで親ループを遅延探索・キャッシュし、効率的な親子関係管理を実現\r\n * - findで名前からループコンテキストを高速検索（キャッシュ付き）\r\n * - walk/serializeでループ階層をたどる処理を簡潔に記述可能\r\n * - createLoopContextファクトリで一貫した生成・管理が可能\r\n */\r\nimport { IBindContent } from \"../DataBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { ILoopContext } from \"./types\";\r\n\r\nclass LoopContext implements ILoopContext {\r\n  #path     : string;\r\n  #info        : IStructuredPathInfo;\r\n  #listIndexRef: WeakRef<IListIndex> | null;\r\n  #bindContent : IBindContent;\r\n  constructor(\r\n    path    : string | null,\r\n    listIndex  : IListIndex,\r\n    bindContent: IBindContent\r\n  ) {\r\n    this.#path = path ?? raiseError(\"name is required\");\r\n    this.#info = getStructuredPathInfo(this.#path);\r\n    this.#listIndexRef = new WeakRef(listIndex);\r\n    this.#bindContent = bindContent;\r\n  }\r\n  get path(): string {\r\n    return this.#path;\r\n  }\r\n  get info(): IStructuredPathInfo {\r\n    return this.#info;\r\n  }\r\n  get listIndex(): IListIndex {\r\n    return this.#listIndexRef?.deref() ?? raiseError(\"listIndex is null\");\r\n  }\r\n  get listIndexRef(): WeakRef<IListIndex> {\r\n    return this.#listIndexRef ?? raiseError(\"listIndexRef is null\");\r\n  }\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    this.#listIndexRef = new WeakRef(listIndex);\r\n    // 構造は変わらないので、#parentLoopContext、#cacheはクリアする必要はない\r\n  }\r\n  clearListIndex():void {\r\n    this.#listIndexRef = null;\r\n  }\r\n  get bindContent(): IBindContent {\r\n    return this.#bindContent;\r\n  }\r\n\r\n  #parentLoopContext: ILoopContext | null | undefined;\r\n  get parentLoopContext(): ILoopContext | null {\r\n    if (typeof this.#parentLoopContext === \"undefined\") {\r\n      let currentBinding: IBindContent | null = this.bindContent;\r\n      while(currentBinding !== null) {\r\n        if (currentBinding.loopContext !== null && currentBinding.loopContext !== this) {\r\n          this.#parentLoopContext = currentBinding.loopContext;\r\n          break;\r\n        }\r\n        currentBinding = currentBinding.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      if (typeof this.#parentLoopContext === \"undefined\") this.#parentLoopContext = null;\r\n    }\r\n    return this.#parentLoopContext;\r\n  }\r\n\r\n  #cache:Record<string, ILoopContext | null> = {};\r\n  find(name: string): ILoopContext | null {\r\n    let loopContext = this.#cache[name];\r\n    if (typeof loopContext === \"undefined\") {\r\n      let currentLoopContext: ILoopContext | null = this;\r\n      while(currentLoopContext !== null) {\r\n        if (currentLoopContext.path === name) break;\r\n        currentLoopContext = currentLoopContext.parentLoopContext;\r\n      }\r\n      loopContext = this.#cache[name] = currentLoopContext;\r\n    }\r\n    return loopContext;\r\n  }\r\n\r\n  walk(callback: (loopContext: ILoopContext) => void): void {\r\n    let currentLoopContext: ILoopContext | null = this;\r\n    while(currentLoopContext !== null) {\r\n      callback(currentLoopContext);\r\n      currentLoopContext = currentLoopContext.parentLoopContext;\r\n    }\r\n  }\r\n\r\n  serialize(): ILoopContext[] {\r\n    const results: ILoopContext[] = [];\r\n    this.walk((loopContext) => {\r\n      results.unshift(loopContext);\r\n    });\r\n    return results;\r\n  }\r\n\r\n}\r\n\r\n// 生成されたあと、IBindContentのloopContextに登録される\r\n// IBindContentにずっと保持される\r\nexport function createLoopContext(\r\n  pattern: string | null,\r\n  listIndex: IListIndex,\r\n  bindContent: IBindContent\r\n): ILoopContext {\r\n  return new LoopContext(pattern, listIndex, bindContent);\r\n}","/**\r\n * render.ts\r\n *\r\n * DataBindingのバインディング配列を受け取り、各バインディングのrender処理を実行するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - bindings配列を走査し、isSelectElementフラグが立っているものは後回しでレンダリング\r\n * - それ以外のバインディングは即時renderを実行\r\n * - select要素のバインディングは最後にまとめてrenderを実行（依存関係や描画順序の問題を回避）\r\n *\r\n * 設計ポイント:\r\n * - select要素の描画順序を制御することで、option要素のバインディングや値の整合性を担保\r\n * - 通常のバインディングとselect要素のバインディングを分離して処理\r\n */\r\nimport { IBinding } from \"../DataBinding/types\";\r\n\r\nexport function render(bindings: IBinding[]) {\r\n  const bindingsWithSelectElement = [];\r\n  for(let i = 0; i < bindings.length; i++) {\r\n    const binding = bindings[i];\r\n    if (binding.bindingNode.isSelectElement) {\r\n      bindingsWithSelectElement.push(binding);\r\n    } else {\r\n      binding.render();\r\n    }\r\n  }\r\n  for(let i = 0; i < bindingsWithSelectElement.length; i++) {\r\n    bindingsWithSelectElement[i].render();\r\n  }\r\n}\r\n","import { resolveNodeFromPath } from \"../BindingBuilder/resolveNodeFromPath.js\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { createBinding } from \"./Binding.js\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\nimport { createLoopContext } from \"../LoopContext/createLoopContext.js\";\r\nimport { render } from \"../Updater/render.js\";\r\nimport { getDataBindAttributesById } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\n\r\nfunction createContent(id: number): DocumentFragment {\r\n  const template = getTemplateById(id) ?? \r\n    raiseError(`BindContent: template is not found: ${id}`);\r\n  return document.importNode(template.content, true);\r\n}\r\n\r\nfunction createBindings(\r\n  bindContent: IBindContent, \r\n  id         : number, \r\n  engine     : IComponentEngine, \r\n  content    : DocumentFragment\r\n): IBinding[] {\r\n  const attributes = getDataBindAttributesById(id) ?? \r\n    raiseError(`BindContent: data-bind is not set`);\r\n  const bindings: IBinding[] = [];\r\n  for(let i = 0; i < attributes.length; i++) {\r\n    const attribute = attributes[i];\r\n    const node = resolveNodeFromPath(content, attribute.nodePath) ?? \r\n      raiseError(`BindContent: node is not found: ${attribute.nodePath}`);\r\n    for(let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      const creator = attribute.creatorByText.get(bindText) ?? \r\n        raiseError(`BindContent: creator is not found: ${bindText}`);\r\n      const binding = createBinding(\r\n        bindContent, \r\n        node, \r\n        engine, \r\n        creator.createBindingNode, \r\n        creator.createBindingState\r\n      );\r\n      bindings.push(binding);\r\n    }\r\n  }\r\n  return bindings;\r\n}\r\n\r\n/**\r\n * BindContentクラスは、テンプレートから生成されたDOM断片（DocumentFragment）と\r\n * そのバインディング情報（IBinding配列）を管理するための実装です。\r\n *\r\n * 主な役割:\r\n * - テンプレートIDからDOM断片を生成し、バインディング情報を構築\r\n * - mount/mountBefore/mountAfter/unmountでDOMへの挿入・削除を制御\r\n * - renderでバインディングの再描画、initで初期化処理を実行\r\n * - ループバインディング時のLoopContextやリストインデックス管理にも対応\r\n * - getLastNodeで再帰的に最後のノードを取得し、リスト描画や差し替えに利用\r\n * - assignListIndexでループ内のリストインデックスを再割り当てし、再初期化\r\n *\r\n * 設計ポイント:\r\n * - fragmentとchildNodesの両方を管理し、効率的なDOM操作を実現\r\n * - バインディング情報はテンプレートごとに動的に生成され、各ノードに紐付く\r\n * - ループや条件分岐など複雑なバインディング構造にも柔軟に対応\r\n * - createBindContentファクトリ関数で一貫した生成・初期化を提供\r\n */\r\nclass BindContent implements IBindContent {\r\n  loopContext  : ILoopContext | null;\r\n  parentBinding: IBinding | null;\r\n  childNodes   : Node[];\r\n  fragment     : DocumentFragment;\r\n  engine       : IComponentEngine | undefined;\r\n  #id;\r\n  get id() {\r\n    return this.#id;\r\n  }\r\n  get isMounted() {\r\n    return this.childNodes.length > 0 && this.childNodes[0].parentNode !== this.fragment;\r\n  }\r\n  get firstChildNode() {\r\n    return this.childNodes[0] ?? null;\r\n  }\r\n  get lastChildNode() {\r\n    return this.childNodes[this.childNodes.length - 1] ?? null;\r\n  }\r\n  getLastNode(parentNode: Node): Node | null {\r\n    const lastBinding = this.bindings[this.bindings.length - 1];\r\n    const lastChildNode = this.lastChildNode;\r\n    if (lastBinding.node === lastChildNode) {\r\n      if (lastBinding.bindContents.size > 0) {\r\n        const childBindContent = Array.from(lastBinding.bindContents).at(-1) ?? raiseError(`BindContent: childBindContent is not found`);\r\n        const lastNode = childBindContent.getLastNode(parentNode);\r\n        if (lastNode !== null) {\r\n          return lastNode;\r\n        }\r\n      }\r\n    }\r\n    if (parentNode !== lastChildNode?.parentNode) {\r\n      return null;\r\n    }\r\n    return lastChildNode;\r\n  }\r\n  #currentLoopContext: ILoopContext | null | undefined;\r\n  get currentLoopContext(): ILoopContext | null {\r\n    if (typeof this.#currentLoopContext === \"undefined\") {\r\n      let bindContent: IBindContent | null = this;\r\n      while(bindContent !== null) {\r\n        if (bindContent.loopContext !== null) break; ;\r\n        bindContent = bindContent.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      this.#currentLoopContext = bindContent?.loopContext ?? null;\r\n    }\r\n    return this.#currentLoopContext;\r\n  }\r\n  constructor(\r\n    parentBinding: IBinding | null,\r\n    id           : number, \r\n    engine       : IComponentEngine, \r\n    loopContext  : string | null,\r\n    listIndex    : IListIndex | null\r\n  ) {\r\n    this.parentBinding = parentBinding;\r\n    this.#id = id;\r\n    this.fragment = createContent(id);\r\n    this.childNodes = Array.from(this.fragment.childNodes);\r\n    this.engine = engine;\r\n    this.loopContext = (listIndex !== null) ? createLoopContext(loopContext, listIndex, this) : null;\r\n    this.bindings = createBindings(\r\n      this, \r\n      id, \r\n      engine, \r\n      this.fragment\r\n    );\r\n  }\r\n  mount(parentNode: Node) {\r\n    if (this.fragment.childNodes.length === 0) {\r\n      for(let i = 0; i < this.childNodes.length; i++) {\r\n        parentNode.appendChild(this.childNodes[i]);\r\n      }\r\n    } else {\r\n      parentNode.appendChild(this.fragment);\r\n    }\r\n  }\r\n  mountBefore(parentNode: Node, beforeNode: Node | null) {\r\n    if (this.fragment.childNodes.length === 0) {\r\n      for(let i = 0; i < this.childNodes.length; i++) {\r\n        parentNode.insertBefore(this.childNodes[i], beforeNode);\r\n      }\r\n    } else {\r\n      parentNode.insertBefore(this.fragment, beforeNode);\r\n    }\r\n  }\r\n  mountAfter(parentNode: Node, afterNode: Node | null) {\r\n    const beforeNode = afterNode?.nextSibling ?? null;\r\n    if (this.fragment.childNodes.length === 0) {\r\n      for(let i = 0; i < this.childNodes.length; i++) {\r\n        parentNode.insertBefore(this.childNodes[i], beforeNode);\r\n      }\r\n    } else {\r\n      parentNode.insertBefore(this.fragment, beforeNode);\r\n    }\r\n  }\r\n  unmount() {\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      this.fragment.appendChild(this.childNodes[i]);\r\n    }\r\n  }\r\n  bindings: IBinding[] = [];\r\n  render() {\r\n    render(this.bindings);\r\n  }\r\n  init() {\r\n    this.bindings.forEach(binding => binding.init());\r\n  }\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    if (this.loopContext == null) raiseError(`BindContent: loopContext is null`);\r\n    this.loopContext.assignListIndex(listIndex);\r\n    this.init();\r\n  }\r\n}\r\n\r\nexport function createBindContent(\r\n  parentBinding: IBinding | null,\r\n  id           : number, \r\n  engine       :IComponentEngine, \r\n  loopContext  : string | null, \r\n  listIndex    :IListIndex | null\r\n):IBindContent {\r\n  const bindContent = new BindContent(\r\n    parentBinding, \r\n    id, \r\n    engine, \r\n    loopContext, \r\n    listIndex\r\n  );\r\n  bindContent.init();\r\n  return bindContent;\r\n}","import { NodePath } from \"./types\";\r\n\r\n/**\r\n * ルートノードとノードパス（インデックス配列）から、該当するノードを辿って取得するユーティリティ関数。\r\n *\r\n * - NodePathは各階層でのchildNodesのインデックスを表す配列\r\n * - ルートから順にchildNodes[index]を辿り、該当ノードを返す\r\n * - パスが不正な場合やノードが存在しない場合はnullを返す\r\n *\r\n * @param root  探索の起点となるルートノード\r\n * @param path  各階層のインデックス配列（NodePath）\r\n * @returns     パスで指定されたノード、またはnull\r\n */\r\nexport function resolveNodeFromPath(root: Node, path: NodePath): Node | null {\r\n  return path.reduce((node, index) => node?.childNodes[index] ?? null, root);\r\n}","/**\r\n * createDependencyEdge.ts\r\n *\r\n * 依存関係グラフのエッジ（IDependencyEdge）を生成・キャッシュするユーティリティです。\r\n *\r\n * 主な役割:\r\n * - IStructuredPathInfo（プロパティパス情報）とDependencyType（依存種別）から一意なキーを生成\r\n * - 同じ依存エッジはキャッシュし、重複生成を防止\r\n * - createDependencyEdgeでIDependencyEdgeインスタンスを取得（キャッシュ利用）\r\n *\r\n * 設計ポイント:\r\n * - createDependencyKeyで「パターン@種別」の一意キーを生成\r\n * - cacheオブジェクトでIDependencyEdgeを再利用し、メモリ効率と比較効率を向上\r\n */\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { DependencyType, IDependencyEdge } from \"./types\";\r\n\r\n/**\r\n * infoとtypeから依存関係エッジの一意キーを生成\r\n */\r\nexport function createDependencyKey(info: IStructuredPathInfo, type: DependencyType): string {\r\n  return `${info.pattern}@${type}`;\r\n}\r\n\r\nconst cache: {[key:string]:IDependencyEdge} = {};;\r\n\r\n/**\r\n * 依存関係エッジ（IDependencyEdge）を生成・キャッシュして返す\r\n */\r\nexport function createDependencyEdge(\r\n  info: IStructuredPathInfo,\r\n  type: DependencyType,\r\n): IDependencyEdge {\r\n  const key = createDependencyKey(info, type);\r\n  return cache[key] ?? (cache[key] = { info, type });\r\n}\r\n","/**\r\n * createDependencyWalker.ts\r\n *\r\n * 依存関係グラフを辿るためのDependencyWalkerクラスと、その生成ファクトリです。\r\n *\r\n * 主な役割:\r\n * - 依存関係グラフ（dependentTree）を深さ優先で再帰的に探索し、各依存ノードに対してコールバックを実行\r\n * - ループ検出のためにtracedセットで訪問済みノードを管理し、無限ループを防止\r\n * - 依存種別（DependencyType）に応じて探索方法を柔軟に切り替え\r\n *\r\n * 設計ポイント:\r\n * - walkSubで再帰的に依存ノードを探索し、structured依存の場合は親のtypeを引き継ぐ\r\n * - tracedセットで一度訪れたノードは再訪しない\r\n * - walkでエントリポイントから探索を開始し、コールバックを全ノードに適用\r\n * - createDependencyWalkerファクトリで一貫した生成・利用が可能\r\n */\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { createDependencyKey } from \"./createDependencyEdge\";\r\nimport { DependencyType } from \"./types\";\r\n\r\nclass dependencyWalker {\r\n  engine: IComponentEngine;\r\n  entryRef: { info: IStructuredPathInfo, listIndex: IListIndex | null };\r\n  traced: Set<string> = new Set<string>();\r\n  constructor(\r\n    engine: IComponentEngine,\r\n    entryRef: { info: IStructuredPathInfo, listIndex: IListIndex | null },\r\n  ) {\r\n    this.engine = engine;\r\n    this.entryRef = entryRef;\r\n  }\r\n\r\n  walkSub(\r\n    info: IStructuredPathInfo,\r\n    type: DependencyType,\r\n    callback: (ref: IStatePropertyRef, info: IStructuredPathInfo, type: DependencyType) => void\r\n  ) {\r\n    const key = createDependencyKey(info, type);\r\n    if (this.traced.has(key)) {\r\n      return;\r\n    }\r\n    this.traced.add(key);\r\n    callback(this.entryRef, info, type);\r\n    const edges = this.engine.dependentTree.get(info) ?? [];\r\n    for(const edge of edges) {\r\n      const overridedType = edge.type === \"structured\" ? type : edge.type;\r\n      this.walkSub(edge.info, overridedType, callback);\r\n    }\r\n\r\n  }\r\n  walk(\r\n    callback: (ref: IStatePropertyRef, info: IStructuredPathInfo, type: DependencyType) => void\r\n  ) {\r\n    const traced = new Set<IStructuredPathInfo>();\r\n    this.walkSub(this.entryRef.info, \"structured\", callback);\r\n  } \r\n\r\n}\r\n\r\nexport function createDependencyWalker(\r\n  engine: IComponentEngine,\r\n  entryRef: { info: IStructuredPathInfo, listIndex: IListIndex | null },\r\n) {\r\n  return new dependencyWalker(engine, entryRef);\r\n}","/**\r\n * createListIndex.ts\r\n *\r\n * リストバインディングやループ処理で利用する「リストインデックス」管理クラスとファクトリ関数の実装です。\r\n *\r\n * 主な役割:\r\n * - ListIndexクラスで多重ループやネスト構造のインデックス情報をツリー状に管理\r\n * - indexes, position, lengthなどで階層的なインデックス情報を取得可能\r\n * - iterator/reverseIteratorで親子関係を辿るイテレータを提供\r\n * - atメソッドで指定位置のListIndexをキャッシュ付きで取得（WeakRefによるメモリ効率化）\r\n * - truncateで指定長さまでの親ListIndexを取得\r\n * - addで新たな子ListIndexを生成\r\n *\r\n * 設計ポイント:\r\n * - ListIndexは親子関係を持つことで多重ループやforバインディングに柔軟に対応\r\n * - atメソッドはキャッシュとWeakRefを活用し、GCフレンドリーかつ高速なインデックス参照を実現\r\n * - createListIndexファクトリで一貫した生成・管理が可能\r\n * - getMaxListIndexIdで現在の最大IDを取得可能（デバッグや管理用途）\r\n */\r\nimport { IListIndex } from \"./types\";\r\n\r\nclass ListIndex implements IListIndex {\r\n  static id: number = 0;\r\n  id              : number = ++ListIndex.id;\r\n  #parentListIndex: IListIndex | null = null;\r\n  get parentListIndex(): IListIndex | null {\r\n    return this.#parentListIndex;\r\n  }\r\n  index: number;\r\n  get indexes(): number[] {\r\n    const indexes = this.parentListIndex?.indexes ?? [];\r\n    indexes.push(this.index);\r\n    return indexes;\r\n  }\r\n\r\n  get position(): number {\r\n    return (this.parentListIndex?.position ?? -1) + 1;\r\n  }\r\n\r\n  get length(): number {\r\n    return (this.parentListIndex?.length ?? 0) + 1;\r\n  }\r\n  \r\n  constructor(\r\n    parentListIndex: IListIndex | null,\r\n    index: number\r\n  ) {\r\n    this.#parentListIndex = parentListIndex;\r\n    this.index = index;\r\n  }\r\n  \r\n  truncate(length: number): IListIndex | null {\r\n    let listIndex: IListIndex | null = this;\r\n    while(listIndex !== null) {\r\n      if (listIndex.position < length) return listIndex;\r\n      listIndex = listIndex.parentListIndex;\r\n    }\r\n    return null;\r\n  }\r\n  add(value: number): IListIndex {\r\n    return new ListIndex(this, value);\r\n  }\r\n\r\n  *reverseIterator(): Generator<IListIndex> {\r\n    yield this;\r\n    if (this.parentListIndex !== null) {\r\n      yield* this.parentListIndex.reverseIterator();\r\n    }\r\n    return;\r\n  }\r\n\r\n  *iterator(): Generator<IListIndex> {\r\n    if (this.parentListIndex !== null) {\r\n      yield* this.parentListIndex.iterator();\r\n    }\r\n    yield this;\r\n    return;\r\n  }\r\n\r\n  toString(): string {\r\n    const parentListIndex = this.parentListIndex?.toString();\r\n    return (parentListIndex !== null) ? parentListIndex + \",\" + this.index.toString() : this.index.toString();\r\n  }\r\n\r\n  #atcache:{[key:number]:(WeakRef<IListIndex> | null)} = {};\r\n  at(position: number): IListIndex | null {\r\n    const value = this.#atcache[position];\r\n    if (value !== undefined) {\r\n      return value ? (value.deref() ?? null) : null;\r\n    }\r\n    let iterator;\r\n    if (position >= 0) {\r\n      iterator = this.iterator();\r\n    } else {\r\n      position = - position - 1 \r\n      iterator = this.reverseIterator();\r\n    }\r\n    let next;\r\n    while(position >= 0) {\r\n      next = iterator.next();\r\n      position--;\r\n    }\r\n    const lisIndex = next?.value ?? null;\r\n    this.#atcache[position] = lisIndex ? new WeakRef(lisIndex) : null;\r\n    return lisIndex;\r\n  }\r\n  \r\n}\r\n\r\nexport function createListIndex(\r\n  parentListIndex: IListIndex | null,\r\n  index          : number\r\n): IListIndex {\r\n  return new ListIndex(parentListIndex, index);\r\n}\r\n\r\nexport function getMaxListIndexId(): number {\r\n  return ListIndex.id;\r\n}\r\n","/**\r\n * listWalker.ts\r\n *\r\n * Stateプロパティのワイルドカード（配列・多重ループ）に対応したリスト探索ユーティリティです。\r\n *\r\n * 主な役割:\r\n * - 指定したプロパティパス（IStructuredPathInfo）とリストインデックス（IListIndex）に対し、\r\n *   再帰的に全てのリスト要素（多重ループ含む）を探索し、コールバックを実行\r\n * - ワイルドカード階層が一致した場合のみコールバックを呼び出し、それ以外は親階層を辿って再帰探索\r\n *\r\n * 設計ポイント:\r\n * - listWalkerSubで再帰的にリストインデックスを探索し、全要素に対してコールバックを適用\r\n * - listWalkerでエントリポイントを提供し、外部から簡単に利用可能\r\n * - 多重ループやネストした配列バインディングにも柔軟に対応\r\n */\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils\";\r\n\r\nfunction listWalkerSub(\r\n  engine: IComponentEngine,\r\n  info: IStructuredPathInfo, \r\n  listIndex: IListIndex | null, \r\n  callback:(info: IStructuredPathInfo, listIndex: IListIndex | null)=> void\r\n) {\r\n  const listIndexLen = listIndex?.length ?? 0;\r\n  if (info.wildcardCount === listIndexLen) {\r\n    callback(info, listIndex);\r\n  } else {\r\n    const parentInfo = info.wildcardParentInfos[listIndexLen] ?? raiseError(\"Invalid state property info\");\r\n    const listIndexes = engine.getListIndexesSet(parentInfo, listIndex);\r\n    for(const subListIndex of listIndexes ?? []) {\r\n      listWalkerSub(engine, info, subListIndex, callback);\r\n    }\r\n  }\r\n}\r\n\r\nexport function listWalker(\r\n  engine: IComponentEngine,\r\n  info:IStructuredPathInfo, \r\n  listIndex: IListIndex | null,\r\n  callback:(info: IStructuredPathInfo, listIndex: IListIndex | null)=> void\r\n) {\r\n  listWalkerSub(engine, info, listIndex, callback);\r\n}\r\n","/**\r\n * getStatePropertyRef.ts\r\n *\r\n * StatePropertyRefのユーティリティとして、構造化パス情報（IStructuredPathInfo）と\r\n * リストインデックス（IListIndex）から一意な参照キー（refKey）を生成する関数です。\r\n *\r\n * 主な役割:\r\n * - info.idとlistIndex.idを組み合わせて、StatePropertyRefを一意に識別するキーを生成\r\n * - listIndexがnullの場合は0を利用し、全ての参照に対して一貫したキーを提供\r\n *\r\n * 設計ポイント:\r\n * - キャッシュや依存解決など、StatePropertyRefの識別・管理に利用\r\n * - シンプルな文字列連結で高速かつ衝突のないキー生成を実現\r\n */\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\n\r\nexport function createRefKey(\r\n  info: IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n) {\r\n  return info.id + \":\" + (listIndex?.id ?? 0);\r\n}\r\n\r\n","/**\r\n * restructListIndex.ts\r\n *\r\n * StateClassのリストインデックス構造を再構築するためのユーティリティです。\r\n *\r\n * 主な役割:\r\n * - buildListIndexTree: 指定されたinfo/listIndex/valueに基づき、リストインデックスのツリー構造を再構築・更新\r\n *   - 既存のリストインデックスと新しいリスト要素を比較し、必要に応じてインデックスを再割り当て\r\n *   - インデックス変更時はengine.updater.addUpdatedListIndexで更新情報を登録\r\n *   - 新しいリストインデックス集合をengine.saveListIndexesSetで保存\r\n * - restructListIndexes: 依存関係を辿りながら、必要なリストインデックスの再構築を一括で実行\r\n *   - 依存関係のある全てのinfo/listIndexに対してbuildListIndexTreeを呼び出し\r\n *   - キャッシュやrefKeyを利用して重複処理や不要な再構築を防止\r\n *   - config.optimizeListElementsやoptimizeListによる最適化にも対応\r\n *\r\n * 設計ポイント:\r\n * - 依存関係の再帰的な探索と、リストインデックスの効率的な再利用・再構築を両立\r\n * - スワップや最適化設定時のスキップ処理、キャッシュによる高速化\r\n * - リストバインディングや多重ループ時のインデックス整合性を担保\r\n */\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { createDependencyWalker } from \"../DependencyWalker/createDependencyWalker\";\r\nimport { createListIndex } from \"../ListIndex/createListIndex\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { listWalker } from \"../ListWalker/listWalker\";\r\nimport { GetByRefSymbol } from \"../StateClass/symbols\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { createRefKey } from \"../StatePropertyRef/getStatePropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { config } from \"../WebComponents/getGlobalConfig\";\r\n\r\nconst BLANK_LISTINDEXES_SET = new Set<IListIndex>();\r\n\r\nfunction buildListIndexTree(\r\n  engine   : IComponentEngine, \r\n  info     : IStructuredPathInfo,\r\n  listIndex: IListIndex | null, \r\n  value: any[]\r\n): void {\r\n  const oldValue = engine.getList(info, listIndex) ?? [];\r\n  if (oldValue === value) {\r\n    return;\r\n  }\r\n  const newListIndexesSet:Set<IListIndex> = new Set();\r\n  const oldListIndexesSet = engine.getListIndexesSet(info, listIndex) ?? BLANK_LISTINDEXES_SET;\r\n  const oldListIndexesByItem = Map.groupBy(oldListIndexesSet, listIndex => oldValue[listIndex.index]);\r\n  for(let i = 0; i < value.length; i++) {\r\n    // リスト要素から古いリストインデックスを取得して、リストインデックスを更新する\r\n    // もし古いリストインデックスがなければ、新しいリストインデックスを作成する\r\n    let curListIndex = oldListIndexesByItem.get(value[i])?.shift() ?? createListIndex(listIndex, i);\r\n    if (curListIndex.index !== i) {\r\n      curListIndex.index = i;\r\n      // リストインデックスのインデックスを更新したので、リストインデックスを登録する\r\n      engine.updater.addUpdatedListIndex(curListIndex);\r\n    }\r\n    // リストインデックスを新しいリストインデックスセットに追加する\r\n    newListIndexesSet.add(curListIndex);\r\n  }\r\n  // 新しいリストインデックスセットを保存する\r\n  engine.saveListIndexesSet(info, listIndex, newListIndexesSet);\r\n  engine.saveList(info, listIndex, value.slice(0)); // コピーを保存\r\n\r\n}\r\n\r\nexport function restructListIndexes(\r\n  infos: IStatePropertyRef[],\r\n  engine: IComponentEngine,\r\n  updateValues: {[key:string]: any[]},\r\n  refKeys: Set<string>,\r\n  cache: Map<IStructuredPathInfo, Set<IListIndex|null>>,\r\n) {\r\n  for(const {info, listIndex} of infos) {\r\n    if (config.optimizeListElements && engine.elementInfoSet.has(info)) {\r\n      // スワップ処理のためスキップ\r\n      continue;\r\n    }\r\n    const dependentWalker = createDependencyWalker(engine, {info, listIndex});\r\n    const nowOnList = config.optimizeList && engine.listInfoSet.has(info);\r\n    dependentWalker.walk((ref, refInfo, type) => {\r\n      if (nowOnList && type === \"structured\" && ref.info !== refInfo) {\r\n        if (refInfo.cumulativeInfoSet.has(ref.info)) {\r\n          return;\r\n        }\r\n      }\r\n      const wildcardMatchPaths = Array.from(ref.info.wildcardInfoSet.intersection(refInfo.wildcardInfoSet));\r\n      const longestMatchAt = (wildcardMatchPaths.at(-1)?.wildcardCount ?? 0) - 1;\r\n      const listIndex = (longestMatchAt >= 0) ? (ref.listIndex?.at(longestMatchAt) ?? null) : null;\r\n      listWalker(engine, refInfo, listIndex, (_info, _listIndex) => {\r\n        if (!engine.existsBindingsByInfo(_info)) {\r\n          return;\r\n        }\r\n        const refKey = createRefKey(_info, _listIndex);\r\n        if (refKeys.has(refKey)) {\r\n          return;\r\n        }\r\n        let cacheListIndexSet = cache.get(_info);\r\n        if (!cacheListIndexSet) {\r\n          cacheListIndexSet = new Set<IListIndex|null>();\r\n          cache.set(_info, cacheListIndexSet);\r\n        }\r\n        cacheListIndexSet.add(_listIndex);\r\n        refKeys.add(refKey);\r\n        if (engine.listInfoSet.has(_info)) {\r\n          const values = updateValues[refKey] ?? engine.readonlyState[GetByRefSymbol](_info, _listIndex);\r\n          buildListIndexTree(engine, _info, _listIndex, values);\r\n        }\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\n","/**\r\n * updater.ts\r\n *\r\n * StateClassの更新処理・変更検知・再描画を一元管理するUpdaterクラスの実装ファイルです。\r\n *\r\n * 主な役割:\r\n * - Stateプロパティやリストインデックスの変更を検知し、再描画や依存解決をトリガー\r\n * - addUpdatedStatePropertyRefValue/addUpdatedListIndexで変更情報を登録し、entryRenderで描画処理をエントリーポイント化\r\n * - rebuildで変更の影響範囲を再計算し、必要なバインディングやリストインデックスの再構築を実行\r\n * - renderでバインディング配列をまとめて描画\r\n *\r\n * 設計ポイント:\r\n * - 変更検知・再描画を非同期でバッチ処理し、パフォーマンスを最適化\r\n * - リストバインディングや多重ループ、スワップ・最適化にも対応\r\n * - StateClassエンジンとの連携やキャッシュ機構も考慮した設計\r\n */\r\nimport { IBinding } from \"../DataBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { render } from \"./render.js\";\r\nimport { SetCacheableSymbol } from \"../StateClass/symbols.js\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IUpdater } from \"./types\";\r\nimport { restructListIndexes } from \"./restructListIndex\";\r\nimport { createRefKey } from \"../StatePropertyRef/getStatePropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\n\r\ntype UpdatedArrayElementBinding = {\r\n  parentRef: IStatePropertyRef;\r\n  binding: IBinding;\r\n  listIndexes: IListIndex[];\r\n  values: any[];\r\n};\r\n\r\nclass Updater implements IUpdater {\r\n  updatedProperties: Set<IStatePropertyRef | IListIndex> = new Set;\r\n  updatedValues    : {[key:string]: any} = {};\r\n  engine           : IComponentEngine;\r\n  #version         : number = 0;\r\n\r\n  constructor(engine: IComponentEngine) {\r\n    this.engine = engine;\r\n  }\r\n\r\n  get version(): number {\r\n    return this.#version;\r\n  }\r\n\r\n  addProcess(process: () => Promise<void> | void): void {\r\n    queueMicrotask(process);\r\n  }\r\n\r\n  addUpdatedStatePropertyRefValue(\r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex | null, \r\n    value    : any\r\n  ): void {\r\n    const refKey = createRefKey(info, listIndex);\r\n    this.updatedProperties.add({info, listIndex});\r\n    this.updatedValues[refKey] = value;\r\n    this.entryRender();\r\n  }\r\n\r\n  addUpdatedListIndex(listIndex: IListIndex): void {\r\n    this.updatedProperties.add(listIndex);\r\n    this.entryRender();\r\n  }\r\n\r\n  #isEntryRender = false;\r\n  entryRender() {\r\n    if (this.#isEntryRender) return;\r\n    this.#isEntryRender = true;\r\n    queueMicrotask(() => {\r\n      try {\r\n        const { bindings, arrayElementBindings } = this.rebuild();\r\n        // render\r\n        for(const arrayElementBinding of arrayElementBindings) {\r\n          arrayElementBinding.binding.bindingNode.updateElements(arrayElementBinding.listIndexes, arrayElementBinding.values);\r\n        }\r\n        if (bindings.length > 0) {\r\n          this.render(bindings);\r\n        }\r\n      } finally {\r\n        this.#isEntryRender = false;\r\n      }\r\n    });\r\n  }\r\n\r\n  rebuild(): {bindings: IBinding[], arrayElementBindings: UpdatedArrayElementBinding[]} {\r\n    const retArrayElementBindings: UpdatedArrayElementBinding[] = [];\r\n    const retBindings: IBinding[] = [];\r\n    const engine = this.engine;\r\n    while(this.updatedProperties.size > 0) {\r\n      const updatedProiperties = Array.from(this.updatedProperties.values());\r\n      this.updatedProperties.clear();\r\n      const bindingsByListIndex: IBinding[] = [];\r\n      const updatedRefs: IStatePropertyRef[] = []; // 更新されたプロパティ参照のリスト\r\n      const arrayElementBindingByParentRefKey = new Map<string, Partial<UpdatedArrayElementBinding>>();\r\n      for(let i = 0; i < updatedProiperties.length; i++) {\r\n        const item = updatedProiperties[i];\r\n        if (\"index\" in item) {\r\n          const bindings = engine.bindingsByListIndex.get(item as IListIndex) ?? [];\r\n          bindingsByListIndex.push(...bindings);\r\n        } else {\r\n          updatedRefs.push(item as IStatePropertyRef);\r\n          if (engine.elementInfoSet.has(item.info)) {\r\n            const parentInfo = item.info.parentInfo ?? raiseError(\"info is null\"); // リストのパス情報\r\n            const parentListIndex = item.listIndex?.at(-2) ?? null; // リストのインデックス\r\n            const parentRef = {info: parentInfo, listIndex: parentListIndex};\r\n            const parentRefKey = createRefKey(parentInfo, parentListIndex);\r\n            let info = arrayElementBindingByParentRefKey.get(parentRefKey);\r\n            if (!info) {\r\n              info = {\r\n                parentRef,\r\n                listIndexes: [],\r\n                values: []\r\n              };\r\n              arrayElementBindingByParentRefKey.set(parentRefKey, info);\r\n            }\r\n            const refKey = createRefKey(item.info, item.listIndex);\r\n            const value = this.updatedValues[refKey] ?? null;\r\n            info.values?.push(value);\r\n            info.listIndexes?.push(item.listIndex as IListIndex);\r\n          }\r\n        }\r\n      }\r\n      // リストインデックスの構築\r\n      const builtStatePropertyRefKeySet = new Set<string>();\r\n      const affectedRefs = new Map<IStructuredPathInfo, Set<IListIndex|null>>();\r\n      restructListIndexes(updatedRefs, engine, this.updatedValues, builtStatePropertyRefKeySet, affectedRefs);\r\n\r\n      // スワップの場合の情報を構築する\r\n      for(const [parentRefKey, info] of arrayElementBindingByParentRefKey) {\r\n        const parentInfo = info.parentRef?.info ?? raiseError(\"parentInfo is null\");\r\n        const parentListIndex = info.parentRef?.listIndex ?? null;\r\n        const bindings = engine.getBindings(parentInfo, parentListIndex);\r\n        for(const binding of bindings) {\r\n          if (!binding.bindingNode.isFor) {\r\n            continue;\r\n          }\r\n          const bindingInfo = Object.assign({}, info, { binding });\r\n          retArrayElementBindings.push(bindingInfo as UpdatedArrayElementBinding);\r\n        }\r\n      }\r\n      // 影響する全てのバインド情報を取得する\r\n      for(const [ info, listIndexes ] of affectedRefs.entries()) {\r\n        for(const listIndex of listIndexes) {\r\n          const bindings = engine.getBindings(info, listIndex);\r\n          retBindings.push(...bindings ?? []);\r\n        }\r\n      }\r\n      retBindings.push(...bindingsByListIndex);\r\n    }\r\n    this.updatedValues = {};\r\n    return {bindings: retBindings, arrayElementBindings: retArrayElementBindings};\r\n  }\r\n\r\n  render(bindings: IBinding[]) {\r\n    this.#version++;\r\n    this.engine.readonlyState[SetCacheableSymbol](() => {\r\n      return render(bindings);\r\n    });\r\n  }\r\n}\r\n\r\nexport function createUpdater(engine: IComponentEngine): IUpdater {\r\n  return new Updater(engine);\r\n}\r\n\r\n","import { raiseError } from \"../utils.js\";\r\nimport { IComponentConfig } from \"../WebComponents/types\";\r\nimport { canHaveShadowRoot } from \"./canHaveShadowRoot.js\";\r\n\r\nfunction getParentShadowRoot(parentNode: Node | null): ShadowRoot|undefined{\r\n  let node: Node | null = parentNode;\r\n  while(node) {\r\n    if (node instanceof ShadowRoot) {\r\n      return node;\r\n    }\r\n    node = node.parentNode;\r\n  }\r\n}\r\n\r\n/**\r\n * 指定したHTMLElementにShadow DOMをアタッチし、スタイルシートを適用するユーティリティ関数。\r\n *\r\n * - config.enableShadowDomがtrueの場合は、ShadowRootを生成し、adoptedStyleSheetsでスタイルを適用\r\n * - extends指定がある場合はcanHaveShadowRootで拡張可能かチェック\r\n * - Shadow DOMを使わない場合は、親のShadowRootまたはdocumentにスタイルシートを追加\r\n * - すでに同じスタイルシートが含まれていれば重複追加しない\r\n *\r\n * @param element    対象のHTMLElement\r\n * @param config     コンポーネント設定\r\n * @param styleSheet 適用するCSSStyleSheet\r\n * @throws           Shadow DOM非対応の組み込み要素を拡張しようとした場合はエラー\r\n */\r\nexport function attachShadow(element: HTMLElement, config: IComponentConfig, styleSheet: CSSStyleSheet): void {\r\n    if (config.enableShadowDom) {\r\n      if (config.extends === null || canHaveShadowRoot(config.extends)) {\r\n        const shadowRoot = element.attachShadow({ mode: 'open' });\r\n        shadowRoot.adoptedStyleSheets = [styleSheet];\r\n      } else {\r\n        raiseError(`ComponentEngine: Shadow DOM not supported for builtin components that extend ${config.extends}`);\r\n      }\r\n    } else {\r\n      const shadowRootOrDocument = getParentShadowRoot(element.parentNode) || document;\r\n      const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n      if (!styleSheets.includes(styleSheet)) {\r\n        shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, styleSheet];\r\n      }\r\n    }\r\n\r\n}","/**\r\n * 指定したタグ名の要素がShadowRootを持てるかどうかを判定するユーティリティ関数。\r\n *\r\n * - 指定タグ名で要素を生成し、attachShadowメソッドが存在するかどうかで判定\r\n * - 無効なタグ名やattachShadow未対応の場合はfalseを返す\r\n *\r\n * @param tagName 判定したい要素のタグ名（例: \"div\", \"span\", \"input\" など）\r\n * @returns       ShadowRootを持てる場合はtrue、持てない場合はfalse\r\n */\r\nexport function canHaveShadowRoot(tagName: string): boolean {\r\n  try {\r\n    // 一時的に要素を作成\r\n    const element = document.createElement(tagName);\r\n    // `attachShadow` メソッドが存在し、実行可能かを確認\r\n    return typeof element.attachShadow === \"function\";\r\n  } catch {\r\n    // 無効なタグ名などが渡された場合は false を返す\r\n    return false;\r\n  }\r\n}\r\n","import { createListIndex } from \"../ListIndex/createListIndex.js\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { GetByRefSymbol } from \"./symbols.js\";\r\n\r\nconst BLANK_LISTINDEXES_SET = new Set<IListIndex>();\r\n\r\nfunction buildListIndexTreeSub(\r\n  engine   : IComponentEngine, \r\n  listInfos: Set<IStructuredPathInfo>,\r\n  info     : IStructuredPathInfo,\r\n  listIndex: IListIndex | null, \r\n  value: any[]\r\n): void {\r\n  const oldValue = engine.getList(info, listIndex) ?? [];\r\n  if (oldValue === value) {\r\n    return;\r\n  }\r\n  const newListIndexesSet:Set<IListIndex> = new Set();\r\n  const oldListIndexesSet = engine.getListIndexesSet(info, listIndex) ?? BLANK_LISTINDEXES_SET;\r\n  const oldListIndexesByItem = Map.groupBy(oldListIndexesSet, listIndex => oldValue[listIndex.index]);\r\n  for(let i = 0; i < value.length; i++) {\r\n    // リスト要素から古いリストインデックスを取得して、リストインデックスを更新する\r\n    // もし古いリストインデックスがなければ、新しいリストインデックスを作成する\r\n    let curListIndex = oldListIndexesByItem.get(value[i])?.shift() ?? createListIndex(listIndex, i);\r\n    if (curListIndex.index !== i) {\r\n      curListIndex.index = i;\r\n      // リストインデックスのインデックスを更新したので、リストインデックスを登録する\r\n      engine.updater.addUpdatedListIndex(curListIndex);\r\n    }\r\n    // リストインデックスを新しいリストインデックスセットに追加する\r\n    newListIndexesSet.add(curListIndex);\r\n  }\r\n  // 新しいリストインデックスセットを保存する\r\n  engine.saveListIndexesSet(info, listIndex, newListIndexesSet);\r\n  engine.saveList(info, listIndex, value.slice(0)); // コピーを保存\r\n\r\n  // サブ要素のリストインデックスを構築する\r\n  const searchPath = info.pattern + \".*\";\r\n  for(const info of listInfos) {\r\n    if (searchPath !== info.lastWildcardPath) {\r\n      continue;\r\n    }\r\n    for(const subListIndex of newListIndexesSet) {\r\n      const subValue = engine.readonlyState[GetByRefSymbol](info, subListIndex);\r\n      buildListIndexTreeSub(\r\n        engine, \r\n        listInfos, \r\n        info, \r\n        subListIndex, \r\n        subValue ?? []\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport function buildListIndexTree(\r\n  engine   : IComponentEngine, \r\n  info     : IStructuredPathInfo,\r\n  listIndex: IListIndex | null, \r\n  value    : any\r\n): void {\r\n  const listInfos = engine.listInfoSet;\r\n  // 配列じゃなければ何もしない\r\n  if (!engine.listInfoSet.has(info)) {\r\n    return;\r\n  }\r\n  const values = (value ?? []) as any[];\r\n  buildListIndexTreeSub(\r\n    engine, \r\n    engine.listInfoSet, \r\n    info, \r\n    listIndex, \r\n    values\r\n  );\r\n}\r\n","/**\r\n * getResolvedPathInfo.ts\r\n *\r\n * Stateプロパティ名（パス文字列）から、ワイルドカードやインデックス情報を含む\r\n * 詳細なパス情報（IResolvedPathInfo）を解析・生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - プロパティ名を分解し、ワイルドカードやインデックスの有無・種別を判定\r\n * - context/all/partial/none のワイルドカード種別を自動判定\r\n * - パスごとにキャッシュし、再利用性とパフォーマンスを両立\r\n * - getStructuredPathInfoで構造化パス情報も取得\r\n *\r\n * 設計ポイント:\r\n * - \"constructor\"や\"toString\"などの予約語も扱えるよう、Mapではなくオブジェクトでキャッシュ\r\n * - ワイルドカード（*）や数値インデックスを柔軟に判定し、wildcardIndexesに格納\r\n * - context型は未確定インデックス、all型は全て確定インデックス、partial型は混在を示す\r\n * - ResolvedPathInfoクラスでパス解析・情報保持を一元化\r\n */\r\nimport { IResolvedPathInfo, WildcardType } from './types';\r\nimport { getStructuredPathInfo } from './getStructuredPathInfo.js';\r\n\r\n/**\r\n * プロパティ名に\"constructor\"や\"toString\"などの予約語やオブジェクトのプロパティ名を\r\n * 上書きするような名前も指定できるように、Mapを検討したが、そもそもそのような名前を\r\n * 指定することはないと考え、Mapを使わないことにした。\r\n */\r\nconst _cache: { [key:string]: IResolvedPathInfo } = {};\r\n//const _cache: Map<string, IResolvedPathInfo> = new Map();\r\n\r\nclass ResolvedPathInfo implements IResolvedPathInfo {\r\n  static id : number = 0;\r\n  id = ++ResolvedPathInfo.id;\r\n  name;\r\n  elements;\r\n  paths;\r\n  wildcardCount;\r\n  wildcardType;\r\n  wildcardIndexes;\r\n  info;\r\n  constructor(name: string) {\r\n    const elements = name.split(\".\");\r\n    const tmpPatternElements = elements.slice();\r\n    const paths = [];\r\n    let incompleteCount = 0;\r\n    let completeCount = 0;\r\n    let lastPath = \"\";\r\n    let wildcardCount = 0;\r\n    let wildcardType: WildcardType = \"none\";\r\n    let wildcardIndexes: (number | null)[] = [];\r\n    for(let i = 0; i < elements.length; i++) {\r\n      const element = elements[i];\r\n      if (element === \"*\") {\r\n        tmpPatternElements[i] = \"*\";\r\n        wildcardIndexes.push(null);\r\n        incompleteCount++;\r\n        wildcardCount++;\r\n      } else {\r\n        const number = Number(element);\r\n        if (!Number.isNaN(number)) {\r\n          tmpPatternElements[i] = \"*\";\r\n          wildcardIndexes.push(number);\r\n          completeCount++;\r\n          wildcardCount++;\r\n        }\r\n      }\r\n      lastPath += element;\r\n      paths.push(lastPath);\r\n      lastPath += (i < elements.length - 1 ? \".\" : \"\");\r\n    }\r\n    const pattern = tmpPatternElements.join(\".\");\r\n    const info = getStructuredPathInfo(pattern);\r\n    if (incompleteCount > 0 || completeCount > 0) {\r\n      if (incompleteCount === wildcardCount) {\r\n        wildcardType = \"context\";\r\n      } else if (completeCount === wildcardCount) {\r\n        wildcardType = \"all\";\r\n      } else {\r\n        wildcardType = \"partial\";\r\n      }\r\n    }\r\n    this.name = name;\r\n    this.elements = elements;\r\n    this.paths = paths;\r\n    this.wildcardCount = wildcardCount;\r\n    this.wildcardType = wildcardType;\r\n    this.wildcardIndexes = wildcardIndexes;\r\n    this.info = info;\r\n  }\r\n}\r\n\r\nexport function getResolvedPathInfo(name:string):IResolvedPathInfo {\r\n  let nameInfo: IResolvedPathInfo | undefined;\r\n//  return _cache.get(name) ?? (_cache.set(name, nameInfo = new ResolvedPathInfo(name)), nameInfo);\r\n  return _cache[name] ?? (_cache[name] = new ResolvedPathInfo(name));\r\n}","/**\r\n * getContextListIndex.ts\r\n *\r\n * StateClassの内部APIとして、現在のプロパティ参照スコープにおける\r\n * 指定したstructuredPath（ワイルドカード付きプロパティパス）に対応する\r\n * リストインデックス（IListIndex）を取得する関数です。\r\n *\r\n * 主な役割:\r\n * - handlerの最後にアクセスされたStatePropertyRefから、指定パスに対応するリストインデックスを取得\r\n * - ワイルドカード階層に対応し、多重ループやネストした配列バインディングにも利用可能\r\n *\r\n * 設計ポイント:\r\n * - 直近のプロパティ参照情報を取得\r\n * - info.wildcardPathsからstructuredPathのインデックスを特定\r\n * - listIndex.at(index)で該当階層のリストインデックスを取得\r\n * - パスが一致しない場合や参照が存在しない場合はnullを返す\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\nexport function getContextListIndex(\r\n  handler: IStateHandler,\r\n  structuredPath: string\r\n): IListIndex | null {\r\n  const info = handler.structuredPathInfoStack[handler.refIndex];\r\n  if (typeof info === \"undefined\" || info === null) {\r\n    return null;\r\n  }\r\n  const index = info.indexByWildcardPath[structuredPath];\r\n  if (index >= 0) {\r\n    const listIndex = handler.listIndexStack[handler.refIndex];\r\n    if (typeof listIndex === \"undefined\") {\r\n      return null;\r\n    }\r\n    return listIndex?.at(index) ?? null;\r\n  }\r\n  return null;\r\n}\r\n","/**\r\n * getListIndex.ts\r\n *\r\n * StateClassの内部APIとして、パス情報（IResolvedPathInfo）から\r\n * 対応するリストインデックス（IListIndex）を取得する関数です。\r\n *\r\n * 主な役割:\r\n * - パスのワイルドカード種別（context/all/partial/none）に応じてリストインデックスを解決\r\n * - context型は現在のループコンテキストからリストインデックスを取得\r\n * - all型は各階層のリストインデックス集合からインデックスを辿って取得\r\n * - partial型やnone型は未実装またはnullを返す\r\n *\r\n * 設計ポイント:\r\n * - ワイルドカードや多重ループ、ネストした配列バインディングに柔軟に対応\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n * - エラー時はraiseErrorで詳細な例外を投げる\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IResolvedPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IStateHandler, IReadonlyStateProxy, IStateProxy } from \"../types\";\r\nimport { getContextListIndex } from \"./getContextListIndex\";\r\n\r\nexport function getListIndex(\r\n  info: IResolvedPathInfo, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): IListIndex | null {\r\n  switch (info.wildcardType) {\r\n    case \"none\":\r\n      return null;\r\n    case \"context\":\r\n      const lastWildcardPath = info.info.lastWildcardPath ?? \r\n        raiseError(`lastWildcardPath is null`);\r\n      return getContextListIndex(handler, lastWildcardPath) ?? \r\n        raiseError(`ListIndex not found: ${info.info.pattern}`);\r\n    case \"all\":\r\n      let parentListIndex = null;\r\n      for(let i = 0; i < info.info.wildcardCount; i++) {\r\n        const wildcardParentPattern = info.info.wildcardParentInfos[i] ?? raiseError(`wildcardParentPattern is null`);\r\n        const listIndexes: IListIndex[] = Array.from(handler.engine.getListIndexesSet(wildcardParentPattern, parentListIndex) ?? []);\r\n        const wildcardIndex = info.wildcardIndexes[i] ?? raiseError(`wildcardIndex is null`);\r\n        parentListIndex = listIndexes[wildcardIndex] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n      }\r\n      return parentListIndex;\r\n    case \"partial\":\r\n      raiseError(`Partial wildcard type is not supported yet: ${info.info.pattern}`);\r\n  }\r\n}\r\n","/**\r\n * setStatePropertyRef.ts\r\n *\r\n * StateClassの内部APIとして、状態プロパティ参照（IStructuredPathInfo, IListIndex）のスコープを\r\n * 一時的に設定し、指定したコールバックをそのスコープ内で実行するための関数です。\r\n *\r\n * 主な役割:\r\n * - handler.structuredPathInfoStackとhandler.listIndexStackにinfoとlistIndexをpushしてスコープを設定\r\n * - 指定したcallbackをそのスコープ内で実行\r\n * - finallyで必ずスタックからpopし、スコープ外への影響を防止\r\n *\r\n * 設計ポイント:\r\n * - コールバック実行中のみスコープを切り替え、例外発生時も状態復元を保証\r\n * - ネストしたスコープにも対応可能\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\nexport function setStatePropertyRef(\r\n  handler: IStateHandler,\r\n  info: IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n  callback: () => void\r\n): void {\r\n  handler.refIndex++;\r\n  if (handler.refIndex >= handler.structuredPathInfoStack.length) {\r\n    handler.structuredPathInfoStack.push(null);\r\n    handler.listIndexStack.push(null);\r\n  }\r\n  handler.structuredPathInfoStack[handler.refIndex] = info;\r\n  handler.listIndexStack[handler.refIndex] = listIndex;\r\n  try {\r\n    return callback();\r\n  } finally {\r\n    handler.structuredPathInfoStack[handler.refIndex] = null;\r\n    handler.listIndexStack[handler.refIndex] = null;\r\n    handler.refIndex--;\r\n  }\r\n}\r\n","/**\r\n * setTracking.ts\r\n *\r\n * StateClassの内部APIとして、依存関係トラッキング用のスコープを一時的に設定し、\r\n * 指定したコールバックをそのスコープ内で実行するための関数です。\r\n *\r\n * 主な役割:\r\n * - handler.trackingStackにinfo（依存対象のパス情報）をpushしてトラッキングスコープを設定\r\n * - 指定したcallbackをそのスコープ内で実行\r\n * - finallyで必ずtrackingStackからpopし、スコープ外への影響を防止\r\n * - lastTrackingStackも適切に更新\r\n *\r\n * 設計ポイント:\r\n * - コールバック実行中のみ依存トラッキングを有効化し、例外発生時も状態復元を保証\r\n * - ネストした依存トラッキングにも対応可能\r\n */\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\nexport function setTracking(info: IStructuredPathInfo, handler: IStateHandler, callback: () => any): any {\r\n  // 依存関係の自動登録\r\n  const lastTrackingStack = handler.trackingStack[handler.trackingIndex] ?? null;\r\n  if (lastTrackingStack != null) {\r\n    // trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n    if (handler.engine.trackedGetters.has(lastTrackingStack.pattern)) {\r\n      handler.engine.addDependentProp(lastTrackingStack, info, \"reference\");\r\n    }\r\n  }\r\n  handler.trackingIndex++;\r\n  if (handler.trackingIndex >= handler.trackingStack.length) {\r\n    handler.trackingStack.push(null);\r\n  }\r\n  handler.trackingStack[handler.trackingIndex] = info;\r\n  handler.lastTrackingStack = handler.trackingStack[handler.trackingIndex] ?? null;\r\n  try {\r\n    return callback();\r\n  } finally {\r\n    handler.trackingStack[handler.trackingIndex] = null;\r\n    handler.trackingIndex--;\r\n    handler.lastTrackingStack = handler.trackingStack[handler.trackingIndex] ?? null;\r\n  }\r\n}\r\n","/**\r\n * getByRef.ts\r\n *\r\n * StateClassの内部APIとして、構造化パス情報（IStructuredPathInfo）とリストインデックス（IListIndex）を指定して\r\n * 状態オブジェクト（target）から値を取得するための関数（getByRef）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定されたパス・インデックスに対応するState値を取得（多重ループやワイルドカードにも対応）\r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyで値をキャッシュ）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * - 存在しない場合は親infoやlistIndexを辿って再帰的に値を取得\r\n *\r\n * 設計ポイント:\r\n * - handler.engine.trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n * - キャッシュ有効時はrefKeyで値をキャッシュし、取得・再利用を最適化\r\n * - ワイルドカードや多重ループにも柔軟に対応し、再帰的な値取得を実現\r\n * - finallyでキャッシュへの格納を保証\r\n */\r\nimport { GetPropertyValueFromChildSymbol, NamesSymbol } from \"../../ComponentState/symbols\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { createRefKey } from \"../../StatePropertyRef/getStatePropertyRef\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IStateHandler, IReadonlyStateProxy, IStateProxy, IReadonlyStateHandler } from \"../types\";\r\nimport { setStatePropertyRef } from \"./setStatePropertyRef\";\r\nimport { setTracking } from \"./setTracking.js\";\r\n\r\n/**\r\n * 構造化パス情報(info, listIndex)をもとに、状態オブジェクト(target)から値を取得する。\r\n * \r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyでキャッシュ）\r\n * - ネスト・ワイルドカード対応（親infoやlistIndexを辿って再帰的に値を取得）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * \r\n * @param target    状態オブジェクト\r\n * @param info      構造化パス情報\r\n * @param listIndex リストインデックス（多重ループ対応）\r\n * @param receiver  プロキシ\r\n * @param handler   状態ハンドラ\r\n * @returns         対象プロパティの値\r\n */\r\nfunction _getByRef(\r\n  target   : Object, \r\n  info     : IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n  receiver : IReadonlyStateProxy,\r\n  handler  : IReadonlyStateHandler\r\n): any {\r\n  // キャッシュが有効な場合はrefKeyで値をキャッシュ\r\n  let refKey = '';\r\n  if (handler.cacheable) {\r\n    refKey = createRefKey(info, listIndex);\r\n    const value = handler.cache[refKey];\r\n    if (typeof value !== \"undefined\") {\r\n      return value;\r\n    }\r\n    if (refKey in handler.cache) {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  let value;\r\n  try {\r\n    if (handler.engine.owner.state[NamesSymbol].has(info.cumulativePaths[0]) && info.cumulativePaths.length > 1) {\r\n      return value = handler.engine.owner.state[GetPropertyValueFromChildSymbol](info.pattern);\r\n    }\r\n    // パターンがtargetに存在する場合はgetter経由で取得\r\n    if (info.pattern in target) {\r\n      return (value = setStatePropertyRef(handler, info, listIndex, () => {\r\n        return Reflect.get(target, info.pattern, receiver);\r\n      }));\r\n    } else {\r\n      // 存在しない場合は親infoを辿って再帰的に取得\r\n      const parentInfo = info.parentInfo ?? raiseError(`propRef.stateProp.parentInfo is undefined`);\r\n      const parentListIndex = parentInfo.wildcardCount < info.wildcardCount ? (listIndex?.parentListIndex ?? null) : listIndex;\r\n      const parentValue = getByRefReadonly(target, parentInfo, parentListIndex, receiver, handler);\r\n      const lastSegment = info.lastSegment;\r\n      if (lastSegment === \"*\") {\r\n        // ワイルドカードの場合はlistIndexのindexでアクセス\r\n        const index = listIndex?.index ?? raiseError(`propRef.listIndex?.index is undefined`);\r\n        return (value = Reflect.get(parentValue, index));\r\n      } else {\r\n        // 通常のプロパティアクセス\r\n        return (value = Reflect.get(parentValue, lastSegment));\r\n      }\r\n    }\r\n  } finally {\r\n    // キャッシュが有効な場合は取得値をキャッシュ\r\n    if (handler.cacheable && !(refKey in handler.cache)) {\r\n      handler.cache[refKey] = value;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * trackedGettersに含まれる場合は依存追跡(setTracking)を有効化し、値取得を行う。\r\n * それ以外は通常の_getByRefで取得。\r\n */\r\nexport function getByRefReadonly(\r\n  target   : Object, \r\n  info     : IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n  receiver : IReadonlyStateProxy,\r\n  handler  : IReadonlyStateHandler\r\n): any {\r\n  return setTracking(info, handler, () => {\r\n    return _getByRef(target, info, listIndex, receiver, handler);\r\n  });\r\n}\r\n","/**\r\n * resolve.ts\r\n *\r\n * StateClassのAPIとして、パス（path）とインデックス（indexes）を指定して\r\n * Stateの値を取得・設定するための関数（resolve）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列パス（path）とインデックス配列（indexes）から、該当するState値の取得・設定を行う\r\n * - ワイルドカードや多重ループを含むパスにも対応\r\n * - value未指定時は取得（getByRef）、指定時は設定（setByRef）を実行\r\n *\r\n * 設計ポイント:\r\n * - getStructuredPathInfoでパスを解析し、ワイルドカード階層ごとにリストインデックスを解決\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n * - getByRef/setByRefで値の取得・設定を一元的に処理\r\n * - 柔軟なバインディングやAPI経由での利用が可能\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IReadonlyStateProxy, IReadonlyStateHandler } from \"../types\";\r\nimport { getByRefReadonly } from \"../methods/getByRefReadonly\";\r\n\r\nexport function resolveReadonly(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IReadonlyStateProxy,\r\n  handler: IReadonlyStateHandler\r\n): Function {\r\n  return (path: string, indexes: number[], value?: any): any => {\r\n    const info = getStructuredPathInfo(path);\r\n    if (handler.lastTrackingStack != null) {\r\n      // trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n      if (handler.engine.trackedGetters.has(handler.lastTrackingStack.pattern)) {\r\n        handler.engine.addDependentProp(handler.lastTrackingStack, info, \"reference\");\r\n      }\r\n    }\r\n\r\n    let listIndex: IListIndex | null = null;\r\n    for(let i = 0; i < info.wildcardParentInfos.length; i++) {\r\n      const wildcardParentPattern = info.wildcardParentInfos[i] ?? raiseError(`wildcardParentPath is null`);\r\n      const listIndexes: IListIndex[] = Array.from(handler.engine.getListIndexesSet(wildcardParentPattern, listIndex) ?? []);\r\n      const index = indexes[i] ?? raiseError(`index is null`);\r\n      listIndex = listIndexes[index] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n    }\r\n    if (typeof value === \"undefined\") {\r\n      return getByRefReadonly(target, info, listIndex, receiver, handler);\r\n    } else {\r\n      raiseError(`Cannot set value on a readonly proxy: ${path}`);\r\n    }\r\n  };\r\n} ","import { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\nexport function trackDependency(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n):Function {\r\n  return (path: string): void => {\r\n    const info = getStructuredPathInfo(path);\r\n    if (handler.lastTrackingStack != null) {\r\n      // trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n      if (handler.engine.trackedGetters.has(handler.lastTrackingStack.pattern)) {\r\n        handler.engine.addDependentProp(handler.lastTrackingStack, info, \"reference\");\r\n      }\r\n    }\r\n  };\r\n}\r\n","/**\r\n * get.ts\r\n *\r\n * StateClassのProxyトラップとして、プロパティアクセス時の値取得処理を担う関数（get）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列プロパティの場合、特殊プロパティ（$1〜$9, $resolve, $getAll, $navigate）に応じた値やAPIを返却\r\n * - 通常のプロパティはgetResolvedPathInfoでパス情報を解決し、getListIndexでリストインデックスを取得\r\n * - getByRefで構造化パス・リストインデックスに対応した値を取得\r\n * - シンボルプロパティの場合はhandler.callableApi経由でAPIを呼び出し\r\n * - それ以外はReflect.getで通常のプロパティアクセスを実行\r\n *\r\n * 設計ポイント:\r\n * - $1〜$9は直近のStatePropertyRefのリストインデックス値を返す特殊プロパティ\r\n * - $resolve, $getAll, $navigateはAPI関数やルーターインスタンスを返す\r\n * - 通常のプロパティアクセスもバインディングや多重ループに対応\r\n * - シンボルAPIやReflect.getで拡張性・互換性も確保\r\n */\r\nimport { getRouter } from \"../../Router/Router.js\";\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { IReadonlyStateHandler, IReadonlyStateProxy } from \"../types.js\";\r\nimport { resolveReadonly } from \"../apis/resolveReadonly.js\";\r\nimport { GetByRefSymbol, SetCacheableSymbol } from \"../symbols.js\";\r\nimport { getByRefReadonly } from \"../methods/getByRefReadonly.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types.js\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { setCacheable } from \"../methods/setCacheable.js\";\r\nimport { getAllReadonly } from \"../apis/getAllReadonly.js\";\r\nimport { trackDependency } from \"../apis/trackDependency.js\";\r\n\r\nexport function getReadonly(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  receiver: IReadonlyStateProxy,\r\n  handler : IReadonlyStateHandler\r\n): any {\r\n  if (typeof prop === \"string\") {\r\n    if (prop.charCodeAt(0) === 36) {\r\n      if (prop.length === 2) {\r\n        const d = prop.charCodeAt(1) - 48;\r\n        if (d >= 1 && d <= 9) {\r\n          const listIndex = handler.listIndexStack[handler.refIndex];\r\n          return listIndex?.at(d - 1)?.index ?? raiseError(`ListIndex not found: ${prop}`);\r\n        }\r\n      }\r\n      switch (prop) {\r\n        case \"$resolve\":\r\n          return resolveReadonly(target, prop, receiver, handler);\r\n        case \"$getAll\":\r\n          return getAllReadonly(target, prop, receiver, handler);\r\n        case \"$trackDependency\":\r\n          return trackDependency(target, prop, receiver, handler);\r\n        case \"$navigate\":\r\n          return (to:string) => getRouter()?.navigate(to);\r\n      }\r\n    }\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    return getByRefReadonly(\r\n      target, \r\n      resolvedInfo.info, \r\n      listIndex, \r\n      receiver,\r\n      handler\r\n    );\r\n\r\n  } else if (typeof prop === \"symbol\") {\r\n    switch (prop) {\r\n      case GetByRefSymbol: \r\n        return (info: IStructuredPathInfo, listIndex: IListIndex | null) => \r\n          getByRefReadonly(target, info, listIndex, receiver, handler);\r\n      case SetCacheableSymbol:\r\n        return (callback: () => void) => setCacheable(handler, callback)\r\n      default:\r\n        return Reflect.get(\r\n          target, \r\n          prop, \r\n          receiver\r\n        );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * getAll.ts\r\n *\r\n * StateClassのAPIとして、ワイルドカードを含むStateプロパティパスに対応した\r\n * 全要素取得関数（getAll）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定パス（path）に一致する全てのState要素を配列で取得\r\n * - 多重ループやワイルドカード（*）を含むパスにも対応\r\n * - indexes未指定時は現在のループコンテキストから自動でインデックスを解決\r\n *\r\n * 設計ポイント:\r\n * - getStructuredPathInfoでパス情報を解析し、依存関係も自動で登録\r\n * - walkWildcardPatternでワイルドカード階層を再帰的に探索し、全インデックス組み合わせを列挙\r\n * - resolveで各インデックス組み合わせに対応する値を取得し、配列で返却\r\n * - getContextListIndexで現在のループインデックスを取得\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IReadonlyStateProxy, IReadonlyStateHandler } from \"../types\";\r\nimport { resolveReadonly } from \"./resolveReadonly.js\";\r\nimport { getContextListIndex } from \"../methods/getContextListIndex\";\r\n\r\nexport function getAllReadonly(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IReadonlyStateProxy,\r\n  handler: IReadonlyStateHandler\r\n):Function {\r\n    const resolve = resolveReadonly(target, prop, receiver, handler);\r\n    return (path: string, indexes?: number[]): any[] => {\r\n      const info = getStructuredPathInfo(path);\r\n      if (handler.lastTrackingStack != null) {\r\n        // trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n        if (handler.engine.trackedGetters.has(handler.lastTrackingStack.pattern)) {\r\n          handler.engine.addDependentProp(handler.lastTrackingStack, info, \"reference\");\r\n        }\r\n      }\r\n  \r\n      if (typeof indexes === \"undefined\") {\r\n        for(let i = 0; i < info.wildcardInfos.length; i++) {\r\n          const wildcardPattern = info.wildcardInfos[i] ?? raiseError(`wildcardPattern is null`);\r\n          const listIndex = getContextListIndex(handler, wildcardPattern.pattern);\r\n          if (listIndex) {\r\n            indexes = listIndex.indexes;\r\n            break;\r\n          }\r\n        }\r\n        if (typeof indexes === \"undefined\") {\r\n          indexes = [];\r\n        }\r\n      }\r\n      const walkWildcardPattern = (\r\n        wildcardParentInfos: IStructuredPathInfo[],\r\n        wildardIndexPos: number,\r\n        listIndex: IListIndex | null,\r\n        indexes: number[],\r\n        indexPos: number,\r\n        parentIndexes: number[],\r\n        results: number[][]\r\n      ) => {\r\n        const wildcardParentPattern = wildcardParentInfos[wildardIndexPos] ?? null;\r\n        if (wildcardParentPattern === null) {\r\n          results.push(parentIndexes);\r\n          return;\r\n        }\r\n        const listIndexSet = handler.engine.getListIndexesSet(wildcardParentPattern, listIndex) ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n        const listIndexes = Array.from(listIndexSet);\r\n        const index = indexes[indexPos] ?? null;\r\n        if (index === null) {\r\n          for(let i = 0; i < listIndexes.length; i++) {\r\n            const listIndex = listIndexes[i];\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results);\r\n          }\r\n        } else {\r\n          const listIndex = listIndexes[index] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n          if ((wildardIndexPos + 1) < wildcardParentInfos.length) {\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results\r\n            );\r\n          }\r\n        }\r\n      }\r\n      const resultIndexes: number[][] = [];\r\n      walkWildcardPattern(\r\n        info.wildcardParentInfos, \r\n        0, \r\n        null, \r\n        indexes, \r\n        0, \r\n        [], \r\n        resultIndexes\r\n      );\r\n      const resultValues: any[] = [];\r\n      for(let i = 0; i < resultIndexes.length; i++) {\r\n        resultValues.push(resolve(\r\n          info.pattern,\r\n          resultIndexes[i]\r\n        ));\r\n      }\r\n      return resultValues;\r\n    }\r\n  }","/**\r\n * setCacheable.ts\r\n *\r\n * StateClassの内部APIとして、キャッシュ可能なスコープを一時的に有効化し、\r\n * 指定したコールバック処理をキャッシュ付きで実行するための関数です。\r\n *\r\n * 主な役割:\r\n * - handler.cacheableをtrueに設定し、キャッシュ用オブジェクトを初期化\r\n * - 指定したcallbackをキャッシュ有効状態で実行\r\n * - finallyで必ずcacheableをfalseに戻し、スコープ外ではキャッシュを無効化\r\n *\r\n * 設計ポイント:\r\n * - コールバック実行中のみキャッシュを有効化し、スコープ外への影響を防止\r\n * - finallyで状態復元を保証し、例外発生時も安全\r\n */\r\nimport { IReadonlyStateHandler } from \"../types\";\r\n\r\nexport function setCacheable(handler: IReadonlyStateHandler, callback: () => void): void {\r\n  handler.cacheable = true;\r\n  handler.cache = {}\r\n  try {\r\n    callback();\r\n  } finally {\r\n    handler.cacheable = false;\r\n  }\r\n}\r\n","/**\r\n * createReadonlyStateProxy.ts\r\n *\r\n * StateClassの「読み取り専用」プロキシを生成するための実装ファイルです。\r\n *\r\n * 主な役割:\r\n * - Stateオブジェクトに対して、読み取り専用のProxyを作成\r\n * - StateHandlerクラスで各種APIやトラップ（get/set）を実装\r\n * - getトラップでバインディングやAPI呼び出し、依存解決などに対応\r\n * - setトラップではエラーを投げて書き込みを禁止\r\n *\r\n * 設計ポイント:\r\n * - StateHandlerはIReadonlyStateHandlerを実装し、状態管理やAPI呼び出しの基盤となる\r\n * - callableApiに各種APIシンボルと関数をマッピングし、柔軟なAPI拡張が可能\r\n * - createReadonlyStateProxyで一貫した生成・利用が可能\r\n * - 依存解決やキャッシュ、ループ・プロパティ参照スコープ管理など多機能な設計\r\n */\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IReadonlyStateHandler, IState, IReadonlyStateProxy } from \"./types\";\r\nimport { getReadonly as trapGet } from \"./traps/getReadonly.js\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\n\r\nconst STACK_DEPTH = 32;\r\n\r\nclass StateHandler implements IReadonlyStateHandler {\r\n  engine   : IComponentEngine;\r\n  cacheable: boolean = false;\r\n  cache    : {[key:number]:any} = {};\r\n  lastTrackingStack: IStructuredPathInfo | null = null;\r\n  trackingStack: (IStructuredPathInfo | null)[] = Array(STACK_DEPTH).fill(null);\r\n  trackingIndex: number = -1;\r\n  structuredPathInfoStack: (IStructuredPathInfo | null)[] = Array(STACK_DEPTH).fill(null);\r\n  listIndexStack: (IListIndex | null)[] = Array(STACK_DEPTH).fill(null);\r\n  refIndex: number = -1;\r\n  loopContext: ILoopContext | null = null;\r\n  \r\n  constructor(engine: IComponentEngine) {\r\n    this.engine = engine;\r\n  }\r\n\r\n  get(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    receiver: IReadonlyStateProxy\r\n  ): any {\r\n    return trapGet(target, prop, receiver, this);\r\n  }\r\n\r\n  set(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    value   : any, \r\n    receiver: IReadonlyStateProxy\r\n  ): boolean {\r\n    raiseError(`Cannot set property ${String(prop)} of readonly state.`);\r\n  }\r\n}\r\n\r\nexport function createReadonlyStateProxy(\r\n  engine: IComponentEngine, \r\n  state: Object\r\n): IReadonlyStateProxy {\r\n  return new Proxy<IState>(state, new StateHandler(engine)) as IReadonlyStateProxy;\r\n}\r\n\r\n","/**\r\n * getByRef.ts\r\n *\r\n * StateClassの内部APIとして、構造化パス情報（IStructuredPathInfo）とリストインデックス（IListIndex）を指定して\r\n * 状態オブジェクト（target）から値を取得するための関数（getByRef）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定されたパス・インデックスに対応するState値を取得（多重ループやワイルドカードにも対応）\r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyで値をキャッシュ）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * - 存在しない場合は親infoやlistIndexを辿って再帰的に値を取得\r\n *\r\n * 設計ポイント:\r\n * - handler.engine.trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n * - キャッシュ有効時はrefKeyで値をキャッシュし、取得・再利用を最適化\r\n * - ワイルドカードや多重ループにも柔軟に対応し、再帰的な値取得を実現\r\n * - finallyでキャッシュへの格納を保証\r\n */\r\nimport { GetPropertyValueFromChildSymbol, NamesSymbol } from \"../../ComponentState/symbols\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { createRefKey } from \"../../StatePropertyRef/getStatePropertyRef\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IStateHandler, IReadonlyStateProxy, IStateProxy, IWritableStateHandler, IWritableStateProxy } from \"../types\";\r\nimport { setStatePropertyRef } from \"./setStatePropertyRef\";\r\nimport { setTracking } from \"./setTracking.js\";\r\n\r\n/**\r\n * 構造化パス情報(info, listIndex)をもとに、状態オブジェクト(target)から値を取得する。\r\n * \r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyでキャッシュ）\r\n * - ネスト・ワイルドカード対応（親infoやlistIndexを辿って再帰的に値を取得）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * \r\n * @param target    状態オブジェクト\r\n * @param info      構造化パス情報\r\n * @param listIndex リストインデックス（多重ループ対応）\r\n * @param receiver  プロキシ\r\n * @param handler   状態ハンドラ\r\n * @returns         対象プロパティの値\r\n */\r\nfunction _getByRef(\r\n  target   : Object, \r\n  info     : IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n  receiver : IWritableStateProxy,\r\n  handler  : IWritableStateHandler\r\n): any {\r\n  if (handler.engine.owner.state[NamesSymbol].has(info.cumulativePaths[0]) && info.cumulativePaths.length > 1) {\r\n    return handler.engine.owner.state[GetPropertyValueFromChildSymbol](info.pattern);\r\n  }\r\n\r\n  // パターンがtargetに存在する場合はgetter経由で取得\r\n  if (info.pattern in target) {\r\n    return setStatePropertyRef(handler, info, listIndex, () => {\r\n      return Reflect.get(target, info.pattern, receiver);\r\n    });\r\n  } else {\r\n    // 存在しない場合は親infoを辿って再帰的に取得\r\n    const parentInfo = info.parentInfo ?? raiseError(`propRef.stateProp.parentInfo is undefined`);\r\n    const parentListIndex = parentInfo.wildcardCount < info.wildcardCount ? (listIndex?.parentListIndex ?? null) : listIndex;\r\n    const parentValue = getByRefWritable(target, parentInfo, parentListIndex, receiver, handler);\r\n    const lastSegment = info.lastSegment;\r\n    if (lastSegment === \"*\") {\r\n      // ワイルドカードの場合はlistIndexのindexでアクセス\r\n      const index = listIndex?.index ?? raiseError(`propRef.listIndex?.index is undefined`);\r\n      return Reflect.get(parentValue, index);\r\n    } else {\r\n      // 通常のプロパティアクセス\r\n      return Reflect.get(parentValue, lastSegment);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * trackedGettersに含まれる場合は依存追跡(setTracking)を有効化し、値取得を行う。\r\n * それ以外は通常の_getByRefで取得。\r\n */\r\nexport function getByRefWritable(\r\n  target   : Object, \r\n  info     : IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n  receiver : IWritableStateProxy,\r\n  handler  : IWritableStateHandler\r\n): any {\r\n  return setTracking(info, handler, () => {\r\n    return _getByRef(target, info, listIndex, receiver, handler);\r\n  });\r\n}\r\n","/**\r\n * setByRef.ts\r\n *\r\n * StateClassの内部APIとして、構造化パス情報（IStructuredPathInfo）とリストインデックス（IListIndex）を指定して\r\n * 状態オブジェクト（target）に値を設定するための関数（setByRef）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定されたパス・インデックスに対応するState値を設定（多重ループやワイルドカードにも対応）\r\n * - getter/setter経由で値設定時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * - 存在しない場合は親infoやlistIndexを辿って再帰的に値を設定\r\n * - 設定後はengine.updater.addUpdatedStatePropertyRefValueで更新情報を登録\r\n *\r\n * 設計ポイント:\r\n * - ワイルドカードや多重ループにも柔軟に対応し、再帰的な値設定を実現\r\n * - finallyで必ず更新情報を登録し、再描画や依存解決に利用\r\n * - getter/setter経由のスコープ切り替えも考慮した設計\r\n */\r\nimport { NamesSymbol, SetPropertyValueFromChildSymbol } from \"../../ComponentState/symbols\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\nimport { getByRefWritable } from \"./getByRefWritable\";\r\nimport { setStatePropertyRef } from \"./setStatePropertyRef\";\r\n\r\nexport function setByRef(\r\n    target   : Object, \r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex | null, \r\n    value    : any, \r\n    receiver : IWritableStateProxy,\r\n    handler  : IWritableStateHandler\r\n): any {\r\n  try {\r\n    if (handler.engine.owner.state[NamesSymbol].has(info.cumulativePaths[0]) && info.cumulativePaths.length > 1) {\r\n      return handler.engine.owner.state[SetPropertyValueFromChildSymbol](info.pattern, value);\r\n    }\r\n    if (info.pattern in target) {\r\n      return setStatePropertyRef(handler, info, listIndex, () => {\r\n        return Reflect.set(target, info.pattern, value, receiver);\r\n      });\r\n    } else {\r\n      const parentInfo = info.parentInfo ?? raiseError(`propRef.stateProp.parentInfo is undefined`);\r\n      const parentListIndex = parentInfo.wildcardCount < info.wildcardCount ? (listIndex?.parentListIndex ?? null) : listIndex;\r\n      const parentValue = getByRefWritable(target, parentInfo, parentListIndex, receiver, handler);\r\n      const lastSegment = info.lastSegment;\r\n      if (lastSegment === \"*\") {\r\n        const index = listIndex?.index ?? raiseError(`propRef.listIndex?.index is undefined`);\r\n        return Reflect.set(parentValue, index, value);\r\n      } else {\r\n        return Reflect.set(parentValue, lastSegment, value);\r\n      }\r\n    }\r\n  } finally {\r\n    handler.engine.updater.addUpdatedStatePropertyRefValue(info, listIndex, value);\r\n  }\r\n}\r\n","/**\r\n * resolve.ts\r\n *\r\n * StateClassのAPIとして、パス（path）とインデックス（indexes）を指定して\r\n * Stateの値を取得・設定するための関数（resolve）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列パス（path）とインデックス配列（indexes）から、該当するState値の取得・設定を行う\r\n * - ワイルドカードや多重ループを含むパスにも対応\r\n * - value未指定時は取得（getByRef）、指定時は設定（setByRef）を実行\r\n *\r\n * 設計ポイント:\r\n * - getStructuredPathInfoでパスを解析し、ワイルドカード階層ごとにリストインデックスを解決\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n * - getByRef/setByRefで値の取得・設定を一元的に処理\r\n * - 柔軟なバインディングやAPI経由での利用が可能\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { getByRefWritable } from \"../methods/getByRefWritable\";\r\n\r\nexport function resolveWritable(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler: IWritableStateHandler\r\n): Function {\r\n  return (path: string, indexes: number[], value?: any): any => {\r\n    const info = getStructuredPathInfo(path);\r\n    if (handler.lastTrackingStack != null) {\r\n      // trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n      if (handler.engine.trackedGetters.has(handler.lastTrackingStack.pattern)) {\r\n        handler.engine.addDependentProp(handler.lastTrackingStack, info, \"reference\");\r\n      }\r\n    }\r\n\r\n    let listIndex: IListIndex | null = null;\r\n    for(let i = 0; i < info.wildcardParentInfos.length; i++) {\r\n      const wildcardParentPattern = info.wildcardParentInfos[i] ?? raiseError(`wildcardParentPath is null`);\r\n      const listIndexes: IListIndex[] = Array.from(handler.engine.getListIndexesSet(wildcardParentPattern, listIndex) ?? []);\r\n      const index = indexes[i] ?? raiseError(`index is null`);\r\n      listIndex = listIndexes[index] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n    }\r\n    if (typeof value === \"undefined\") {\r\n      return getByRefWritable(target, info, listIndex, receiver, handler);\r\n    } else {\r\n      return setByRef(target, info, listIndex, value, receiver, handler);\r\n    }\r\n  };\r\n} ","/**\r\n * get.ts\r\n *\r\n * StateClassのProxyトラップとして、プロパティアクセス時の値取得処理を担う関数（get）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列プロパティの場合、特殊プロパティ（$1〜$9, $resolve, $getAll, $navigate）に応じた値やAPIを返却\r\n * - 通常のプロパティはgetResolvedPathInfoでパス情報を解決し、getListIndexでリストインデックスを取得\r\n * - getByRefで構造化パス・リストインデックスに対応した値を取得\r\n * - シンボルプロパティの場合はhandler.callableApi経由でAPIを呼び出し\r\n * - それ以外はReflect.getで通常のプロパティアクセスを実行\r\n *\r\n * 設計ポイント:\r\n * - $1〜$9は直近のStatePropertyRefのリストインデックス値を返す特殊プロパティ\r\n * - $resolve, $getAll, $navigateはAPI関数やルーターインスタンスを返す\r\n * - 通常のプロパティアクセスもバインディングや多重ループに対応\r\n * - シンボルAPIやReflect.getで拡張性・互換性も確保\r\n */\r\nimport { getRouter } from \"../../Router/Router.js\";\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { IWritableStateHandler, IWritableStateProxy } from \"../types.js\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, SetByRefSymbol } from \"../symbols.js\";\r\nimport { getByRefWritable } from \"../methods/getByRefWritable.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types.js\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { resolveWritable } from \"../apis/resolveWritable.js\";\r\nimport { getAllWritable } from \"../apis/getAllWritable.js\";\r\nimport { connectedCallback } from \"../apis/connectedCallback.js\";\r\nimport { disconnectedCallback } from \"../apis/disconnectedCallback.js\";\r\nimport { trackDependency } from \"../apis/trackDependency.js\";\r\n\r\nexport function getWritable(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler : IWritableStateHandler\r\n): any {\r\n  if (typeof prop === \"string\") {\r\n    if (prop.charCodeAt(0) === 36) {\r\n      if (prop.length === 2) {\r\n        const d = prop.charCodeAt(1) - 48;\r\n        if (d >= 1 && d <= 9) {\r\n          const listIndex = handler.listIndexStack[handler.refIndex];\r\n          return listIndex?.at(d - 1)?.index ?? raiseError(`ListIndex not found: ${prop}`);\r\n        }\r\n      }\r\n      switch (prop) {\r\n        case \"$resolve\":\r\n          return resolveWritable(target, prop, receiver, handler);\r\n        case \"$getAll\":\r\n          return getAllWritable(target, prop, receiver, handler);\r\n        case \"$trackDependency\":\r\n          return trackDependency(target, prop, receiver, handler);\r\n        case \"$navigate\":\r\n          return (to:string) => getRouter()?.navigate(to);\r\n      }\r\n    }\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    return getByRefWritable(\r\n      target, \r\n      resolvedInfo.info, \r\n      listIndex, \r\n      receiver,\r\n      handler\r\n    );\r\n\r\n  } else if (typeof prop === \"symbol\") {\r\n    switch (prop) {\r\n      case GetByRefSymbol: \r\n        return (info: IStructuredPathInfo, listIndex: IListIndex | null) => \r\n          getByRefWritable(target, info, listIndex, receiver, handler);\r\n      case SetByRefSymbol: \r\n        return (info: IStructuredPathInfo, listIndex: IListIndex | null, value: any) => \r\n          setByRef(target, info, listIndex, value, receiver, handler);\r\n      case ConnectedCallbackSymbol:\r\n        return () => connectedCallback(target, prop, receiver, handler);\r\n      case DisconnectedCallbackSymbol: \r\n        return () => disconnectedCallback(target, prop, receiver, handler);\r\n      default:\r\n        return Reflect.get(\r\n          target, \r\n          prop, \r\n          receiver\r\n        );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * getAll.ts\r\n *\r\n * StateClassのAPIとして、ワイルドカードを含むStateプロパティパスに対応した\r\n * 全要素取得関数（getAll）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定パス（path）に一致する全てのState要素を配列で取得\r\n * - 多重ループやワイルドカード（*）を含むパスにも対応\r\n * - indexes未指定時は現在のループコンテキストから自動でインデックスを解決\r\n *\r\n * 設計ポイント:\r\n * - getStructuredPathInfoでパス情報を解析し、依存関係も自動で登録\r\n * - walkWildcardPatternでワイルドカード階層を再帰的に探索し、全インデックス組み合わせを列挙\r\n * - resolveで各インデックス組み合わせに対応する値を取得し、配列で返却\r\n * - getContextListIndexで現在のループインデックスを取得\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IWritableStateHandler, IWritableStateProxy } from \"../types\";\r\nimport { resolveWritable } from \"./resolveWritable.js\";\r\nimport { getContextListIndex } from \"../methods/getContextListIndex\";\r\n\r\nexport function getAllWritable(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler: IWritableStateHandler\r\n):Function {\r\n    const resolve = resolveWritable(target, prop, receiver, handler);\r\n    return (path: string, indexes?: number[]): any[] => {\r\n      const info = getStructuredPathInfo(path);\r\n      if (handler.lastTrackingStack != null) {\r\n        // trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n        if (handler.engine.trackedGetters.has(handler.lastTrackingStack.pattern)) {\r\n          handler.engine.addDependentProp(handler.lastTrackingStack, info, \"reference\");\r\n        }\r\n      }\r\n  \r\n      if (typeof indexes === \"undefined\") {\r\n        for(let i = 0; i < info.wildcardInfos.length; i++) {\r\n          const wildcardPattern = info.wildcardInfos[i] ?? raiseError(`wildcardPattern is null`);\r\n          const listIndex = getContextListIndex(handler, wildcardPattern.pattern);\r\n          if (listIndex) {\r\n            indexes = listIndex.indexes;\r\n            break;\r\n          }\r\n        }\r\n        if (typeof indexes === \"undefined\") {\r\n          indexes = [];\r\n        }\r\n      }\r\n      const walkWildcardPattern = (\r\n        wildcardParentInfos: IStructuredPathInfo[],\r\n        wildardIndexPos: number,\r\n        listIndex: IListIndex | null,\r\n        indexes: number[],\r\n        indexPos: number,\r\n        parentIndexes: number[],\r\n        results: number[][]\r\n      ) => {\r\n        const wildcardParentPattern = wildcardParentInfos[wildardIndexPos] ?? null;\r\n        if (wildcardParentPattern === null) {\r\n          results.push(parentIndexes);\r\n          return;\r\n        }\r\n        const listIndexSet = handler.engine.getListIndexesSet(wildcardParentPattern, listIndex) ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n        const listIndexes = Array.from(listIndexSet);\r\n        const index = indexes[indexPos] ?? null;\r\n        if (index === null) {\r\n          for(let i = 0; i < listIndexes.length; i++) {\r\n            const listIndex = listIndexes[i];\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results);\r\n          }\r\n        } else {\r\n          const listIndex = listIndexes[index] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n          if ((wildardIndexPos + 1) < wildcardParentInfos.length) {\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results\r\n            );\r\n          }\r\n        }\r\n      }\r\n      const resultIndexes: number[][] = [];\r\n      walkWildcardPattern(\r\n        info.wildcardParentInfos, \r\n        0, \r\n        null, \r\n        indexes, \r\n        0, \r\n        [], \r\n        resultIndexes\r\n      );\r\n      const resultValues: any[] = [];\r\n      for(let i = 0; i < resultIndexes.length; i++) {\r\n        resultValues.push(resolve(\r\n          info.pattern,\r\n          resultIndexes[i]\r\n        ));\r\n      }\r\n      return resultValues;\r\n    }\r\n  }","/**\r\n * connectedCallback.ts\r\n *\r\n * StateClassのライフサイクルフック「$connectedCallback」を呼び出すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - オブジェクト（target）に$connectedCallbackメソッドが定義されていれば呼び出す\r\n * - コールバックはtargetのthisコンテキストで呼び出し、IReadonlyStateProxy（receiver）を引数として渡す\r\n * - 非同期関数として実行可能（await対応）\r\n *\r\n * 設計ポイント:\r\n * - Reflect.getで$connectedCallbackプロパティを安全に取得\r\n * - 存在しない場合は何もしない\r\n * - ライフサイクル管理やカスタム初期化処理に利用\r\n */\r\nimport { IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\n\r\nconst CONNECTED_CALLBACK = \"$connectedCallback\";\r\n\r\nexport function connectedCallback(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler: IWritableStateHandler\r\n):Function {\r\n  return async () => {\r\n    const callback = Reflect.get(target, CONNECTED_CALLBACK);\r\n    if (typeof callback === \"function\") {\r\n      await callback.call(target, receiver);\r\n    }\r\n  };\r\n}","/**\r\n * disconnectedCallback.ts\r\n *\r\n * StateClassのライフサイクルフック「$disconnectedCallback」を呼び出すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - オブジェクト（target）に$disconnectedCallbackメソッドが定義されていれば呼び出す\r\n * - コールバックはtargetのthisコンテキストで呼び出し、IReadonlyStateProxy（receiver）を引数として渡す\r\n * - 非同期関数として実行可能（await対応）\r\n *\r\n * 設計ポイント:\r\n * - Reflect.getで$disconnectedCallbackプロパティを安全に取得\r\n * - 存在しない場合は何もしない\r\n * - ライフサイクル管理やクリーンアップ処理に利用\r\n */\r\nimport { IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\n\r\nconst DISCONNECTED_CALLBACK = \"$disconnectedCallback\";\r\n\r\nexport function disconnectedCallback(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler: IWritableStateHandler\r\n):Function {\r\n  return async () => {\r\n    const callback = Reflect.get(target, DISCONNECTED_CALLBACK);\r\n    if (typeof callback === \"function\") {\r\n      await callback.call(target, receiver);\r\n    }\r\n  };\r\n}","/**\r\n * createWritableStateProxy.ts\r\n *\r\n * StateClassの「書き込み可能」プロキシを生成するための実装ファイルです。\r\n *\r\n * 主な役割:\r\n * - Stateオブジェクトに対して、書き込み可能なProxyを作成\r\n * - StateHandlerクラスで各種APIやトラップ（get/set）を実装\r\n * - getトラップでバインディングやAPI呼び出し、依存解決などに対応\r\n * - setトラップで値の書き込みや副作用（依存解決・再描画）を一元管理\r\n *\r\n * 設計ポイント:\r\n * - StateHandlerはIWritableStateHandlerを実装し、状態管理やAPI呼び出しの基盤となる\r\n * - callableApiに各種APIシンボルと関数をマッピングし、柔軟なAPI拡張が可能\r\n * - createWritableStateProxyで一貫した生成・利用が可能\r\n * - 依存解決やキャッシュ、ループ・プロパティ参照スコープ管理など多機能な設計\r\n */\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IState, IWritableStateHandler, IWritableStateProxy } from \"./types\";\r\nimport { getWritable as trapGet } from \"./traps/getWritable.js\";\r\nimport { set as trapSet } from \"./traps/set.js\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { setLoopContext } from \"./methods/setLoopContext\";\r\n\r\nconst STACK_DEPTH = 32;\r\n\r\nclass StateHandler implements IWritableStateHandler {\r\n  engine   : IComponentEngine;\r\n  lastTrackingStack: IStructuredPathInfo | null = null;\r\n  trackingStack: (IStructuredPathInfo | null)[] = Array(STACK_DEPTH).fill(null);\r\n  trackingIndex: number = -1;\r\n  structuredPathInfoStack: (IStructuredPathInfo | null)[] = Array(STACK_DEPTH).fill(null);\r\n  listIndexStack: (IListIndex | null)[] = Array(STACK_DEPTH).fill(null);\r\n  refIndex: number = -1;\r\n  loopContext: ILoopContext | null = null;\r\n  \r\n  constructor(engine: IComponentEngine) {\r\n    this.engine = engine;\r\n  }\r\n\r\n  get(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    receiver: IWritableStateProxy\r\n  ): any {\r\n    return trapGet(target, prop, receiver, this);\r\n  }\r\n\r\n  set(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    value   : any, \r\n    receiver: IWritableStateProxy\r\n  ): boolean {\r\n    return trapSet(target, prop, value, receiver, this);\r\n  }\r\n}\r\n\r\nexport async function useWritableStateProxy(\r\n  engine: IComponentEngine, \r\n  state: Object,\r\n  loopContext: ILoopContext | null = null,\r\n  callback: (stateProxy: IWritableStateProxy) => Promise<void>\r\n): Promise<void> {\r\n  const handler = new StateHandler(engine);\r\n  const stateProxy = new Proxy<IState>(state, handler) as IWritableStateProxy;\r\n  return setLoopContext(handler, loopContext, async () => {\r\n    await callback(stateProxy);\r\n  });\r\n}\r\n\r\n","/**\r\n * set.ts\r\n *\r\n * StateClassのProxyトラップとして、プロパティ設定時の値セット処理を担う関数（set）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列プロパティの場合、getResolvedPathInfoでパス情報を解決し、getListIndexでリストインデックスを取得\r\n * - setByRefで構造化パス・リストインデックスに対応した値設定を実行\r\n * - それ以外（シンボル等）の場合はReflect.setで通常のプロパティ設定を実行\r\n *\r\n * 設計ポイント:\r\n * - バインディングや多重ループ、ワイルドカードを含むパスにも柔軟に対応\r\n * - setByRefを利用することで、依存解決や再描画などの副作用も一元管理\r\n * - Reflect.setで標準的なプロパティ設定の互換性も確保\r\n */\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { IStateHandler, IReadonlyStateProxy, IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\n\r\nexport function set(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  value   : any, \r\n  receiver: IWritableStateProxy,\r\n  handler : IWritableStateHandler\r\n): boolean {\r\n  if (typeof prop === \"string\") {\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    return setByRef(\r\n      target, \r\n      resolvedInfo.info, \r\n      listIndex, \r\n      value, \r\n      receiver,\r\n      handler\r\n    );\r\n  } else {\r\n    return Reflect.set(\r\n      target, \r\n      prop, \r\n      value, \r\n      receiver\r\n    );\r\n  }\r\n}\r\n","/**\r\n * setLoopContext.ts\r\n *\r\n * StateClassの内部APIとして、ループコンテキスト（ILoopContext）を一時的に設定し、\r\n * 指定した非同期コールバックをそのスコープ内で実行するための関数です。\r\n *\r\n * 主な役割:\r\n * - handler.loopContextにループコンテキストを一時的に設定\r\n * - 既にループコンテキストが設定されている場合はエラーを投げる\r\n * - loopContextが存在する場合はasyncSetStatePropertyRefでスコープを設定しコールバックを実行\r\n * - loopContextがnullの場合はそのままコールバックを実行\r\n * - finallyで必ずloopContextをnullに戻し、スコープ外への影響を防止\r\n *\r\n * 設計ポイント:\r\n * - ループバインディングや多重ループ時のスコープ管理を安全に行う\r\n * - finallyで状態復元を保証し、例外発生時も安全\r\n * - 非同期処理にも対応\r\n */\r\nimport { ILoopContext } from \"../../LoopContext/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IWritableStateHandler } from \"../types\";\r\nimport { asyncSetStatePropertyRef } from \"./asyncSetStatePropertyRef\";\r\n\r\nexport async function setLoopContext(\r\n  handler: IWritableStateHandler,\r\n  loopContext: ILoopContext | null,\r\n  callback: () => Promise<void>\r\n): Promise<void> {\r\n  if (handler.loopContext) {\r\n    raiseError('already in loop context');\r\n  }\r\n  handler.loopContext = loopContext;\r\n  try {\r\n    if (loopContext) {\r\n      await asyncSetStatePropertyRef(handler, loopContext.info, loopContext.listIndex, callback);\r\n    } else {\r\n      await callback();\r\n    }\r\n  } finally {\r\n    handler.loopContext = null;\r\n  }\r\n}\r\n","/**\r\n * asyncSetStatePropertyRef.ts\r\n *\r\n * 状態プロパティ参照のスコープを一時的に設定し、非同期コールバックを実行するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - handlerのstructuredPathInfoStackとlistIndexStackに、infoとlistIndexをpushしてスコープを設定\r\n * - 指定した非同期コールバック（callback）をそのスコープ内で実行\r\n * - callback実行後は必ずpopしてスコープを元に戻す（finallyで保証）\r\n *\r\n * 設計ポイント:\r\n * - 非同期処理中も正しいスコープ情報（パス・リストインデックス）が維持される\r\n * - ネストした非同期処理にも対応可能\r\n * - スコープのpush/popは例外発生時も確実に実行される\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\n/**\r\n * 状態プロパティ参照のスコープを一時的に設定し、非同期コールバックを実行します。\r\n * \r\n * @param handler   スコープ管理用のハンドラ\r\n * @param info      現在の構造化パス情報\r\n * @param listIndex 現在のリストインデックス（ネスト対応用）\r\n * @param callback  スコープ内で実行する非同期処理\r\n * \r\n * スタックに info と listIndex をpushし、callback実行後に必ずpopします。\r\n * これにより、非同期処理中も正しいスコープ情報が維持されます。\r\n */\r\nexport async function asyncSetStatePropertyRef(\r\n  handler: IStateHandler,\r\n  info: IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n  callback: () => Promise<void>\r\n): Promise<void> {\r\n  handler.refIndex++;\r\n  if (handler.refIndex >= handler.structuredPathInfoStack.length) {\r\n    handler.structuredPathInfoStack.push(null);\r\n    handler.listIndexStack.push(null);\r\n  }\r\n  handler.structuredPathInfoStack[handler.refIndex] = info;\r\n  handler.listIndexStack[handler.refIndex] = listIndex;\r\n  try {\r\n    await callback();\r\n  } finally {\r\n    handler.structuredPathInfoStack[handler.refIndex] = null;\r\n    handler.listIndexStack[handler.refIndex] = null;\r\n    handler.refIndex--;\r\n  }\r\n}\r\n","import { createBindContent } from \"../DataBinding/BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../DataBinding/types\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { IState, IReadonlyStateProxy, IStructiveState, IWritableStateProxy } from \"../StateClass/types\";\r\nimport { IUpdater } from \"../Updater/types\";\r\nimport { createUpdater } from \"../Updater/updater.js\";\r\nimport { ComponentType, IComponentConfig, IComponentStatic, StructiveComponent } from \"../WebComponents/types\";\r\nimport { attachShadow } from \"./attachShadow.js\";\r\nimport { ISaveInfoByResolvedPathInfo, IComponentEngine } from \"./types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { buildListIndexTree } from \"../StateClass/buildListIndexTree.js\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, SetByRefSymbol, SetCacheableSymbol } from \"../StateClass/symbols.js\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { BindParentComponentSymbol } from \"../ComponentState/symbols.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { DependencyType, IDependencyEdge } from \"../DependencyWalker/types.js\";\r\nimport { createDependencyEdge } from \"../DependencyWalker/createDependencyEdge.js\";\r\nimport { createReadonlyStateProxy } from \"../StateClass/createReadonlyStateProxy.js\";\r\nimport { useWritableStateProxy } from \"../StateClass/useWritableStateProxy.js\";\r\n\r\n/**\r\n * ComponentEngineクラスは、Structiveコンポーネントの状態管理・依存関係管理・\r\n * バインディング・ライフサイクル・レンダリングなどの中核的な処理を担うエンジンです。\r\n *\r\n * 主な役割:\r\n * - 状態インスタンスやプロキシの生成・管理\r\n * - テンプレート・スタイルシート・フィルター・バインディング情報の管理\r\n * - 依存関係グラフ（dependentTree）の構築と管理\r\n * - バインディング情報やリスト情報の保存・取得\r\n * - ライフサイクル（connectedCallback/disconnectedCallback）処理\r\n * - Shadow DOMやスタイルシートの適用\r\n * - 状態プロパティの取得・設定\r\n * - バインディングの追加・存在判定・リスト管理\r\n *\r\n * 構造・設計上の特徴:\r\n * - 状態や依存関係、バインディング情報を効率的に管理するためのキャッシュやマップを多用\r\n * - テンプレートやリスト構造の多重管理に対応\r\n * - 非同期初期化やUpdaterによるバッチ的な状態更新設計\r\n * - 疎結合な設計で、各種ユーティリティやファクトリ関数と連携\r\n *\r\n * 典型的なWeb Componentsのライフサイクルやリアクティブな状態管理を、Structive独自の構造で実現しています。\r\n */\r\nexport class ComponentEngine implements IComponentEngine {\r\n  type          : ComponentType = 'autonomous';\r\n  config        : IComponentConfig;\r\n  template      : HTMLTemplateElement;\r\n  styleSheet    : CSSStyleSheet;\r\n  stateClass    : IStructiveState;\r\n  state         : IState;\r\n  readonlyState : IReadonlyStateProxy;\r\n  updater       : IUpdater;\r\n  inputFilters  : FilterWithOptions;\r\n  outputFilters : FilterWithOptions;\r\n  #bindContent  :IBindContent | null = null;\r\n  get bindContent(): IBindContent {\r\n    if (this.#bindContent === null) {\r\n      raiseError(\"bindContent is not initialized yet\");\r\n    }\r\n    return this.#bindContent;\r\n  }\r\n  baseClass     : typeof HTMLElement = HTMLElement;\r\n  owner         : StructiveComponent;\r\n  trackedGetters: Set<string>;\r\n\r\n  listInfoSet         : Set<IStructuredPathInfo> = new Set();\r\n  elementInfoSet      : Set<IStructuredPathInfo> = new Set();\r\n  bindingsByListIndex : WeakMap<IListIndex, Set<IBinding>> = new WeakMap();\r\n  dependentTree       : Map<IStructuredPathInfo, Set<IDependencyEdge>> = new Map();\r\n\r\n  bindingsByComponent: WeakMap<StructiveComponent, Set<IBinding>> = new WeakMap();\r\n  structiveComponents: Set<StructiveComponent> = new Set();\r\n\r\n  #waitForInitialize : PromiseWithResolvers<void> = Promise.withResolvers<void>();\r\n\r\n  constructor(config: IComponentConfig, owner: StructiveComponent) {\r\n    this.config = config;\r\n    if (this.config.extends) {\r\n      this.type = 'builtin';\r\n    }\r\n    const componentClass = owner.constructor as IComponentStatic;\r\n    this.template = componentClass.template;\r\n    this.styleSheet = componentClass.styleSheet;\r\n    this.stateClass = componentClass.stateClass;\r\n    this.state = new this.stateClass();\r\n    this.readonlyState = createReadonlyStateProxy(this, this.state);\r\n    this.updater = createUpdater(this);\r\n    this.inputFilters = componentClass.inputFilters;\r\n    this.outputFilters = componentClass.outputFilters;\r\n    this.owner = owner;\r\n    this.trackedGetters = componentClass.trackedGetters;\r\n    // 依存関係の木を作成する\r\n    const checkDependentProp = (info: IStructuredPathInfo) => {\r\n      const parentInfo = info.parentInfo;\r\n      if (parentInfo === null) return;\r\n      this.addDependentProp(info, parentInfo, \"structured\");\r\n      checkDependentProp(parentInfo);\r\n    }\r\n    for(const path of componentClass.paths) {\r\n      const info = getStructuredPathInfo(path);\r\n      checkDependentProp(info);\r\n    }\r\n    // 配列のプロパティ、配列要素のプロパティを登録する\r\n    for(const listPath of componentClass.listPaths) {\r\n      this.listInfoSet.add(getStructuredPathInfo(listPath));\r\n      this.elementInfoSet.add(getStructuredPathInfo(listPath + \".*\"));\r\n    }\r\n  }\r\n\r\n  setup(): void {\r\n    const componentClass = this.owner.constructor as IComponentStatic;\r\n    for(const info of this.listInfoSet) {\r\n      if (info.wildcardCount > 0) continue;\r\n      const value = this.readonlyState[GetByRefSymbol](info, null)\r\n      buildListIndexTree(this, info, null, value);\r\n    }\r\n    this.#bindContent = createBindContent(null, componentClass.id, this, null, null); // this.stateArrayPropertyNamePatternsが変更になる可能性がある\r\n  }\r\n\r\n  get waitForInitialize(): PromiseWithResolvers<void> {\r\n    return this.#waitForInitialize;\r\n  }\r\n\r\n  async connectedCallback(): Promise<void> {\r\n    await this.owner.parentStructiveComponent?.waitForInitialize.promise;\r\n    // コンポーネントの状態を初期化する\r\n    if (this.owner.dataset.state) {\r\n      // data-state属性から状態を取得する\r\n      try {\r\n        const json = JSON.parse(this.owner.dataset.state);\r\n        await this.useWritableStateProxy(null, async (stateProxy) => {\r\n          // JSONから状態を設定する\r\n          for(const [key, value] of Object.entries(json)) {\r\n            const info = getStructuredPathInfo(key);\r\n            if (info.wildcardCount > 0) continue;\r\n            stateProxy[SetByRefSymbol](info, null, value);\r\n          }\r\n        });\r\n      } catch(e) {\r\n        raiseError(\"Failed to parse state from dataset\");\r\n      }\r\n    }\r\n    // 親コンポーネントに登録する\r\n    this.owner.parentStructiveComponent?.registerChildComponent(this.owner);\r\n    // コンポーネントの状態を親コンポーネントにバインドする\r\n    this.owner.state[BindParentComponentSymbol]();\r\n    // \r\n    attachShadow(this.owner, this.config, this.styleSheet);\r\n\r\n    this.bindContent.render();\r\n    await this.useWritableStateProxy(null, async (stateProxy) => {\r\n      await stateProxy[ConnectedCallbackSymbol]();\r\n    });\r\n    // レンダリングが終わってから実行する\r\n    queueMicrotask(() => {\r\n      this.bindContent.mount(this.owner.shadowRoot ?? this.owner);\r\n      this.#waitForInitialize.resolve();\r\n    });\r\n  }\r\n\r\n  async disconnectedCallback(): Promise<void> {\r\n    await this.useWritableStateProxy(null, async (stateProxy) => {\r\n      await stateProxy[DisconnectedCallbackSymbol]();\r\n    });\r\n    // 親コンポーネントから登録を解除する\r\n    this.owner.parentStructiveComponent?.unregisterChildComponent(this.owner);\r\n  }\r\n\r\n  #saveInfoByListIndexByResolvedPathInfoId: { [id:number]: WeakMap<IListIndex,ISaveInfoByResolvedPathInfo> } = {};\r\n  #saveInfoByStructuredPathId: { [id:number]: ISaveInfoByResolvedPathInfo } = {};\r\n\r\n  createSaveInfo():ISaveInfoByResolvedPathInfo {\r\n    return {\r\n      list          : null,\r\n      listIndexesSet: null,\r\n      bindings      : [],\r\n    }\r\n  }\r\n\r\n  getSaveInfoByStatePropertyRef(info:IStructuredPathInfo, listIndex:IListIndex | null): ISaveInfoByResolvedPathInfo {\r\n    if (listIndex === null) {\r\n      let saveInfo = this.#saveInfoByStructuredPathId[info.id];\r\n      if (typeof saveInfo === \"undefined\") {\r\n        saveInfo = this.createSaveInfo();\r\n        this.#saveInfoByStructuredPathId[info.id] = saveInfo;\r\n      }\r\n      return saveInfo;\r\n    } else {\r\n      let saveInfoByListIndex = this.#saveInfoByListIndexByResolvedPathInfoId[info.id];\r\n      if (typeof saveInfoByListIndex === \"undefined\") {\r\n        saveInfoByListIndex = new WeakMap<IListIndex, ISaveInfoByResolvedPathInfo>();\r\n        this.#saveInfoByListIndexByResolvedPathInfoId[info.id] = saveInfoByListIndex;\r\n      }\r\n      let saveInfo = saveInfoByListIndex.get(listIndex);\r\n      if (typeof saveInfo === \"undefined\") {\r\n        saveInfo = this.createSaveInfo();\r\n        saveInfoByListIndex.set(listIndex, saveInfo);\r\n      }\r\n      return saveInfo;\r\n    }\r\n  }\r\n  \r\n  saveBinding(\r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex | null, \r\n    binding  : IBinding\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.bindings.push(binding);\r\n  }\r\n\r\n  saveListIndexesSet(\r\n    info              :IStructuredPathInfo, \r\n    listIndex         :IListIndex | null, \r\n    saveListIndexesSet:Set<IListIndex>\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.listIndexesSet = saveListIndexesSet;\r\n  }\r\n\r\n  saveList(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null, \r\n    list     :any[]\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.list = list;\r\n  }\r\n\r\n  getBindings(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null\r\n  ): IBinding[] {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return saveInfo.bindings;\r\n  }\r\n\r\n  existsBindingsByInfo(info: IStructuredPathInfo): boolean {\r\n    if (typeof this.#saveInfoByStructuredPathId[info.id] !== \"undefined\") {\r\n      return true;\r\n    }\r\n    if (typeof this.#saveInfoByListIndexByResolvedPathInfoId[info.id] !== \"undefined\") {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  getListIndexesSet(info:IStructuredPathInfo, listIndex:IListIndex | null): Set<IListIndex> | null {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return saveInfo.listIndexesSet;\r\n  }\r\n    \r\n  getList(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null\r\n  ): any[] | null {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return saveInfo.list;\r\n  }\r\n\r\n  addDependentProp(info: IStructuredPathInfo, refInfo: IStructuredPathInfo, type: DependencyType) {\r\n    let dependents = this.dependentTree.get(refInfo);\r\n    if (typeof dependents === \"undefined\") {\r\n      dependents = new Set<IDependencyEdge>();\r\n      this.dependentTree.set(refInfo, dependents);\r\n    }\r\n    const edge = createDependencyEdge(info, type);\r\n    dependents.add(edge);\r\n  }\r\n\r\n  getPropertyValue(info: IStructuredPathInfo, listIndex:IListIndex | null): any {\r\n    // プロパティの値を取得する\r\n    const readonlyState = createReadonlyStateProxy(this, this.state);\r\n    return readonlyState[GetByRefSymbol](info, listIndex);\r\n  }\r\n  setPropertyValue(info: IStructuredPathInfo, listIndex:IListIndex | null, value: any): void {\r\n    // プロパティの値を設定する\r\n    this.updater.addProcess(() => {\r\n      this.useWritableStateProxy(null, async (stateProxy) => {\r\n        stateProxy[SetByRefSymbol](info, listIndex, value);\r\n      });\r\n    });\r\n  }\r\n  // 読み取り専用の状態プロキシを作成する\r\n  createReadonlyStateProxy(): IReadonlyStateProxy {\r\n    return createReadonlyStateProxy(this, this.state);\r\n  }\r\n  // 書き込み可能な状態プロキシを作成する\r\n  async useWritableStateProxy(\r\n    loopContext: ILoopContext | null,\r\n    callback: (stateProxy: IWritableStateProxy) => Promise<void>\r\n  ): Promise<void> {\r\n    return useWritableStateProxy(this, this.state, loopContext, callback);\r\n  }\r\n  // Structive子コンポーネントを登録する\r\n  registerStrutiveComponent(component: StructiveComponent): void {\r\n    this.structiveComponents.add(component);\r\n  }\r\n  unregisterStrutiveComponent(component: StructiveComponent): void {\r\n    this.structiveComponents.delete(component);\r\n  }\r\n  \r\n}\r\n\r\nexport function createComponentEngine(config: IComponentConfig, component: StructiveComponent): IComponentEngine {\r\n  return new ComponentEngine(config, component);\r\n}","/**\r\n * replaceMustacheWithTemplateTag.ts\r\n *\r\n * Mustache構文（{{if:条件}}, {{for:式}}, {{endif}}, {{endfor}}, {{elseif:条件}}, {{else}} など）を\r\n * <template>タグやコメントノードに変換するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - HTML文字列内のMustache構文を正規表現で検出し、<template data-bind=\"...\">やコメントノードに変換\r\n * - if/for/endif/endfor/elseif/elseなどの制御構文をネスト対応で<template>タグに変換\r\n * - 通常の埋め込み式（{{expr}}）はコメントノード（<!--embed:expr-->）に変換\r\n *\r\n * 設計ポイント:\r\n * - stackでネスト構造を管理し、endif/endfor/elseif/elseの対応関係を厳密にチェック\r\n * - 不正なネストや対応しない構文にはraiseErrorで例外を発生\r\n * - elseif/elseはnot条件のtemplateを自動生成し、条件分岐を表現\r\n * - コメントノードへの変換で埋め込み式の安全なDOM挿入を実現\r\n */\r\nimport { COMMENT_EMBED_MARK } from \"../constants.js\";\r\nimport { raiseError } from \"../utils.js\";\r\n\r\nconst MUSTACHE_REGEXP = /\\{\\{([^\\}]+)\\}\\}/g;\r\nconst MUSTACHE_TYPES:Set<string> = new Set(['if', 'for', 'endif', 'endfor', 'elseif', 'else']);\r\n\r\ntype MustacheType = 'if' | 'for' | 'endif' | 'endfor' | 'elseif' | 'else';\r\ntype MustacheInfo = {\r\n  type: MustacheType;\r\n  remain: string; // after first ':'\r\n  expr: string;\r\n}\r\n\r\nexport function replaceMustacheWithTemplateTag(html: string): string {\r\n  const stack:MustacheInfo[] = [];\r\n  return html.replaceAll(MUSTACHE_REGEXP, (match, expr) => {\r\n    expr = expr.trim();\r\n    const [ type ] = expr.split(':');\r\n    if (!MUSTACHE_TYPES.has(type)) {\r\n      // embed\r\n      return `<!--${COMMENT_EMBED_MARK}${expr}-->`;\r\n    }\r\n    const remain = expr.slice(type.length + 1).trim();\r\n    const currentInfo:MustacheInfo = { type, expr, remain };\r\n    if (type === 'if' || type === 'for') {\r\n      stack.push(currentInfo);\r\n      return `<template data-bind=\"${expr}\">`;\r\n    } else if (type === 'endif') {\r\n      const endTags = [];\r\n      do {\r\n        const info = stack.pop() ?? raiseError('replaceMustacheToTemplateOrEmbed: endif without if');\r\n        if (info.type === 'if') {\r\n          endTags.push('</template>');\r\n          break;\r\n        } else if (info.type === 'elseif') {\r\n          endTags.push('</template>');\r\n        } else {\r\n          raiseError('replaceMustacheToTemplateOrEmbed: endif without if');\r\n        }\r\n      } while(true);\r\n      return endTags.join('');\r\n    } else if (type === 'endfor') {\r\n      const info = stack.pop() ?? raiseError('replaceMustacheToTemplateOrEmbed: endif without if');\r\n      if (info.type === 'for') {\r\n        return '</template>';\r\n      } else {\r\n        raiseError('replaceMustacheToTemplateOrEmbed: endfor without for');\r\n      }\r\n    } else if (type === 'elseif') {\r\n      const lastInfo = stack.at(-1) ?? raiseError('replaceMustacheToTemplateOrEmbed: elseif without if');\r\n      if (lastInfo.type === 'if' || lastInfo.type === 'elseif') {\r\n        stack.push(currentInfo);\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\"><template data-bind=\"if:${remain}\">`;\r\n      } else {\r\n        raiseError('replaceMustacheToTemplateOrEmbed: elseif without if');\r\n      }\r\n    } else if (type === 'else') {\r\n      const lastInfo = stack.at(-1) ?? raiseError('replaceMustacheToTemplateOrEmbed: else without if');\r\n      if (lastInfo.type === 'if') {\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\">`;\r\n      } else {\r\n        raiseError('replaceMustacheToTemplateOrEmbed: else without if');\r\n      }\r\n    } else {\r\n      raiseError('replaceMustacheToTemplateOrEmbed: unknown type');\r\n    }\r\n  });\r\n}\r\n\r\n\r\n\r\n","/**\r\n * replaceTemplateTagWithComment.ts\r\n *\r\n * <template>タグをコメントノードに置換し、テンプレートを再帰的に登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - 指定したHTMLTemplateElementをコメントノード（<!--template:id-->）に置換\r\n * - SVG内のtemplateタグは通常のtemplate要素に変換し、属性や子ノードを引き継ぐ\r\n * - テンプレート内の入れ子templateも再帰的に置換・登録\r\n * - registerTemplateでテンプレートをID付きで管理\r\n *\r\n * 設計ポイント:\r\n * - テンプレートの階層構造を維持しつつ、DOM上はコメントノードでマーク\r\n * - SVG対応や属性引き継ぎなど、汎用的なテンプレート処理に対応\r\n * - generateIdでユニークIDを割り当て、テンプレート管理を一元化\r\n */\r\nimport { COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants.js\";\r\nimport { generateId } from \"../GlobalId/generateId.js\";\r\nimport { registerTemplate } from \"./registerTemplate.js\";\r\n\r\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\r\n\r\nexport function replaceTemplateTagWithComment(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number = id\r\n):number {\r\n  // テンプレートの親ノードが存在する場合は、テンプレートをコメントノードに置き換える\r\n  template.parentNode?.replaceChild(document.createComment(`${COMMENT_TEMPLATE_MARK}${id}`), template);\r\n  if (template.namespaceURI === SVG_NS) {\r\n    // SVGタグ内のtemplateタグを想定\r\n    const newTemplate = document.createElement(\"template\");\r\n    for(let childNode of Array.from(template.childNodes)) {\r\n      newTemplate.content.appendChild(childNode);\r\n    }\r\n    const bindText = template.getAttribute(DATA_BIND_ATTRIBUTE);\r\n    newTemplate.setAttribute(DATA_BIND_ATTRIBUTE, bindText ?? \"\");\r\n    template = newTemplate;\r\n  }\r\n  template.content.querySelectorAll(\"template\").forEach(template => {\r\n    replaceTemplateTagWithComment(generateId(), template, rootId);\r\n  });\r\n  registerTemplate(id, template, rootId);\r\n  return id;\r\n}\r\n","/**\r\n * registerHtml.ts\r\n *\r\n * HTML文字列をテンプレートとして登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - 指定IDでHTMLテンプレートを生成し、data-id属性を付与\r\n * - Mustache構文（{{ }})をテンプレートタグに変換（replaceMustacheWithTemplateTagを利用）\r\n * - テンプレートタグをコメントに置換（replaceTemplateTagWithCommentを利用）\r\n *\r\n * 設計ポイント:\r\n * - テンプレートの動的生成・管理や、構文変換による柔軟なテンプレート処理に対応\r\n * - テンプレートはdocument.createElement(\"template\")で生成し、data-idで識別\r\n */\r\nimport { replaceMustacheWithTemplateTag } from \"./replaceMustacheWithTemplateTag.js\";\r\nimport { replaceTemplateTagWithComment } from \"./replaceTemplateTagWithComment.js\";\r\n\r\nexport function registerHtml(id: number, html:string) {\r\n  const template = document.createElement(\"template\");\r\n  template.dataset.id = id.toString();\r\n  template.innerHTML = replaceMustacheWithTemplateTag(html);\r\n  replaceTemplateTagWithComment(id, template);\r\n}","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IBinding } from \"../DataBinding/types\";\r\nimport { GetByRefSymbol, SetByRefSymbol } from \"../StateClass/symbols\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { BindParentComponentSymbol, GetPropertyValueFromChildSymbol, NamesSymbol, RenderSymbol, SetPropertyValueFromChildSymbol } from \"./symbols.js\";\r\nimport { IComponentState, IComponentStateHandler, IComponentStateProxy } from \"./types\";\r\n\r\n/**\r\n * createComponentState.ts\r\n * \r\n * Structiveコンポーネントの状態管理を担う「ComponentState」クラスと、そのプロキシ生成関数の実装。\r\n *\r\n * 主な役割:\r\n * - 親コンポーネントとのバインディング（親プロパティのgetter/setterを動的に定義）\r\n * - 親コンポーネントからのバインディング一括登録（bindParentComponent）\r\n * - 状態プロパティの取得・設定・レンダリング（getPropertyValue, setPropertyValue, render）\r\n * - Proxyハンドラで、プロパティアクセスを自動的にget/set/特殊メソッドに振り分け\r\n *\r\n * 構造・設計ポイント:\r\n * - 親子コンポーネント間のデータ連携を柔軟に実現\r\n * - ループコンテキストや非同期更新にも対応\r\n * - Proxyによる柔軟なAPI（state.xxxで直接アクセス可能）\r\n *\r\n * @param engine IComponentEngineインスタンス\r\n * @returns      IComponentStateProxy（Proxyラップされた状態オブジェクト）\r\n */\r\nclass ComponentState implements IComponentState {\r\n  engine: IComponentEngine;\r\n  bindingByName: Record<string, IBinding> = {};\r\n  #names? : Set<string>;\r\n  constructor(engine: IComponentEngine) {\r\n    this.engine = engine;\r\n  }\r\n\r\n  get names(): Set<string> {\r\n    return this.#names ?? new Set<string>();\r\n  }\r\n\r\n  bindParentProperty(binding: IBinding): void {\r\n    const propName = binding.bindingNode.subName;\r\n    this.bindingByName[propName] = binding;\r\n    Object.defineProperty(this.engine.state, propName, {\r\n      get: () => {\r\n        return binding.bindingState.filteredValue;\r\n      },\r\n      set: (value: any) => {\r\n        const engine = binding.engine;\r\n        const loopContext = binding.parentBindContent.currentLoopContext;\r\n        engine.updater.addProcess(async () => {\r\n          engine.useWritableStateProxy(loopContext, async (stateProxy) => {\r\n            // Set the value in the writable state proxy\r\n            // This will trigger the binding update logic\r\n            return binding.updateStateValue(stateProxy, value);\r\n          });\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  unbindParentProperty(binding: IBinding): void {\r\n    const propName = binding.bindingNode.subName;\r\n    Object.defineProperty(this.engine.state, propName, { value:undefined });\r\n  }\r\n  \r\n  /** \r\n   * 子コンポーネントから呼び出される \r\n   */\r\n  bindParentComponent(): void {\r\n    // bindParentComponent\r\n    const parent = this.engine.owner.parentStructiveComponent;\r\n    if (parent === null) {\r\n      return;\r\n    }\r\n    const bindings = parent.getBindingsFromChild(this.engine.owner);\r\n    for (const binding of bindings ?? []) {\r\n      this.bindParentProperty(binding);\r\n    }\r\n    this.#names = new Set(Object.keys(this.bindingByName));\r\n  }\r\n\r\n  unbindParentComponent(): void {\r\n    // unbindParentComponent\r\n    for(const name of this.names) {\r\n      const binding = this.bindingByName[name];\r\n      if (binding) {\r\n        this.unbindParentProperty(binding);\r\n      }\r\n    }\r\n  }\r\n\r\n  render(name: string, value:any): void {\r\n    if (!this.names.has(name)) {\r\n      return;\r\n    }\r\n    // render\r\n    const info = getStructuredPathInfo(name);\r\n    this.engine.updater.addUpdatedStatePropertyRefValue(info, null, value)\r\n  }\r\n\r\n  getPropertyValue(name: string): any {\r\n    // getPropertyValue\r\n    const info = getStructuredPathInfo(name);\r\n    return this.engine.getPropertyValue(info, null);\r\n  }\r\n\r\n  setPropertyValue(name: string, value: any): void {\r\n    // setPropertyValue\r\n    const info = getStructuredPathInfo(name);\r\n    this.engine.setPropertyValue(info, null, value); \r\n  }\r\n\r\n  getPropertyValueFromChild(name: string): any {\r\n    const info = getStructuredPathInfo(name);\r\n    const rootName = info.cumulativePaths[0];\r\n    if (!this.names.has(rootName)) {\r\n      return undefined;\r\n    }\r\n    const parentBinding = this.bindingByName[rootName];\r\n    const remainName = name.slice(rootName.length); // include dot\r\n    const parentPropName = parentBinding?.bindingState.pattern + remainName;\r\n    const parentPropInfo = getStructuredPathInfo(parentPropName);\r\n    const listIndex = parentBinding.bindingState.listIndex ?? null;\r\n    return parentBinding.bindingState.state[GetByRefSymbol](parentPropInfo, listIndex);\r\n  }\r\n\r\n  setPropertyValueFromChild(name: string, value: any): void {\r\n    const info = getStructuredPathInfo(name);\r\n    const rootName = info.cumulativePaths[0];\r\n    if (!this.names.has(rootName)) {\r\n      return;\r\n    }\r\n    const parentBinding = this.bindingByName[rootName];\r\n    const loopContext = parentBinding.parentBindContent.currentLoopContext;\r\n    const remainName = name.slice(rootName.length); // include dot\r\n    const parentPropName = parentBinding?.bindingState.pattern + remainName;\r\n    const parentPropInfo = getStructuredPathInfo(parentPropName);\r\n    const listIndex = parentBinding.bindingState.listIndex ?? null;\r\n    const engine = parentBinding.engine;\r\n    engine.updater.addProcess(async () => {\r\n      engine.useWritableStateProxy(loopContext, async (stateProxy) => {\r\n        // Set the value in the writable state proxy\r\n        // This will trigger the binding update logic\r\n        return stateProxy[SetByRefSymbol](parentPropInfo, listIndex, value);\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nclass ComponentStateHandler implements IComponentStateHandler {\r\n  get(state: IComponentState, prop: PropertyKey, receiver: IComponentState): any {\r\n    if (prop === RenderSymbol) {\r\n      return state.render.bind(state);\r\n    } else if (prop === BindParentComponentSymbol) {\r\n      // 子コンポーネントから呼ばれる\r\n      return state.bindParentComponent.bind(state);\r\n    } else if (prop === NamesSymbol) {\r\n      return state.names;\r\n    } else if (prop === GetPropertyValueFromChildSymbol) {\r\n      return state.getPropertyValueFromChild.bind(state);\r\n    } else if (prop === SetPropertyValueFromChildSymbol) {\r\n      return state.setPropertyValueFromChild.bind(state);\r\n    } else if (typeof prop === 'string') {\r\n      return state.getPropertyValue(prop);\r\n    } else {\r\n      return Reflect.get(state, prop, receiver);\r\n    }\r\n  }\r\n\r\n  set(state: IComponentState, prop: PropertyKey, value: any, receiver: IComponentState): boolean {\r\n    if (typeof prop === 'string') {\r\n      state.setPropertyValue(prop, value);\r\n      return true;\r\n    } else {\r\n      return Reflect.set(state, prop, value, receiver);\r\n    }\r\n  }\r\n};\r\n\r\nexport const createComponentState = (engine: IComponentEngine): IComponentStateProxy => {\r\n  return new Proxy<IComponentState>(new ComponentState(engine), new ComponentStateHandler()) as IComponentStateProxy;\r\n}","/**\r\n * createAccessorFunctions.ts\r\n *\r\n * Stateプロパティのパス情報（IStructuredPathInfo）から、動的なgetter/setter関数を生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - パス情報とgetter集合から、最適なアクセサ関数（get/set）を動的に生成\r\n * - ワイルドカード（*）やネストしたプロパティパスにも対応\r\n * - パスやセグメントのバリデーションも実施\r\n *\r\n * 設計ポイント:\r\n * - matchPathsから最長一致のgetterパスを探索し、そこからの相対パスでアクセサを構築\r\n * - パスが一致しない場合はinfo.pathSegmentsから直接アクセサを生成\r\n * - new Functionで高速なgetter/setterを動的生成\r\n * - パスやセグメント名は正規表現で厳密にチェックし、安全性を担保\r\n */\r\nimport { getStructuredPathInfo } from \"./getStructuredPathInfo\";\r\nimport { IAccessorFunctions, IStructuredPathInfo } from \"./types\";\r\n\r\nconst checkSegmentRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\r\nconst checkPathRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*(\\.[a-zA-Z_$][0-9a-zA-Z_$]*|\\.\\*)*$/;\r\n\r\nexport function createAccessorFunctions(info: IStructuredPathInfo, getters: Set<string>): IAccessorFunctions {\r\n  const matchPaths = new Set(info.cumulativePaths).intersection(getters);\r\n  let len = -1;\r\n  let matchPath = '';\r\n  for(const curPath of matchPaths) {\r\n    const pathSegments = curPath.split('.');\r\n    if (pathSegments.length === 1) {\r\n      continue;\r\n    }\r\n    if (pathSegments.length > len) {\r\n      len = pathSegments.length;\r\n      matchPath = curPath;\r\n    }\r\n  }\r\n  if (matchPath.length > 0) {\r\n    if (!checkPathRegexp.test(matchPath)) {\r\n      throw new Error(`Invalid path: ${matchPath}`);\r\n    }\r\n    const matchInfo = getStructuredPathInfo(matchPath);\r\n    const segments = [];\r\n    let count = matchInfo.wildcardCount;\r\n    for(let i = matchInfo.pathSegments.length; i < info.pathSegments.length; i++) {\r\n      const segment = info.pathSegments[i];\r\n      if (segment === '*') {\r\n        segments.push(\"[this.$\" + (count + 1) + \"]\");\r\n        count++;\r\n      } else {\r\n        if (!checkSegmentRegexp.test(segment)) {\r\n          throw new Error(`Invalid segment name: ${segment}`);\r\n        }\r\n        segments.push(\".\" + segment);\r\n      }\r\n    }\r\n    const path = segments.join('');\r\n    return {\r\n      get : new Function('', `return this[\"${matchPath}\"]${path};`) as ()=> any,\r\n      set : new Function('value', `this[\"${matchPath}\"]${path} = value;`) as (value: any) => void,\r\n    }\r\n  } else {\r\n    const segments = [];\r\n    let count = 0;\r\n    for(const segment of info.pathSegments) {\r\n      if (segment === '*') {\r\n        segments.push(\"[this.$\" + (count + 1) + \"]\");\r\n        count++;\r\n      } else {\r\n        if (!checkSegmentRegexp.test(segment)) {\r\n          throw new Error(`Invalid segment name: ${segment}`);\r\n        }\r\n        segments.push((segments.length > 0 ? \".\" : \"\") + segment);\r\n      }\r\n    }\r\n    const path = segments.join('');\r\n    return {\r\n      get : new Function('', `return this.${path};`) as ()=> any,\r\n      set : new Function('value', `this.${path} = value;`) as (value: any) => void,\r\n    }\r\n  }\r\n\r\n}\r\n","/**\r\n * createComponentClass.ts\r\n *\r\n * StructiveのWeb Components用カスタム要素クラスを動的に生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - ユーザー定義のcomponentData（stateClass, html, css等）からWeb Componentsクラスを生成\r\n * - StateClass/テンプレート/CSS/バインディング情報などをIDで一元管理・登録\r\n * - 独自のget/setトラップやバインディング、親子コンポーネント探索、フィルター拡張など多機能な基盤を提供\r\n * - 静的プロパティでテンプレート・スタイル・StateClass・フィルター・getter情報などにアクセス可能\r\n * - defineメソッドでカスタム要素として登録\r\n *\r\n * 設計ポイント:\r\n * - findStructiveParentで親Structiveコンポーネントを探索し、階層的な状態管理を実現\r\n * - getter/setter/バインディング最適化やアクセサ自動生成（optimizeAccessor）に対応\r\n * - テンプレート・CSS・StateClass・バインディング情報をIDで一元管理し、再利用性・拡張性を確保\r\n * - フィルターやバインディング情報も静的プロパティで柔軟に拡張可能\r\n */\r\nimport { inputBuiltinFilters, outputBuiltinFilters } from \"../Filter/builtinFilters.js\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { generateId } from \"../GlobalId/generateId.js\";\r\nimport { getStateClassById, registerStateClass } from \"../StateClass/registerStateClass.js\";\r\nimport { getStyleSheetById } from \"../StyleSheet/registerStyleSheet.js\";\r\nimport { registerCss } from \"../StyleSheet/regsiterCss.js\";\r\nimport { createComponentEngine } from \"../ComponentEngine/ComponentEngine.js\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types.js\";\r\nimport { registerHtml } from \"../Template/registerHtml.js\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { getBaseClass } from \"./getBaseClass.js\";\r\nimport { getComponentConfig } from \"./getComponentConfig.js\";\r\nimport { IComponent, IUserComponentData, IUserConfig, StructiveComponentClass, StructiveComponent } from \"./types\";\r\nimport { getListPathsSetById, getPathsSetById } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { IStructiveState } from \"../StateClass/types\";\r\nimport { IBinding } from \"../DataBinding/types\";\r\nimport { IComponentStateProxy } from \"../ComponentState/types\";\r\nimport { createComponentState } from \"../ComponentState/createComponentState.js\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { createAccessorFunctions } from \"../StateProperty/createAccessorFunctions.js\";\r\nimport { config as globalConfig } from \"./getGlobalConfig.js\";\r\nimport { raiseError } from \"../utils.js\";\r\n\r\nfunction findStructiveParent(el:StructiveComponent): IComponent | null {\r\n  let current = el.parentNode;\r\n  while (current) {\r\n    if ((current as StructiveComponent).state && (current as StructiveComponent).isStructive) {\r\n      return current as StructiveComponent;\r\n    }\r\n    current = current.parentNode;\r\n    if (current instanceof ShadowRoot) {\r\n      if (current.host && (current.host as StructiveComponent).state && (current.host as StructiveComponent).isStructive) {\r\n        return current.host as StructiveComponent;\r\n      }\r\n      current = current.host;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function createComponentClass(componentData: IUserComponentData): StructiveComponentClass {\r\n  const config = (componentData.stateClass.$config ?? {})as IUserConfig;\r\n  const componentConfig = getComponentConfig(config);\r\n  const id = generateId();\r\n  const { html, css, stateClass } = componentData;\r\n  const inputFilters:FilterWithOptions = Object.assign({}, inputBuiltinFilters);\r\n  const outputFilters:FilterWithOptions = Object.assign({}, outputBuiltinFilters);\r\n  stateClass.$isStructive = true;\r\n  registerHtml(id, html);\r\n  registerCss(id, css);\r\n  registerStateClass(id, stateClass);\r\n  const baseClass = getBaseClass(componentConfig.extends);\r\n  const extendTagName = componentConfig.extends;\r\n  return class extends baseClass implements IComponent {\r\n    #engine: IComponentEngine;\r\n    #componentState: IComponentStateProxy;\r\n\r\n    constructor() {\r\n      super();\r\n      this.#engine = createComponentEngine(componentConfig, this as StructiveComponent);\r\n      this.#componentState = createComponentState(this.#engine);\r\n      this.#engine.setup();\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.#engine.connectedCallback();\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.#engine.disconnectedCallback();\r\n    }\r\n\r\n    #parentStructiveComponent: IComponent | null | undefined;\r\n    get parentStructiveComponent(): IComponent | null {\r\n      if (typeof this.#parentStructiveComponent === \"undefined\") {\r\n        this.#parentStructiveComponent = findStructiveParent(this as StructiveComponent);\r\n      }\r\n      return this.#parentStructiveComponent;\r\n    }\r\n\r\n    get state(): IComponentStateProxy {\r\n      return this.#componentState;\r\n    }\r\n\r\n    get isStructive(): boolean {\r\n      return this.#engine.stateClass.$isStructive ?? false;\r\n    }\r\n\r\n    get waitForInitialize(): PromiseWithResolvers<void> {\r\n      return this.#engine.waitForInitialize;\r\n    }\r\n\r\n    getBindingsFromChild(component: IComponent): Set<IBinding> | null {\r\n      return this.#engine.bindingsByComponent.get(component as StructiveComponent) ?? null;\r\n    }\r\n\r\n    registerChildComponent(component:StructiveComponent): void {\r\n      this.#engine.registerStrutiveComponent(component);\r\n    }\r\n    unregisterChildComponent(component:StructiveComponent): void {\r\n      this.#engine.unregisterStrutiveComponent(component);\r\n    }\r\n    static define(tagName:string) {\r\n      if (extendTagName) {\r\n        customElements.define(tagName, this, { extends: extendTagName });\r\n      } else {\r\n        customElements.define(tagName, this);\r\n      }\r\n    }\r\n\r\n    static get id():number {\r\n      return id;\r\n    }\r\n    static #html:string = html;\r\n    static get html():string {\r\n      return this.#html;\r\n    }\r\n    static set html(value:string) {\r\n      this.#html = value;\r\n      registerHtml(this.id, value);\r\n      this.#template = null;\r\n    }\r\n\r\n    static #css:string = css;\r\n    static get css() {\r\n      return this.#css;\r\n    }\r\n    static set css(value:string) {\r\n      this.#css = value;\r\n      registerCss(this.id, value);\r\n      this.#styleSheet = null;\r\n    }\r\n    static #template: HTMLTemplateElement | null = null;\r\n    static get template():HTMLTemplateElement {\r\n      if (!this.#template) {\r\n        this.#template = getTemplateById(this.id);\r\n      }\r\n      return this.#template;\r\n    }\r\n    static #styleSheet: CSSStyleSheet | null = null;\r\n    static get styleSheet():CSSStyleSheet {\r\n      if (!this.#styleSheet) {\r\n        this.#styleSheet = getStyleSheetById(this.id);\r\n      }\r\n      return this.#styleSheet;\r\n    }\r\n    static #stateClass: IStructiveState | null = null;\r\n    static get stateClass():IStructiveState {\r\n      if (!this.#stateClass) {\r\n        this.#stateClass = getStateClassById(this.id) as IStructiveState;\r\n      }\r\n      return this.#stateClass;\r\n    }\r\n    static #inputFilters:FilterWithOptions = inputFilters;\r\n    static get inputFilters():FilterWithOptions {\r\n      return this.#inputFilters;\r\n    }\r\n    static #outputFilters:FilterWithOptions = outputFilters;\r\n    static get outputFilters():FilterWithOptions {\r\n      return this.#outputFilters;\r\n    }\r\n    static get listPaths(): Set<string> {\r\n      return getListPathsSetById(this.id);\r\n    }\r\n    static get paths(): Set<string> {\r\n      return getPathsSetById(this.id);\r\n    }\r\n    static #getters: Set<string> | null = null;\r\n    static get getters(): Set<string> {\r\n      return this.#getters ?? raiseError(\"getters is null\");\r\n    }\r\n    static #trackedGetters: Set<string> | null = null;\r\n    static get trackedGetters(): Set<string> {\r\n      if(this.#trackedGetters === null) {\r\n        this.#trackedGetters = new Set<string>();\r\n        this.#getters = new Set<string>();\r\n        let currentProto = this.stateClass.prototype;\r\n        while (currentProto && currentProto !== Object.prototype) {\r\n          const trackedGetters = Object.getOwnPropertyDescriptors(currentProto);\r\n          if (trackedGetters) {\r\n            for (const [key, desc] of Object.entries(trackedGetters)) {\r\n              if ((desc as PropertyDescriptor).get && !(desc as PropertyDescriptor).set) {\r\n                this.#trackedGetters.add(key);\r\n              }\r\n              this.#getters.add(key);\r\n            }\r\n          }\r\n          currentProto = Object.getPrototypeOf(currentProto);\r\n        }\r\n        if (globalConfig.optimizeAccessor) {\r\n          for(const path of this.paths) {\r\n            const info = getStructuredPathInfo(path);\r\n            if (info.pathSegments.length === 1) {\r\n              continue;\r\n            }\r\n            if (this.#getters.has(path)) {\r\n              continue;\r\n            }\r\n            const funcs = createAccessorFunctions(info, this.#getters);\r\n            Object.defineProperty(this.stateClass.prototype, path, {\r\n              get: funcs.get,\r\n              set: funcs.set,\r\n              enumerable: true,\r\n              configurable: true,\r\n            });\r\n          }\r\n        }\r\n      }\r\n      return this.#trackedGetters;\r\n\r\n    }\r\n  } as StructiveComponentClass;\r\n}\r\n","/**\r\n * getComponentConfig.ts\r\n *\r\n * ユーザー設定（IUserConfig）とグローバル設定を統合し、コンポーネントの設定（IComponentConfig）を生成するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - getGlobalConfigでグローバル設定を取得\r\n * - ユーザー設定が優先され、未指定の場合はグローバル設定値を利用\r\n * - enableShadowDomやextendsなどの設定値を一元的に返却\r\n *\r\n * 設計ポイント:\r\n * - ユーザーごとの個別設定と全体のデフォルト設定を柔軟に統合\r\n * - 設定値のデフォルト化や拡張性を考慮した設計\r\n */\r\nimport { getGlobalConfig } from \"./getGlobalConfig.js\";\r\nimport { IUserConfig, IComponentConfig } from \"./types\";\r\n\r\nexport function getComponentConfig(userConfig: IUserConfig): IComponentConfig {\r\n  const globalConfig = getGlobalConfig();\r\n  return {\r\n    enableShadowDom: userConfig.enableShadowDom ?? globalConfig.enableShadowDom,\r\n    extends        : userConfig.extends ?? null,\r\n  };\r\n}","/**\r\n * getBaseClass.ts\r\n *\r\n * 指定したタグ名（extendTagName）から、その要素のコンストラクタ（基底クラス）を取得するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - extendTagNameが指定されていれば、そのタグのHTMLElementコンストラクタを返す\r\n * - 指定がなければHTMLElementを返す\r\n *\r\n * 設計ポイント:\r\n * - カスタム要素の継承元クラスを動的に取得し、柔軟なWeb Components拡張に対応\r\n */\r\nimport { Constructor } from \"./types\";\r\n\r\nexport function getBaseClass(extendTagName: string | null):Constructor<HTMLElement> {\r\n  return extendTagName ? (document.createElement(extendTagName).constructor as Constructor<HTMLElement>) : HTMLElement;\r\n}","/**\r\n * createSingleFileComponent.ts\r\n *\r\n * Structive用のシングルファイルコンポーネント（SFC）をパースし、各要素（HTML, CSS, StateClass）を抽出・生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - テキストから<template>・<script type=\"module\">・<style>を抽出し、それぞれを分離\r\n * - <script type=\"module\">はBase64エンコードして動的importし、StateClassとして利用\r\n * - {{...}}埋め込み式は一時的にコメントノード化してHTMLパース時の消失を防止し、復元\r\n * - 各要素（html, css, stateClass, text）をIUserComponentDataとして返却\r\n *\r\n * 設計ポイント:\r\n * - escapeEmbed/unescapeEmbedでMustache構文の安全なパースを実現\r\n * - scriptはdata:URL経由で安全に動的import\r\n * - テンプレート・スクリプト・スタイルを柔軟に分離・管理できる設計\r\n */\r\nimport { IStructiveState } from \"../StateClass/types\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nfunction escapeEmbed(html: string): string {\r\n  return html.replaceAll(/\\{\\{([^\\}]+)\\}\\}/g, (match, expr) => {\r\n    return `<!--{{${expr}}}-->`;\r\n  });\r\n}\r\n\r\nfunction unescapeEmbed(html:string):string {\r\n  return html.replaceAll(/<!--\\{\\{([^\\}]+)\\}\\}-->/g, (match, expr) => {\r\n    return `{{${expr}}}`;\r\n  });\r\n}\r\n\r\nexport async function createSingleFileComponent(text: string): Promise<IUserComponentData> {\r\n  const template = document.createElement(\"template\");\r\n  template.innerHTML = escapeEmbed(text);\r\n\r\n  const html = template.content.querySelector(\"template\");\r\n  html?.remove();\r\n\r\n  const script = template.content.querySelector(\"script[type=module]\") as HTMLScriptElement;\r\n  const b64 = btoa(String.fromCodePoint(...new TextEncoder().encode(script.text)));\r\n  const scriptModule = script ? await import(\"data:application/javascript;base64,\" + b64) : {};\r\n//  const scriptModule = script ? await import(\"data:text/javascript;charset=utf-8,\" + script.text) : {};\r\n  script?.remove();\r\n\r\n  const style = template.content.querySelector(\"style\");\r\n  style?.remove();\r\n\r\n  const stateClass = (scriptModule.default ?? class {}) as IStructiveState;\r\n  \r\n  return {\r\n    text,\r\n    html      : unescapeEmbed(html?.innerHTML ?? \"\").trim(),\r\n    css       : style?.textContent ?? \"\",\r\n    stateClass,\r\n  }\r\n}","/**\r\n * loadSingleFileComponent.ts\r\n *\r\n * 指定パスのシングルファイルコンポーネント（SFC）をfetchし、パースしてIUserComponentDataとして返すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - fetchで指定パスのSFCファイルを取得\r\n * - テキストとして読み込み、createSingleFileComponentでパース\r\n * - パース結果（IUserComponentData）を返却\r\n *\r\n * 設計ポイント:\r\n * - import.meta.resolveを利用し、パス解決の柔軟性を確保\r\n * - 非同期処理で動的なコンポーネントロードに対応\r\n */\r\nimport { createSingleFileComponent } from \"./createSingleFileComponent.js\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nexport async function loadSingleFileComponent(path: string): Promise<IUserComponentData> {\r\n  const response = await fetch(import.meta.resolve(path));\r\n  const text = await response.text();\r\n  return createSingleFileComponent(text);\r\n}\r\n","/**\r\n * registerComponentClass.ts\r\n *\r\n * StructiveのWeb Componentsクラスを指定したタグ名でカスタム要素として登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - registerComponentClass: 渡されたcomponentClassをtagNameでdefineメソッドを使って登録\r\n *\r\n * 設計ポイント:\r\n * - Web Componentsのカスタム要素登録を簡潔にラップし、再利用性を高める設計\r\n */\r\nimport { StructiveComponentClass } from \"./types\";\r\n\r\nexport function registerComponentClass(tagName: string, componentClass: StructiveComponentClass) {\r\n  componentClass.define(tagName);\r\n}","/**\r\n * MainWrapper.ts\r\n *\r\n * アプリ全体のレイアウトやルーティングを管理するカスタムエレメント MainWrapper の実装です。\r\n *\r\n * 主な役割:\r\n * - Shadow DOMの有効化やレイアウトテンプレートの動的読み込み\r\n * - レイアウトテンプレートやスタイルの適用\r\n * - ルーター要素（routerTagName）の動的追加\r\n *\r\n * 設計ポイント:\r\n * - config.enableShadowDom でShadow DOMの有効/無効を切り替え\r\n * - config.layoutPath が指定されていればfetchでレイアウトHTMLを取得し、テンプレート・スタイルを適用\r\n * - スタイルはadoptedStyleSheetsでShadowRootまたはdocumentに適用\r\n * - レイアウトが指定されていない場合はデフォルトのslotを挿入\r\n * - config.enableRouter が有効な場合はrouter要素をslotに追加\r\n */\r\nimport { raiseError } from \"../utils\";\r\nimport { config } from \"../WebComponents/getGlobalConfig\";\r\n\r\nconst SLOT_KEY = \"router\";\r\nconst DEFAULT_LAYOUT = `<slot name=\"${SLOT_KEY}\"></slot>`;\r\n\r\nexport class MainWrapper extends HTMLElement {\r\n  constructor() {\r\n    super();\r\n    if (config.enableShadowDom) {\r\n      this.attachShadow({ mode: 'open' });\r\n    }\r\n  }\r\n\r\n  async connectedCallback() {\r\n    await this.loadLayout();\r\n    this.render();\r\n  }\r\n\r\n  get root(): ShadowRoot | HTMLElement {\r\n    return this.shadowRoot ?? this;\r\n  }\r\n\r\n  async loadLayout() {\r\n    if (config.layoutPath) {\r\n      const response = await fetch(config.layoutPath);\r\n      if (response.ok) {\r\n        const layoutText = await response.text();\r\n        const workTemplate = document.createElement(\"template\");\r\n        workTemplate.innerHTML = layoutText;\r\n      \r\n        const template = workTemplate.content.querySelector(\"template\");\r\n        const style = workTemplate.content.querySelector(\"style\") as CSSStyleSheet | null;\r\n      \r\n        this.root.appendChild(template?.content ?? document.createDocumentFragment());\r\n        if (style) {\r\n          const shadowRootOrDocument = this.shadowRoot ?? document;\r\n          const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n          if (!styleSheets.includes(style)) {\r\n            shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, style];\r\n          }\r\n        }\r\n      } else {\r\n        raiseError(`Failed to load layout from ${config.layoutPath}`);\r\n      }\r\n    } else {\r\n      this.root.innerHTML = DEFAULT_LAYOUT;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    // add router\r\n    if (config.enableRouter) {\r\n      const router = document.createElement(config.routerTagName);\r\n      router.setAttribute('slot', SLOT_KEY);\r\n      this.root.appendChild(router);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * loadFromImportMap.ts\r\n *\r\n * importmapの情報をもとに、Structiveのルートやコンポーネントを動的にロード・登録するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - importmap.imports内のエイリアスを走査し、@routes/や@components/のプレフィックスで判定\r\n * - @routes/の場合はルーティング情報をentryRouteで登録\r\n * - @components/の場合はloadSingleFileComponentでSFCをロードし、createComponentClassでクラス化してregisterComponentClassで登録\r\n *\r\n * 設計ポイント:\r\n * - importmapのエイリアスを利用して、ルーティングやコンポーネントの自動登録を実現\r\n * - パスやタグ名の正規化、パラメータ除去なども自動で処理\r\n * - 非同期でSFCをロードし、動的なWeb Components登録に対応\r\n */\r\nimport { entryRoute } from \"../Router/Router\";\r\nimport { createComponentClass } from \"./createComponentClass\";\r\nimport { loadImportmap } from \"./loadImportmap\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent\";\r\nimport { registerComponentClass } from \"./registerComponentClass\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nconst ROUTES_KEY = \"@routes/\";\r\nconst COMPONENTS_KEY = \"@components/\";\r\n\r\nexport async function loadFromImportMap(): Promise<void> {\r\n  const importmap = loadImportmap();\r\n  if (importmap.imports) {\r\n    for (const [alias, value] of Object.entries(importmap.imports)) {\r\n      let tagName;\r\n      if (alias.startsWith(ROUTES_KEY)) {\r\n        const path = alias.slice(ROUTES_KEY.length - 1); // remove the prefix '@routes'\r\n        const pathWithoutParams = path.replace(/:[^\\s/]+/g, \"\"); // remove the params\r\n        tagName = \"routes\" + pathWithoutParams.replace(/\\//g, \"-\"); // replace '/' with '-'\r\n        entryRoute(tagName, path === \"/root\" ? \"/\" : path); // routing\r\n      } if (alias.startsWith(COMPONENTS_KEY)) {\r\n        tagName = alias.slice(COMPONENTS_KEY.length); // remove the prefix '@components/'\r\n      }\r\n      if (!tagName) {\r\n        continue;\r\n      }\r\n\r\n      let componentData : IUserComponentData | null = null;\r\n      componentData = await loadSingleFileComponent(alias);\r\n      const componentClass = createComponentClass(componentData);\r\n      registerComponentClass(tagName, componentClass);\r\n    }\r\n  }\r\n\r\n} \r\n","/**\r\n * loadImportmap.ts\r\n *\r\n * HTML内の<script type=\"importmap\">タグからimportmap情報を取得・統合するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - 複数のimportmapスクリプトタグを走査し、全てのimportsをマージしてIImportMap型で返却\r\n *\r\n * 設計ポイント:\r\n * - scriptタグのinnerHTMLをJSON.parseでパースし、importsプロパティを統合\r\n * - importmap.importsが複数存在する場合もObject.assignでマージ\r\n * - importmap仕様に準拠し、柔軟なimportエイリアス管理を実現\r\n */\r\nimport { IImportMap } from \"./types\";\r\n\r\nexport function loadImportmap():IImportMap {\r\n  const importmap: IImportMap = {};\r\n  document.querySelectorAll(\"script[type='importmap']\").forEach(script => {\r\n    const scriptImportmap = JSON.parse(script.innerHTML);\r\n    if (scriptImportmap.imports) {\r\n      importmap.imports = Object.assign(importmap.imports || {}, scriptImportmap.imports);\r\n    }\r\n  });\r\n  return importmap;\r\n}\r\n\r\n","/**\r\n * exports.ts\r\n *\r\n * Structiveの主要なエントリーポイント・APIを外部公開するモジュールです。\r\n *\r\n * 主な役割:\r\n * - registerSingleFileComponents, bootstrap, config などの主要APIをエクスポート\r\n * - defineComponents: SFC群をまとめて登録し、autoInitが有効なら自動で初期化\r\n * - bootstrapStructive: 初期化処理を一度だけ実行\r\n *\r\n * 設計ポイント:\r\n * - グローバル設定(config)を外部から参照・変更可能\r\n * - 初期化処理の多重実行を防止し、安全な起動を保証\r\n */\r\nimport { registerSingleFileComponents } from \"./WebComponents/registerSingleFIleComponents.js\";\r\nimport { bootstrap } from \"./bootstrap.js\";\r\nimport { config as _config } from \"./WebComponents/getGlobalConfig.js\";\r\nimport { IConfig } from \"./WebComponents/types\";\r\n\r\nexport const config: IConfig = _config;\r\n\r\nlet initialized = false;\r\nexport async function defineComponents(singleFileComponents: Record<string, string>):Promise<void> {\r\n  await registerSingleFileComponents(singleFileComponents);\r\n  if (config.autoInit) {\r\n    await bootstrapStructive();\r\n  }\r\n}\r\n\r\nexport async function bootstrapStructive():Promise<void> {\r\n  if (!initialized) {\r\n    await bootstrap();\r\n    initialized = true;\r\n  }\r\n}\r\n\r\n","/**\r\n * registerSingleFileComponents.ts\r\n *\r\n * 複数のシングルファイルコンポーネント（SFC）をまとめてStructiveのWeb Componentsとして登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - singleFileComponents（tagNameとパスのマップ）を走査し、各SFCを非同期で取得・パース\r\n * - enableRouterが有効な場合はentryRouteでルーティング情報も登録\r\n * - createComponentClassでWeb Componentsクラスを生成し、registerComponentClassでカスタム要素として登録\r\n *\r\n * 設計ポイント:\r\n * - SFCのロードからWeb Components登録、ルーティング登録までを一括で自動化\r\n * - 非同期処理で複数コンポーネントの動的登録に対応\r\n * - ルートパス\"/root\"の正規化や、@routesプレフィックスの除去など柔軟なパス処理\r\n */\r\nimport { entryRoute } from \"../Router/Router.js\";\r\nimport { createComponentClass } from \"./createComponentClass.js\";\r\nimport { config } from \"./getGlobalConfig.js\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent.js\";\r\nimport { registerComponentClass } from \"./registerComponentClass.js\";\r\nimport { IUserComponentData, SingleFileComponents } from \"./types\";\r\n\r\nexport async function registerSingleFileComponents(singleFileComponents:SingleFileComponents):Promise<void> {\r\n  for(const [ tagName, path ] of Object.entries(singleFileComponents)) {\r\n    let componentData : IUserComponentData | null = null;\r\n    if (config.enableRouter) {\r\n      const routePath = path.startsWith(\"@routes\") ? path.slice(7) : path; // remove the prefix 'routes:'\r\n      entryRoute(tagName, routePath === \"/root\" ? \"/\" : routePath); // routing\r\n    }\r\n    componentData = await loadSingleFileComponent(path);\r\n    const componentClass = createComponentClass(componentData);\r\n    registerComponentClass(tagName, componentClass);\r\n  }\r\n}","/**\r\n * bootstrap.ts\r\n *\r\n * Structiveアプリケーションの初期化処理を行うエントリーポイントです。\r\n *\r\n * 主な役割:\r\n * - グローバル設定(config)に従い、必要なコンポーネントやルーター、メインラッパーを登録・初期化\r\n * - autoLoadFromImportMapが有効な場合はimportmapからルートやコンポーネントを動的ロード\r\n * - enableRouterが有効な場合はRouterコンポーネントをカスタム要素として登録\r\n * - enableMainWrapperが有効な場合はMainWrapperをカスタム要素として登録し、autoInsertMainWrapperが有効ならbodyに自動挿入\r\n *\r\n * 設計ポイント:\r\n * - 設定値に応じて初期化処理を柔軟に制御\r\n * - importmapやカスタム要素の登録、DOMへの自動挿入など、Structiveの起動に必要な処理を一元化\r\n */\r\nimport { MainWrapper } from \"./MainWrapper/MainWrapper.js\";\r\nimport { Router } from \"./Router/Router.js\";\r\nimport { config } from \"./WebComponents/getGlobalConfig.js\";\r\nimport { loadFromImportMap } from \"./WebComponents/loadFromImportMap.js\";\r\n\r\nexport async function bootstrap(): Promise<void> {\r\n  if (config.autoLoadFromImportMap) {\r\n    await loadFromImportMap();\r\n  }\r\n\r\n  if (config.enableRouter) {\r\n    customElements.define(config.routerTagName, Router);\r\n  }\r\n\r\n  if (config.enableMainWrapper) {\r\n    customElements.define(config.mainTagName, MainWrapper);\r\n    if (config.autoInsertMainWrapper) {\r\n      const mainWrapper = document.createElement(config.mainTagName);\r\n      document.body.appendChild(mainWrapper);\r\n    }\r\n  }\r\n}"],"names":["ROUTE_PATH_PREFIX","routeEntries","globalRouter","Router","HTMLElement","_popstateHandler","constructor","super","this","popstateHandler","bind","connectedCallback","innerHTML","window","addEventListener","dispatchEvent","Event","disconnectedCallback","removeEventListener","event","preventDefault","render","navigate","to","history","pushState","Array","from","childNodes","filter","n","getAttribute","forEach","removeChild","routePath","location","pathname","tagName","params","path","tag","regex","RegExp","replace","test","matches","match","key","index","substring","customElement","document","createElement","setAttribute","JSON","stringify","appendChild","messageElement","textContent","entryRoute","startsWith","push","getRouter","globalConfig","debug","locale","enableShadowDom","enableMainWrapper","enableRouter","autoInsertMainWrapper","autoInit","mainTagName","routerTagName","layoutPath","autoLoadFromImportMap","optimizeList","optimizeListElements","optimizeAccessor","getGlobalConfig","config","optionsRequired","fnName","Error","optionMustBeNumber","valueMustBeNumber","valueMustBeDate","builtinFilters","eq","options","opt","value","optValue","Number","isNaN","ne","not","valueMustBeBoolean","lt","le","gt","ge","inc","dec","mul","div","fix","toFixed","toLocaleString","uc","toString","toUpperCase","lc","toLowerCase","cap","v","length","charAt","slice","trim","substr","opt1","opt1Value","opt2","opt2Value","pad","padStart","rep","repeat","rev","split","reverse","join","int","parseInt","float","parseFloat","round","Math","pow","floor","ceil","percent","date","Date","toLocaleDateString","time","toLocaleTimeString","datetime","ymd","year","getFullYear","month","getMonth","day","getDate","falsy","truthy","defaults","boolean","Boolean","number","string","String","null","outputBuiltinFilters","inputBuiltinFilters","id","generateId","raiseError","message","stateClassById","styleSheetById","registerCss","css","styleSheet","CSSStyleSheet","replaceSync","registerStyleSheet","textToFilter","filters","text","name","cache","Map","createFilters","texts","result","get","i","set","BindingNode","binding","node","decorates","bindContents","Set","subName","init","update","assignValue","bindingState","filteredValue","updateElements","listIndexes","values","isSelectElement","HTMLSelectElement","isFor","BindingNodeAttribute","BindingNodeCheckbox","isArray","element","checked","map","_val","includes","BindingNodeClassList","className","BindingNodeClassName","classList","add","remove","BindingNodeEvent","e","handler","engine","loopContext","parentBindContent","currentLoopContext","indexes","serialize","context","listIndex","stopPropagation","useWritableStateProxy","async","stateProxy","Reflect","apply","createBindingNodeEvent","filterTexts","filterFns","DATA_BIND_ATTRIBUTE","COMMENT_EMBED_MARK","COMMENT_TEMPLATE_MARK","BindingNodeBlock","BindingNodeIf","bindContent","trueBindContents","falseBindContents","createBindContent","parentNode","mountAfter","nextSibling","unmount","BindingNodeFor","bindContentsSet","bindContentByListIndex","WeakMap","bindContentPool","bindContentLastIndex","lastListIndexSet","assignListIndex","pattern","deleteBindContent","clearListIndex","poolLength","listIndexesSet","getListIndexesSet","info","newBindContensSet","lastBindContent","removeBindContentsSet","diff","difference","firstNode","lastNode","getLastNode","firstChildNode","oldListValues","getList","currentBindContents","targetBindContents","lastChildNode","oldValue","targetIndex","indexOf","prevBindContent","saveList","createBindingNodeFor","DEFAULT_PROPERTY","defaultPropertyByElementType","radio","checkbox","button","_cache","getDefaultPropertyByNodeType","HTMLTextAreaElement","HTMLOptionElement","HTMLButtonElement","HTMLAnchorElement","HTMLFormElement","HTMLInputElement","type","SVGElement","undefined","Text","Template","defaultEventByName","selected","BindingNodeProperty","defaultName","nodeType","getDefaultName","eventName","updateStateValue","createBindingNodeProperty","BindingNodeRadio","BindingNodeStyle","style","setProperty","symbolName","RenderSymbol","Symbol","for","BindParentComponentSymbol","NamesSymbol","GetPropertyValueFromChildSymbol","SetPropertyValueFromChildSymbol","BindingNodeComponent","bindings","bindingsByComponent","state","nodePropertyConstructorByNameByIsComment","class","if","nodePropertyConstructorByFirstName","attr","getBindingNodeCreator","propertyName","isComment","Comment","isElement","Element","fn","bindingNodeCreatorByName","nameElements","bindingNodeCreatorByFirstName","_getBindingNodeCreator","GetByRefSymbol","SetByRefSymbol","SetCacheableSymbol","ConnectedCallbackSymbol","DisconnectedCallbackSymbol","StructuredPathInfo","static","pathSegments","lastSegment","cumulativePaths","cumulativePathSet","cumulativeInfos","cumulativeInfoSet","wildcardPaths","wildcardPathSet","wildcardInfos","indexByWildcardPath","wildcardInfoSet","wildcardParentPaths","wildcardParentPathSet","wildcardParentInfos","wildcardParentInfoSet","lastWildcardPath","lastWildcardInfo","parentPath","parentInfo","wildcardCount","children","getPattern","_pattern","getStructuredPathInfo","currentPatternPath","prevPatternPath","reservedWords","structuredPath","has","BindingState","listIndexRef","deref","find","saveBinding","writeState","BindingStateIndex","indexNumber","loopContexts","bindingsByListIndex","ereg","getBindingStateCreator","createBindingStateIndex","createBindingState","nodeTypeByNodeKey","getNodeType","nodeKey","createNodeKey","getNodeTypeByNode","s","re","decode","m","exec","decodeURIComponent","parseFilter","parseProperty","property","parseExpressions","expression","bindExpression","decoratesExpression","nodePropertyText","statePropertyText","nodeProperty","inputFilterTexts","stateProperty","outputFilterTexts","parseExpression","removeAttributeFromElement","removeAttribute","removeAttributeByNodeType","replaceTextNodeFn","textNode","createTextNode","replaceChild","DataBindAttributes","nodePath","bindTexts","creatorByText","getTemplateById","getDataBindText","removeDataBindAttribute","replaceTextNodeFromComment","routeIndexes","getAbsoluteNodePath","parseBindText","bindText","creator","createBindingNode","getNodesHavingDataBind","root","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","SHOW_COMMENT","acceptNode","hasAttribute","FILTER_ACCEPT","FILTER_SKIP","isCommentNode","nextNode","currentNode","listDataBindAttributesById","listPathsSetById","pathsSetById","getDataBindAttributesFromTemplate","content","createDataBindAttributes","templateById","registerTemplate","template","rootId","Node","TEXT_NODE","nodeValue","dataBindAttributes","paths","listPaths","attribute","j","registerDataBindAttributes","Binding","bindingNode","version","inputFilters","readonlyState","outputFilters","updater","createBinding","LoopContext","WeakRef","parentLoopContext","currentBinding","parentBinding","walk","callback","results","unshift","bindingsWithSelectElement","createBindings","attributes","getDataBindAttributesById","reduce","BindContent","fragment","isMounted","lastBinding","size","at","importNode","createContent","createLoopContext","mount","mountBefore","beforeNode","insertBefore","afterNode","createDependencyKey","dependencyWalker","entryRef","traced","walkSub","edges","dependentTree","edge","overridedType","createDependencyWalker","ListIndex","parentListIndex","position","truncate","reverseIterator","iterator","atcache","next","lisIndex","createListIndex","listWalkerSub","listIndexLen","subListIndex","listWalker","createRefKey","BLANK_LISTINDEXES_SET","buildListIndexTree","newListIndexesSet","oldListIndexesSet","oldListIndexesByItem","groupBy","curListIndex","shift","addUpdatedListIndex","saveListIndexesSet","restructListIndexes","infos","updateValues","refKeys","L","elementInfoSet","dependentWalker","nowOnList","listInfoSet","ref","refInfo","wildcardMatchPaths","intersection","longestMatchAt","_info","_listIndex","existsBindingsByInfo","refKey","cacheListIndexSet","Updater","updatedProperties","updatedValues","addProcess","process","queueMicrotask","addUpdatedStatePropertyRefValue","entryRender","isEntryRender","_t","fe","arrayElementBindings","rebuild","arrayElementBinding","retArrayElementBindings","retBindings","updatedProiperties","clear","updatedRefs","arrayElementBindingByParentRefKey","item","parentRef","parentRefKey","builtStatePropertyRefKeySet","affectedRefs","getBindings","bindingInfo","Object","assign","entries","attachShadow","extends","canHaveShadowRoot","mode","adoptedStyleSheets","shadowRootOrDocument","ShadowRoot","getParentShadowRoot","styleSheets","buildListIndexTreeSub","listInfos","searchPath","subValue","ResolvedPathInfo","elements","wildcardType","wildcardIndexes","tmpPatternElements","incompleteCount","completeCount","lastPath","getResolvedPathInfo","getContextListIndex","structuredPathInfoStack","refIndex","listIndexStack","getListIndex","receiver","wildcardParentPattern","setStatePropertyRef","setTracking","lastTrackingStack","trackingStack","trackingIndex","trackedGetters","addDependentProp","getByRefReadonly","target","cacheable","owner","parentValue","_getByRef","resolveReadonly","prop","trackDependency","getReadonly","charCodeAt","d","resolve","wildcardPattern","walkWildcardPattern","wildardIndexPos","indexPos","parentIndexes","listIndexSet","concat","resultIndexes","resultValues","getAllReadonly","resolvedInfo","setCacheable","StateHandler$1","fill","trapGet","createReadonlyStateProxy","Proxy","StateHandler","getByRefWritable","setByRef","resolveWritable","getWritable","getAllWritable","call","trapSet","asyncSetStatePropertyRef","setLoopContext","ComponentEngine","stateClass","baseClass","structiveComponents","waitForInitialize","Promise","withResolvers","componentClass","checkDependentProp","listPath","setup","parentStructiveComponent","promise","dataset","json","parse","registerChildComponent","shadowRoot","unregisterChildComponent","saveInfoByListIndexByResolvedPathInfoId","saveInfoByStructuredPathId","createSaveInfo","list","getSaveInfoByStatePropertyRef","saveInfo","saveInfoByListIndex","dependents","createDependencyEdge","getPropertyValue","setPropertyValue","registerStrutiveComponent","component","unregisterStrutiveComponent","delete","MUSTACHE_REGEXP","MUSTACHE_TYPES","replaceTemplateTagWithComment","createComment","namespaceURI","newTemplate","childNode","querySelectorAll","registerHtml","html","stack","replaceAll","expr","remain","currentInfo","endTags","pop","lastInfo","replaceMustacheWithTemplateTag","ComponentState","bindingByName","names","bindParentProperty","propName","defineProperty","unbindParentProperty","bindParentComponent","parent","getBindingsFromChild","keys","unbindParentComponent","getPropertyValueFromChild","rootName","remainName","parentPropInfo","setPropertyValueFromChild","ComponentStateHandler","checkSegmentRegexp","checkPathRegexp","createAccessorFunctions","getters","matchPaths","len","matchPath","curPath","matchInfo","segments","count","segment","Function","createComponentClass","componentData","componentConfig","userConfig","be","getComponentConfig","$config","cn","an","Re","$isStructive","registerStateClass","extendTagName","getBaseClass","componentState","createComponentEngine","el","current","isStructive","host","findStructiveParent","define","customElements","getStyleSheetById","getStateClassById","getListPathsSetById","getPathsSetById","currentProto","prototype","getOwnPropertyDescriptors","desc","getPrototypeOf","funcs","enumerable","configurable","unescapeEmbed","loadSingleFileComponent","response","fetch","escapeEmbed","querySelector","script","b64","btoa","fromCodePoint","TextEncoder","encode","scriptModule","import","default","createSingleFileComponent","registerComponentClass","SLOT_KEY","DEFAULT_LAYOUT","MainWrapper","loadLayout","ok","layoutText","workTemplate","createDocumentFragment","router","ROUTES_KEY","COMPONENTS_KEY","loadFromImportMap","importmap","scriptImportmap","imports","loadImportmap","alias","_config","initialized","defineComponents","singleFileComponents","registerSingleFileComponents","bootstrapStructive","mainWrapper","body","bootstrap"],"mappings":"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"}