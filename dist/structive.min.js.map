{"version":3,"file":"structive.min.js","sources":["../src/Router/Router.ts","../src/WebComponents/getGlobalConfig.ts","../src/Filter/errorMessages.ts","../src/Filter/builtinFilters.ts","../src/GlobalId/generateId.ts","../src/utils.ts","../src/StateClass/registerStateClass.ts","../src/StyleSheet/registerStyleSheet.ts","../src/StyleSheet/regsiterCss.ts","../src/BindingBuilder/createFilters.ts","../src/DataBinding/BindingNode/BindingNode.ts","../src/DataBinding/BindingNode/BindingNodeAttribute.ts","../src/DataBinding/BindingNode/BindingNodeCheckbox.ts","../src/DataBinding/BindingNode/BindingNodeClassList.ts","../src/DataBinding/BindingNode/BindingNodeClassName.ts","../src/DataBinding/BindingNode/BindingNodeEvent.ts","../src/constants.ts","../src/DataBinding/BindingNode/BindingNodeBlock.ts","../src/DataBinding/BindingNode/BindingNodeIf.ts","../src/DataBinding/BindingNode/BindingNodeFor.ts","../src/BindingBuilder/getDefaultName.ts","../src/DataBinding/BindingNode/BindingNodeProperty.ts","../src/DataBinding/BindingNode/BindingNodeRadio.ts","../src/DataBinding/BindingNode/BindingNodeStyle.ts","../src/ComponentState/symbols.ts","../src/DataBinding/BindingNode/BindingNodeComponent.ts","../src/BindingBuilder/getBindingNodeCreator.ts","../src/StateClass/symbols.ts","../src/StateProperty/getStructuredPathInfo.ts","../src/DataBinding/BindingState/BindingState.ts","../src/DataBinding/BindingState/BindingStateIndex.ts","../src/BindingBuilder/getBindingStateCreator.ts","../src/BindingBuilder/getDataBindText.ts","../src/BindingBuilder/getNodeType.ts","../src/BindingBuilder/parseBindText.ts","../src/BindingBuilder/removeDataBindAttribute.ts","../src/BindingBuilder/replaceTextNodeFromComment.ts","../src/BindingBuilder/createDataBindAttributes.ts","../src/BindingBuilder/getAbsoluteNodePath.ts","../src/BindingBuilder/getNodesHavingDataBind.ts","../src/BindingBuilder/registerDataBindAttributes.ts","../src/Template/registerTemplate.ts","../src/Template/removeEmptyTextNodes.ts","../src/DataBinding/Binding.ts","../src/LoopContext/createLoopContext.ts","../src/Render/render.ts","../src/DataBinding/BindContent.ts","../src/BindingBuilder/resolveNodeFromPath.ts","../src/ListIndex/createListIndex.ts","../src/StatePropertyRef/getStatePropertyRefId.ts","../src/StateClass/methods/getByRef.ts","../src/StateClass/methods/setTracking.ts","../src/StateClass/apis/getByRef.ts","../src/StateClass/methods/setByRef.ts","../src/StateClass/apis/setByRef.ts","../src/StateClass/apis/setCacheable.ts","../src/StateClass/methods/setCacheable.ts","../src/StateClass/apis/connectedCallback.ts","../src/StateClass/apis/disconnectedCallback.ts","../src/StateClass/apis/resolve.ts","../src/StateClass/apis/getAll.ts","../src/StateProperty/getResolvedPathInfo.ts","../src/StateClass/getListIndex.ts","../src/StateClass/traps/get.ts","../src/StateClass/createStateProxy.ts","../src/StateClass/traps/set.ts","../src/StateClass/buildListIndexTree.ts","../src/Updater/collectAffectedGetters.ts","../src/Updater/updater.ts","../src/ComponentEngine/attachShadow.ts","../src/ComponentEngine/canHaveShadowRoot.ts","../src/ComponentEngine/ComponentEngine.ts","../src/Template/replaceMustacheWithTemplateTag.ts","../src/Template/replaceTemplateTagWithComment.ts","../src/Template/registerHtml.ts","../src/ComponentState/createComponentState.ts","../src/WebComponents/createComponentClass.ts","../src/WebComponents/getComponentConfig.ts","../src/WebComponents/getBaseClass.ts","../src/WebComponents/createSingleFileComponent.ts","../src/WebComponents/loadSingleFileComponent.ts","../src/WebComponents/registerComponentClass.ts","../src/MainWrapper/MainWrapper.ts","../src/WebComponents/loadFromImportMap.ts","../src/WebComponents/loadImportmap.ts","../src/exports.ts","../src/WebComponents/registerSingleFIleComponents.ts","../src/bootstrap.ts"],"sourcesContent":["const DEFAULT_ROUTE_PATH = '/'; // Default route path\r\nconst ROUTE_PATH_PREFIX = 'routes:'; // Prefix for route paths\r\n/**\r\n * example:\r\n * ```ts\r\n * entryRoute('my-view', '/my-view/:id');\r\n */\r\nconst routeMap: Record<string,string> = {};\r\n\r\nexport class Router extends HTMLElement {\r\n  _popstateHandler: (event: PopStateEvent) => void;\r\n  constructor() {\r\n    super();\r\n    this._popstateHandler = this.popstateHandler.bind(this);\r\n  }\r\n\r\n  connectedCallback() {\r\n    this.innerHTML = '<slot name=\"content\"></slot>';\r\n    window.addEventListener('popstate', this._popstateHandler);\r\n    window.dispatchEvent(new Event(\"popstate\")); // Dispatch popstate event to trigger the initial render\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    window.removeEventListener('popstate', this._popstateHandler);\r\n  }\r\n\r\n  popstateHandler(event: PopStateEvent) {\r\n    this.render();\r\n  }\r\n\r\n  render() {\r\n    const routePath = window.location.pathname || DEFAULT_ROUTE_PATH;\r\n    let tagName: string | undefined = undefined;\r\n    let params: Record<string, string> = {};\r\n    // Check if the routePath matches any of the defined routes\r\n    for (const [path, tag] of Object.entries(routeMap)) {\r\n      const regex = new RegExp(path.replace(/:[^\\s/]+/g, '([^/]+)'));\r\n      if (regex.test(routePath)) {\r\n        tagName = tag;\r\n        // Extract the parameters from the routePath\r\n        const matches = routePath.match(regex);\r\n        if (matches) {\r\n          const keys = path.match(/:[^\\s/]+/g) || [];\r\n          keys.forEach((key, index) => {\r\n            params[key.substring(1)] = matches[index + 1]; // +1 to skip the full match\r\n          });\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    if (tagName) {\r\n      // If a route matches, create the custom element and set its state\r\n      // Create the custom element with the tag name\r\n      // project the custom element into the router slot\r\n      const customElement = document.createElement(tagName) as HTMLElement;\r\n      customElement.setAttribute('state', JSON.stringify(params));\r\n      customElement.setAttribute('slot', 'content');\r\n      this.appendChild(customElement);\r\n    } else {\r\n      // If no route matches, show 404 content\r\n      const messageElement = document.createElement('h1') as HTMLElement;\r\n      messageElement.setAttribute('slot', 'content');\r\n      messageElement.textContent = '404 Not Found';\r\n      this.appendChild(messageElement);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport function entryRoute(tagName: string, routePath: string): void {\r\n  if (routePath.startsWith(ROUTE_PATH_PREFIX)) {\r\n    routePath = routePath.substring(ROUTE_PATH_PREFIX.length); // Remove 'routes:' prefix\r\n  } \r\n  routeMap[routePath] = tagName;\r\n}\r\n\r\n\r\n","import { IConfig } from \"./types\";\r\n\r\nconst globalConfig: IConfig = {\r\n  debug                : false,\r\n  locale               : \"en-US\", // The locale of the component, ex. \"en-US\", default is \"en-US\"\r\n  enableShadowDom      : true,\r\n  enableMainWrapper    : true, // Whether to use the main wrapper or not\r\n  enableRouter         : true, // Whether to use the router or not\r\n  autoInsertMainWrapper: false, // Whether to automatically insert the main wrapper or not\r\n  autoInit             : true, // Whether to automatically initialize the component or not\r\n  mainTagName          : \"app-main\", // The tag name of the main wrapper, default is \"app-main\"\r\n  routerTagName        : \"view-router\", // The tag name of the router, default is \"view-router\"\r\n  layoutPath           : \"\", // The path to the layout file, default is \"\"\r\n  autoLoadFromImportMap: false, // Whether to automatically load the component from the import map or not\r\n};\r\n\r\nexport function getGlobalConfig():IConfig {\r\n  return globalConfig;\r\n}\r\n\r\nexport const config = getGlobalConfig();\r\n","\r\nexport function optionsRequired(fnName:string): never {\r\n  throw new Error(`${fnName} requires at least one option`);\r\n}\r\n\r\nexport function optionMustBeNumber(fnName:string): never {\r\n  throw new Error(`${fnName} requires a number as option`);\r\n}\r\n\r\nexport function valueMustBeNumber(fnName:string): never {\r\n  throw new Error(`${fnName} requires a number value`);\r\n}\r\n\r\nexport function valueMustBeBoolean(fnName:string): never {\r\n  throw new Error(`${fnName} requires a boolean value`);\r\n}\r\n\r\nexport function valueMustBeDate(fnName:string): never {\r\n  throw new Error(`${fnName} requires a date value`);\r\n}","import { getGlobalConfig } from \"../WebComponents/getGlobalConfig.js\";\r\nimport { optionMustBeNumber, optionsRequired, valueMustBeBoolean, valueMustBeDate, valueMustBeNumber } from \"./errorMessages.js\";\r\nimport { FilterWithOptions } from \"./types\";\r\n\r\nconst config = getGlobalConfig();\r\n\r\nconst eq = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('eq');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('eq');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('eq');\r\n    return value === optValue;\r\n  }\r\n}\r\n\r\nconst ne = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('ne');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('ne');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ne');\r\n    return value !== optValue;\r\n  }\r\n}\r\n\r\nconst not = (options?:string[]) => {\r\n  return (value: any) => {\r\n    if (typeof value !== 'boolean') valueMustBeBoolean('not');\r\n    return !value;\r\n  }\r\n}\r\n\r\nconst lt = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('lt');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('lt');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('lt');\r\n    return value < optValue;\r\n  }\r\n}\r\n\r\nconst le = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('le');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('le');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('le');\r\n    return value <= optValue;\r\n  }\r\n}\r\n\r\nconst gt = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('gt');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('gt');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('gt');\r\n    return value > optValue;\r\n  }\r\n}\r\n\r\nconst ge = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('ge');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('ge');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ge');\r\n    return value >= optValue;\r\n  }\r\n}\r\n\r\nconst inc = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('inc');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('inc');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('inc');\r\n    return value + optValue;\r\n  }\r\n}\r\n\r\nconst dec = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('dec');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('dec');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('dec');\r\n    return value - optValue;\r\n  }\r\n}\r\n\r\nconst mul = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('mul');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('mul');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('mul');\r\n    return value * optValue;\r\n  }\r\n}\r\n\r\nconst div = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('div');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('div');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('div');\r\n    return value / optValue;\r\n  }\r\n}\r\n\r\nconst fix = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('div');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('div');\r\n    return value.toFixed(optValue);\r\n  }\r\n}\r\n\r\nconst locale = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('locale');\r\n    return value.toLocaleString(opt);\r\n  }\r\n}\r\n\r\nconst uc = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().toUpperCase();\r\n  }\r\n}\r\n\r\nconst lc = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().toLowerCase();\r\n  }\r\n}\r\n\r\nconst cap = (options?:string[]) => {\r\n  return (value: any) => {\r\n    const v = value.toString();\r\n    if (v.length === 0) return v;\r\n    if (v.length === 1) return v.toUpperCase();\r\n    return v.charAt(0).toUpperCase() + v.slice(1);\r\n  }\r\n}\r\n\r\nconst trim = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().trim();\r\n  }\r\n}\r\n\r\nconst slice = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('slice');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('slice');\r\n  return (value: any) => {\r\n    return value.toString().slice(optValue);\r\n  }\r\n}\r\n\r\nconst substr = (options?:string[]) => {\r\n  const opt1 = options?.[0] ?? optionsRequired('substr');\r\n  const opt1Value = Number(opt1);\r\n  if (isNaN(opt1Value)) optionMustBeNumber('substr');\r\n  const opt2 = options?.[1] ?? optionsRequired('substr');\r\n  const opt2Value = Number(opt2);\r\n  if (isNaN(opt2Value)) optionMustBeNumber('substr');\r\n  return (value: any) => {\r\n    return value.toString().substr(opt1Value, opt2Value);\r\n  }\r\n}\r\n\r\nconst pad = (options?:string[]) => {\r\n  const opt1 = options?.[0] ?? optionsRequired('pad');\r\n  const opt1Value = Number(opt1);\r\n  if (isNaN(opt1Value)) optionMustBeNumber('pad');\r\n  const opt2 = options?.[1] ?? '0';\r\n  const opt2Value = opt2;\r\n  return (value: any) => {\r\n    return value.toString().padStart(opt1Value, opt2Value);\r\n  }\r\n}\r\n\r\nconst rep = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('rep');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('rep');\r\n  return (value: any) => {\r\n    return value.toString().repeat(optValue);\r\n  }\r\n}\r\n\r\nconst rev = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().split('').reverse().join('');\r\n  }\r\n}\r\n\r\nconst int = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return parseInt(value, 10);\r\n  }\r\n}\r\n\r\nconst float = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return parseFloat(value);\r\n  }\r\n}\r\n\r\nconst round = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('round');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('round');\r\n    return Math.round(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst floor = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('floor');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('floor');\r\n    return Math.floor(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst ceil = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('ceil');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ceil');\r\n    return Math.ceil(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst percent = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('percent');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('percent');\r\n    return value.toFixed(optValue) + '%';\r\n  }\r\n}\r\n\r\nconst date = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date))  valueMustBeDate('date');\r\n    return value.toLocaleDateString(config.locale);\r\n  }\r\n}\r\n\r\nconst time = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('time');\r\n    return value.toLocaleTimeString(config.locale);\r\n  }\r\n}\r\n\r\nconst datetime = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('datetime');\r\n    return value.toLocaleString(config.locale);\r\n  }\r\n}\r\n\r\nconst ymd = (options?:string[]) => {\r\n  const opt = options?.[0] ?? '-';\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('ymd');\r\n    const year = value.getFullYear().toString();\r\n    const month = (value.getMonth() + 1).toString().padStart(2, '0');\r\n    const day = value.getDate().toString().padStart(2, '0');\r\n    return `${year}${opt}${month}${opt}${day}`;\r\n  }\r\n}\r\n\r\nconst falsy = (options?:string[]) => {\r\n  return (value: any) => value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value);\r\n}\r\n\r\nconst truthy = (options?:string[]) => {\r\n  return (value: any) =>value !== false && value !== null && value !== undefined && value !== 0 && value !== '' && !Number.isNaN(value);\r\n}\r\n\r\nconst defaults = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('defaults');\r\n  return (value: any) => {\r\n    if (value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value)) return opt;\r\n    return value;\r\n  }\r\n}\r\n\r\nconst boolean = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return Boolean(value);\r\n  }\r\n}\r\n\r\nconst number = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return Number(value);\r\n  }\r\n}\r\n\r\nconst string = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return String(value);\r\n  }\r\n}\r\n\r\nconst _null = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return (value === \"\") ? null : value;\r\n  } \r\n}\r\n\r\nconst builtinFilters: FilterWithOptions = {\r\n  eq,\r\n  ne,\r\n  not,\r\n  \r\n  lt,\r\n  le,\r\n  gt,\r\n  ge,\r\n\r\n  inc,\r\n  dec,\r\n  mul,\r\n  div,\r\n\r\n  fix,\r\n  locale,\r\n  uc,\r\n  lc,\r\n  cap,\r\n  trim,\r\n  slice,\r\n  substr,\r\n  pad,\r\n  rep,\r\n  rev,\r\n\r\n  int,\r\n  float,\r\n  round,\r\n  floor,\r\n  ceil,\r\n  percent,\r\n\r\n  date,\r\n  time,\r\n  datetime,\r\n  ymd,\r\n\r\n  falsy,\r\n  truthy,\r\n  defaults,\r\n\r\n  boolean,\r\n  number,\r\n  string,\r\n  \"null\": _null,\r\n};\r\n\r\nexport const outputBuiltinFilters = builtinFilters;\r\nexport const inputBuiltinFilters = builtinFilters;\r\n\r\nexport const builtinFilterFn = (name:string, options: string[]) => (filters: FilterWithOptions) => {\r\n  const filter = filters[name];\r\n  if (!filter) throw new Error(`outputBuiltinFiltersFn: filter not found: ${name}`);\r\n  return filter(options);\r\n}\r\n\r\n","\r\nlet id = 0;\r\n\r\nexport function generateId(): number {\r\n  return ++id;\r\n}","\r\nexport function raiseError(message: string): never {\r\n  throw new Error(message);\r\n}\r\n","import { raiseError } from \"../utils.js\";\r\nimport { IStructiveState } from \"./types\";\r\n\r\nconst stateClassById: Record<number,IStructiveState> = {};\r\n\r\nexport function registerStateClass(id: number, stateClass: IStructiveState) {\r\n  stateClassById[id] = stateClass;\r\n}\r\n\r\nexport function getStateClassById(id: number): IStructiveState {\r\n  return stateClassById[id] ?? raiseError(`getStateClassById: stateClass not found: ${id}`);\r\n}\r\n","import { raiseError } from \"../utils.js\";\r\n\r\nconst styleSheetById: Record<number,CSSStyleSheet> = {};\r\n\r\nexport function registerStyleSheet(id: number, css: CSSStyleSheet) {\r\n  styleSheetById[id] = css;\r\n}\r\n\r\nexport function getStyleSheetById(id: number): CSSStyleSheet {\r\n  return styleSheetById[id] ?? raiseError(`getStyleSheetById: stylesheet not found: ${id}`);\r\n}","import { registerStyleSheet } from \"./registerStyleSheet.js\";\r\n\r\nexport function registerCss(id: number, css: string) {\r\n  const styleSheet = new CSSStyleSheet();\r\n  styleSheet.replaceSync(css);\r\n  registerStyleSheet(id, styleSheet);\r\n}","import { FilterFn, Filters, FilterWithOptions } from \"../Filter/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IFilterText } from \"./types\";\r\n\r\nfunction textToFilter(filters:FilterWithOptions, text: IFilterText): FilterFn {\r\n  const filter = filters[text.name];\r\n  if (!filter) raiseError(`outputBuiltinFiltersFn: filter not found: ${name}`);\r\n  return filter(text.options);\r\n}\r\n\r\nconst cache : Map<IFilterText[], Filters> = new Map();\r\n\r\nexport function createFilters(filters:FilterWithOptions, texts: IFilterText[]): Filters {\r\n  let result = cache.get(texts);\r\n  if (typeof result === \"undefined\") {\r\n    result = [];\r\n    for(let i = 0; i < texts.length; i++) {\r\n      result.push(textToFilter(filters, texts[i]));\r\n    }\r\n    cache.set(texts, result);\r\n  }\r\n  return result;\r\n}\r\n","import { Filters } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { IBindingNode } from \"./types\";\r\n\r\nexport class BindingNode implements IBindingNode {\r\n  #binding: IBinding;\r\n  #node: Node;\r\n  #name: string;\r\n  #filters: Filters;\r\n  #event: string | null;\r\n  #bindContents: Set<IBindContent> = new Set<IBindContent>();\r\n  get node(): Node {\r\n    return this.#node;\r\n  }\r\n  get name(): string {\r\n    return this.#name;\r\n  }\r\n  get subName(): string {\r\n    return this.#name;\r\n  }\r\n  get binding(): IBinding {\r\n    return this.#binding;\r\n  }\r\n  get event(): string | null {\r\n    return this.#event;\r\n  }\r\n  get filters(): Filters {\r\n    return this.#filters;\r\n  }\r\n  get bindContents(): Set<IBindContent> {\r\n    return this.#bindContents;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node  : Node, \r\n    name  : string,\r\n    filters: Filters,\r\n    event : string | null\r\n  ) {\r\n    this.#binding = binding;\r\n    this.#node = node;\r\n    this.#name = name;\r\n    this.#filters = filters;\r\n    this.#event = event;\r\n  }\r\n  init():void {\r\n  }\r\n  update(): void {\r\n    this.assignValue(this.binding.bindingState.filteredValue);\r\n  }\r\n  assignValue(value: any): void {\r\n    raiseError(`BindingNode: assignValue not implemented`);\r\n  }\r\n  updateElements(listIndexes: IListIndex[], values: any[]) {\r\n    raiseError(`BindingNode: updateElements not implemented`);\r\n  }\r\n  get isSelectElement(): boolean {\r\n    return this.node instanceof HTMLSelectElement;\r\n  }\r\n  get value():any {\r\n    return null;\r\n  }\r\n  get filteredValue():any {\r\n    return null;\r\n  }\r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeAttribute extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as Element;\r\n    element.setAttribute(this.subName, value.toString());\r\n  }\r\n}\r\n\r\nexport const createBindingNodeAttribute: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeAttribute(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeCheckbox extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError(`BindingNodeCheckbox.update: value is not array`, );\r\n    }\r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value.map(_val => _val.toString()).includes(element.value);\r\n  }\r\n}\r\n\r\nexport const createBindingNodeCheckbox: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeCheckbox(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeClassList extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError(`BindingNodeClassList.update: value is not array`);\r\n    }\r\n    const element = this.node as Element;\r\n    element.className = value.join(\" \");\r\n  }\r\n}\r\n\r\nexport const createBindingNodeClassList: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeClassList(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeClassName extends BindingNode {\r\n  #subName: string;\r\n  get subName(): string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (typeof value !== \"boolean\") {\r\n      raiseError(`BindingNodeClassName.update: value is not boolean`);\r\n    }\r\n    const element = this.node as Element;\r\n    if (value) {\r\n      element.classList.add(this.subName);\r\n    } else {\r\n      element.classList.remove(this.subName);\r\n    }\r\n  }\r\n}\r\n\r\nexport const createBindingNodeClassName: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeClassName(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeEvent extends BindingNode {\r\n  #subName    : string;\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    this.#subName = this.name.slice(2); // on～\r\n    const element = node as HTMLElement;\r\n    element.addEventListener(this.subName, (e:Event) => this.handler(e));\r\n  }\r\n  get subName(): string {\r\n    return this.#subName;\r\n  }\r\n  update() {\r\n    // 何もしない\r\n  }\r\n\r\n  handler(e: Event) {\r\n    const bindingState = this.binding.bindingState;\r\n    const engine = this.binding.engine;\r\n    const stateProxy = engine.stateProxy;\r\n    const updater = engine.updater;\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n    const indexes = loopContext?.serialize().map((context) => context.listIndex.index) ?? [];\r\n    const option = this.event;\r\n    if (option === \"preventDefault\") {\r\n      e.preventDefault();\r\n    }\r\n    this.binding.engine.updater.addProcess(async () => {\r\n      const value = bindingState.value;\r\n      const typeOfValue = typeof value;\r\n      updater.addProcess(async () => {\r\n        if (loopContext) {\r\n          await engine.setLoopContext(loopContext, async () => {\r\n            if (typeOfValue === \"function\") {\r\n              await Reflect.apply(value, stateProxy, [e, ...indexes]);\r\n            } else {\r\n              // ToDo:error\r\n            }\r\n          });\r\n        } else {\r\n          if (typeOfValue === \"function\") {\r\n            await Reflect.apply(value, stateProxy, [e, ...indexes]);\r\n          } else {\r\n            // ToDo:error\r\n          }\r\n        }\r\n      });\r\n    });\r\n  } \r\n}\r\n\r\nexport const createBindingNodeEvent: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeEvent(binding, node, name, filterFns, event);\r\n  }\r\n","export const DATA_BIND_ATTRIBUTE = \"data-bind\";\r\nexport const COMMENT_EMBED_MARK = \"@@:\"; // 埋め込み変数のマーク\r\nexport const COMMENT_TEMPLATE_MARK = \"@@|\"; // テンプレートのマーク\r\n","import { COMMENT_TEMPLATE_MARK } from \"../../constants.js\";\r\nimport { Filters } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\n\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\nexport class BindingNodeBlock extends BindingNode {\r\n  #id: number;\r\n  get id(): number {\r\n    return this.#id;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    const id = this.node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN) ?? raiseError(\"BindingNodeBlock.id: invalid node\");\r\n    this.#id = Number(id);\r\n  }\r\n    \r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindContent } from \"../BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeIf extends BindingNodeBlock {\r\n  #bindContent: IBindContent;\r\n  #trueBindContents: Set<IBindContent>;\r\n  #falseBindContents: Set<IBindContent> = new Set();\r\n  #bindContents: Set<IBindContent>;\r\n\r\n  get bindContents(): Set<IBindContent> {\r\n    return this.#bindContents;\r\n  }\r\n\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    this.#bindContent = createBindContent(\r\n      this.binding, \r\n      this.id, \r\n      this.binding.engine, \r\n      \"\", \r\n      null\r\n    );\r\n    this.#trueBindContents = this.#bindContents = new Set([this.#bindContent]);\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (typeof value !== \"boolean\") {\r\n      raiseError(`BindingNodeIf.update: value is not boolean`);\r\n    }\r\n    const parentNode = this.node.parentNode;\r\n    if (parentNode == null) {\r\n      raiseError(`BindingNodeIf.update: parentNode is null`);\r\n    }\r\n    if (value) {\r\n      this.#bindContent.render();\r\n      this.#bindContent.mountBefore(parentNode, this.node.nextSibling);\r\n      this.#bindContents = this.#trueBindContents;\r\n    } else {\r\n      this.#bindContent.unmount();\r\n      this.#bindContents = this.#falseBindContents;\r\n    }\r\n  }\r\n}\r\n\r\nexport const createBindingNodeIf: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeIf(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindContent } from \"../BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeFor extends BindingNodeBlock {\r\n  #bindContentsSet       : Set<IBindContent> = new Set<IBindContent>();\r\n  #bindContentByListIndex: WeakMap<IListIndex, IBindContent> = new WeakMap();\r\n  #bindContentPool       : IBindContent[] = [];\r\n  #bindContentLastIndex  : number = 0;\r\n\r\n  get bindContents(): Set<IBindContent> {\r\n    return this.#bindContentsSet;\r\n  }\r\n\r\n  init() {\r\n  }\r\n\r\n  createBindContent(listIndex: IListIndex): IBindContent {\r\n    let bindContent: IBindContent;\r\n    if (this.#bindContentLastIndex >= 0) {\r\n      // プールの最後の要素を取得して、プールの長さをあとで縮減する\r\n      // 作るたびにプールを縮減すると、パフォーマンスが悪化するため\r\n      // プールの長さを縮減するのは、全ての要素を作った後に行う\r\n      bindContent = this.#bindContentPool[this.#bindContentLastIndex];\r\n      this.#bindContentLastIndex--;\r\n      bindContent.assignListIndex(listIndex);\r\n    } else {\r\n      bindContent = createBindContent(\r\n        this.binding, \r\n        this.id, \r\n        this.binding.engine, \r\n        this.binding.bindingState.pattern + \".*\", \r\n        listIndex);\r\n    }\r\n    // 登録\r\n    this.#bindContentByListIndex.set(listIndex, bindContent);\r\n    return bindContent;\r\n  }\r\n\r\n  deleteBindContent(bindContent: IBindContent): void {\r\n    bindContent.unmount();\r\n    bindContent.loopContext?.clearListIndex();\r\n  }\r\n\r\n  get bindContentLastIndex():number {\r\n    return this.#bindContentLastIndex;\r\n  }\r\n  set bindContentLastIndex(value:number) {\r\n    this.#bindContentLastIndex = value;\r\n  }\r\n\r\n  get poolLength():number {\r\n    return this.#bindContentPool.length;\r\n  }\r\n  set poolLength(length: number) {\r\n    if (length < 0) {\r\n      raiseError(`BindingNodeFor.setPoolLength: length is negative`);\r\n    }\r\n    this.#bindContentPool.length = length;\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError(`BindingNodeFor.assignValue: value is not array`);\r\n    }\r\n    const listIndexesSet = this.binding.engine.getListIndexesSet(\r\n      this.binding.bindingState.info, \r\n      this.binding.bindingState.listIndex\r\n    );\r\n    if (listIndexesSet === null) {\r\n      raiseError(`BindingNodeFor.assignValue: listIndexes is not found`);\r\n    }\r\n    this.bindContentLastIndex = this.poolLength - 1;\r\n    const newBindContensSet = new Set<IBindContent>();\r\n    let lastBindContent = null;\r\n    const parentNode = this.node.parentNode;\r\n    if (parentNode == null) {\r\n      raiseError(`BindingNodeFor.update: parentNode is null`);\r\n    }\r\n    for(const listIndex of listIndexesSet) {\r\n      const lastNode = lastBindContent?.getLastNode(parentNode) ?? this.node;\r\n      let bindContent = this.#bindContentByListIndex.get(listIndex);\r\n      if (typeof bindContent === \"undefined\") {\r\n        bindContent = this.createBindContent(listIndex);\r\n        bindContent.render();\r\n        bindContent.mountAfter(parentNode, lastNode);\r\n      } else {\r\n        if (lastNode.nextSibling !== bindContent.firstChildNode) {\r\n          bindContent.mountAfter(parentNode, lastNode);\r\n        }\r\n      }\r\n      newBindContensSet.add(bindContent);\r\n      lastBindContent = bindContent;\r\n    }\r\n    // プールの長さを更新する\r\n    // プールの長さは、プールの最後の要素のインデックス+1であるため、\r\n    this.poolLength = this.bindContentLastIndex + 1;\r\n    // 削除\r\n    const removeBindContentsSet = this.#bindContentsSet.difference(newBindContensSet);\r\n    for(const bindContent of removeBindContentsSet) {\r\n      this.deleteBindContent(bindContent);\r\n    }\r\n    this.#bindContentPool.push(...removeBindContentsSet);\r\n    this.#bindContentsSet = newBindContensSet;\r\n  }\r\n\r\n  /**\r\n   * SWAP処理を想定\r\n   * \r\n   * @param listIndexes \r\n   * @param values \r\n   * @returns \r\n   */\r\n  updateElements(listIndexes: IListIndex[], values: any[]) {\r\n    if (typeof values[0] !== \"object\") return;\r\n    const engine = this.binding.engine;\r\n    const oldListValues = \r\n      engine.getList(\r\n        this.binding.bindingState.info, \r\n        this.binding.bindingState.listIndex\r\n      ) ?? raiseError(`BindingNodeFor.updateElements: oldValues is not found`); \r\n    const parentNode = this.node.parentNode ?? raiseError(`BindingNodeFor.update: parentNode is null`);\r\n\r\n    // DOMから削除\r\n    const currentBindContents = Array.from(this.#bindContentsSet);\r\n    const targetBindContents: IBindContent[] = [];\r\n    for(let i = 0; i < listIndexes.length; i++) {\r\n      const listIndex = listIndexes[i];\r\n      const bindContent = currentBindContents[listIndex.index];\r\n      bindContent.unmount();\r\n      targetBindContents.push(bindContent);\r\n    }\r\n\r\n    // DOMに追加、listIndexを更新\r\n    for(let i = 0; i < listIndexes.length; i++) {\r\n      const listIndex = listIndexes[i];\r\n      const index = listIndex.index;\r\n\r\n      const lastBindContent = currentBindContents[index - 1] ?? null;\r\n      const lastNode = lastBindContent?.lastChildNode ?? this.node;\r\n\r\n      const oldValue = oldListValues[index];\r\n      const targetIndex = values.indexOf(oldValue);\r\n      const prevBindContent = targetBindContents[targetIndex];\r\n\r\n      if (typeof prevBindContent === \"undefined\") {\r\n        // 入れ替えるBindContentがない場合は再描画\r\n        const bindContent = targetBindContents[index];\r\n        bindContent.render();\r\n        bindContent.mountAfter(parentNode, lastNode);\r\n      } else {\r\n        prevBindContent.assignListIndex(listIndex);\r\n        prevBindContent.mountAfter(parentNode, lastNode);\r\n        this.#bindContentByListIndex.set(listIndex, prevBindContent);\r\n        currentBindContents[index] = prevBindContent;\r\n      }\r\n      if (targetIndex >= 0) {\r\n        values[targetIndex] = -1;\r\n      }\r\n    }\r\n    this.#bindContentsSet = new Set<IBindContent>(currentBindContents);\r\n    engine.saveList(\r\n      this.binding.bindingState.info, \r\n      this.binding.bindingState.listIndex, \r\n      this.binding.bindingState.value.slice(0)\r\n    );\r\n  }\r\n}\r\n\r\nexport const createBindingNodeFor: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeFor(binding, node, name, filterFns, event);\r\n  }\r\n","import { NodeType } from \"./types\";\r\n\r\nconst DEFAULT_PROPERTY = \"textContent\";\r\n\r\ntype DefaultPropertyByElementType = {\r\n  [key:string]: string;\r\n}\r\n\r\nconst defaultPropertyByElementType:DefaultPropertyByElementType = {\r\n  \"radio\"   : \"checked\",\r\n  \"checkbox\": \"checked\",\r\n  \"button\"  : \"onclick\",\r\n}\r\n\r\n/**\r\n * HTML要素のデフォルトプロパティを取得\r\n */\r\nconst getDefaultPropertyHTMLElement = (node:Node):string => \r\n  node instanceof HTMLSelectElement || node instanceof HTMLTextAreaElement || node instanceof HTMLOptionElement ? \"value\" : \r\n  node instanceof HTMLButtonElement ? \"onclick\" : \r\n  node instanceof HTMLAnchorElement ? \"onclick\" : \r\n  node instanceof HTMLFormElement ? \"onsubmit\" : \r\n  node instanceof HTMLInputElement ? (defaultPropertyByElementType[node.type] ?? \"value\") :\r\n  DEFAULT_PROPERTY;\r\n\r\ntype DefaultPropertyByKey = {\r\n  [key:string]: string | undefined;\r\n}\r\n\r\nconst _cache: DefaultPropertyByKey = {};\r\n\r\nconst textContentProperty = (node:Node):string => DEFAULT_PROPERTY;\r\n\r\ntype GetDefaultPropertyByNodeType = {\r\n  [key in NodeType]: ((node:Node)=>string) | undefined;\r\n}\r\n\r\nconst getDefaultPropertyByNodeType: GetDefaultPropertyByNodeType = {\r\n  HTMLElement: getDefaultPropertyHTMLElement,\r\n  SVGElement : undefined,\r\n  Text       : textContentProperty,\r\n  Template   : undefined,\r\n}\r\n\r\n/**\r\n * バインド情報でノードプロパティを省略された場合のデフォルトのプロパティ名を取得\r\n * @param node ノード\r\n * @param nodeType ノードタイプ\r\n * @returns {string | undefined} デフォルトのプロパティ名\r\n */\r\nexport function getDefaultName(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n): string | undefined {\r\n  const key = node.constructor.name + \"\\t\" + ((node as HTMLInputElement).type ?? \"\"); // type attribute\r\n  return _cache[key] ?? (_cache[key] = getDefaultPropertyByNodeType[nodeType]?.(node));\r\n}\r\n  ","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { getDefaultName } from \"../../BindingBuilder/getDefaultName.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nfunction isTwoWayBindable(element: HTMLElement): boolean {\r\n  return element instanceof HTMLInputElement || \r\n    element instanceof HTMLTextAreaElement || \r\n    element instanceof HTMLSelectElement;\r\n}\r\n\r\nconst defaultEventByName: {[key:string]: string} = {\r\n  \"value\"   : \"input\",\r\n  \"checked\" : \"change\",\r\n  \"selected\": \"change\",\r\n};\r\n\r\nclass BindingNodeProperty extends BindingNode {\r\n  get value(): any {\r\n    // @ts-ignore\r\n    return this.node[this.name];\r\n  }\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for(let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n\r\n    const isElement = this.node instanceof HTMLElement;\r\n    if (!isElement) return;\r\n    if (!isTwoWayBindable(this.node)) return;\r\n    const defaultName = getDefaultName(this.node, \"HTMLElement\");\r\n    if (defaultName !== this.name) return;\r\n    const eventName = this.event ?? defaultEventByName[this.name] ?? \"readonly\";\r\n    if (event === \"readonly\" || event === \"ro\") return;\r\n    this.node.addEventListener(eventName, () => {\r\n      this.binding.updateStateValue(this.filteredValue);\r\n    });\r\n\r\n  }\r\n\r\n  init() {\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    // @ts-ignore\r\n    this.node[this.name] = value;\r\n  }\r\n}\r\n\r\nexport const createBindingNodeProperty: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeProperty(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeRadio extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value.toString() === element.value.toString();\r\n  }\r\n}\r\n\r\nexport const createBindingNodeRadio: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeRadio(binding, node, name, filterFns, event);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeStyle extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as HTMLElement;\r\n    element.style.setProperty(this.subName, value.toString());\r\n  }\r\n}\r\n\r\nexport const createBindingNodeStyle: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeStyle(binding, node, name, filterFns, event);\r\n  }\r\n","\r\nconst symbolName = \"componentState\";\r\n\r\nexport const RenderSymbol : unique symbol = Symbol.for(`${symbolName}.render`);\r\nexport const BindParentComponentSymbol : unique symbol = Symbol.for(`${symbolName}.bindParentComponent`);\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { RenderSymbol } from \"../../ComponentState/symbols.js\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { StructiveComponent } from \"../../WebComponents/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nclass BindingNodeComponent extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    node   : Node, \r\n    name   : string,\r\n    filters: Filters,\r\n    event  : string | null\r\n  ) {\r\n    super(binding, node, name, filters, event);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n\r\n  init(): void {\r\n    const engine = this.binding.engine;\r\n    let bindings = engine.bindingsByComponent.get(this.node as StructiveComponent);\r\n    if (typeof bindings === \"undefined\") {\r\n      bindings = new Set<IBinding>();\r\n      engine.bindingsByComponent.set(this.node as StructiveComponent, bindings);\r\n    }\r\n    bindings.add(this.binding);\r\n  }\r\n\r\n  assignValue(value: any): void {\r\n    const component = this.node as StructiveComponent;\r\n    component.state[RenderSymbol](this.subName, value);\r\n  }\r\n\r\n}\r\n\r\nexport const createBindingNodeComponent: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], event: string | null) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeComponent(binding, node, name, filterFns, event);\r\n  }\r\n","import { createBindingNodeAttribute } from \"../DataBinding/BindingNode/BindingNodeAttribute.js\";\r\nimport { createBindingNodeCheckbox } from \"../DataBinding/BindingNode/BindingNodeCheckbox.js\";\r\nimport { createBindingNodeClassList } from \"../DataBinding/BindingNode/BindingNodeClassList.js\";\r\nimport { createBindingNodeClassName } from \"../DataBinding/BindingNode/BindingNodeClassName.js\";\r\nimport { createBindingNodeEvent } from \"../DataBinding/BindingNode/BindingNodeEvent.js\";\r\nimport { createBindingNodeIf } from \"../DataBinding/BindingNode/BindingNodeIf.js\";\r\nimport { createBindingNodeFor } from \"../DataBinding/BindingNode/BindingNodeFor.js\";\r\nimport { createBindingNodeProperty } from \"../DataBinding/BindingNode/BindingNodeProperty.js\";\r\nimport { createBindingNodeRadio } from \"../DataBinding/BindingNode/BindingNodeRadio.js\";\r\nimport { createBindingNodeStyle } from \"../DataBinding/BindingNode/BindingNodeStyle.js\";\r\nimport { CreateBindingNodeByNodeFn, CreateBindingNodeFn } from \"../DataBinding/BindingNode/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IFilterText } from \"./types\";\r\nimport { createBindingNodeComponent } from \"../DataBinding/BindingNode/BindingNodeComponent.js\";\r\n\r\ntype NodePropertyConstructorByName = {[key:string]:CreateBindingNodeFn};\r\ntype NodePropertyConstructorByNameByIsComment = {[key:number]:NodePropertyConstructorByName};\r\n\r\nconst nodePropertyConstructorByNameByIsComment:NodePropertyConstructorByNameByIsComment = {\r\n  0: {\r\n    \"class\"   : createBindingNodeClassList,\r\n    \"checkbox\": createBindingNodeCheckbox,\r\n    \"radio\"   : createBindingNodeRadio,\r\n  },\r\n  1: {\r\n    \"if\" : createBindingNodeIf,\r\n  },\r\n};\r\n\r\ntype NodePropertyConstructorByFirstName = {[key:string]:CreateBindingNodeFn};\r\n\r\nconst nodePropertyConstructorByFirstName:NodePropertyConstructorByFirstName = {\r\n  \"class\": createBindingNodeClassName,\r\n  \"attr\" : createBindingNodeAttribute,\r\n  \"style\": createBindingNodeStyle,\r\n  \"state\": createBindingNodeComponent,\r\n//  \"popover\": PopoverTarget,\r\n//  \"commandfor\": CommandForTarget,\r\n};\r\n\r\nfunction _getBindingNodeCreator(isComment:boolean, isElement: boolean, propertyName: string): CreateBindingNodeFn {\r\n  const bindingNodeCreatorByName = nodePropertyConstructorByNameByIsComment[isComment ? 1 : 0][propertyName];\r\n  if (typeof bindingNodeCreatorByName !== \"undefined\") {\r\n    return bindingNodeCreatorByName;\r\n  }\r\n  if (isComment && propertyName === \"for\") {\r\n    return createBindingNodeFor;\r\n  }\r\n  if (isComment) {\r\n    raiseError(`getBindingNodeCreator: unknown node property ${propertyName}`);\r\n  }\r\n  const nameElements = propertyName.split(\".\");\r\n  const bindingNodeCreatorByFirstName = nodePropertyConstructorByFirstName[nameElements[0]];\r\n  if (typeof bindingNodeCreatorByFirstName !== \"undefined\") {\r\n    return bindingNodeCreatorByFirstName;\r\n  }\r\n  if (isElement) {\r\n    if (propertyName.startsWith(\"on\")) {\r\n      return createBindingNodeEvent;\r\n    } else {\r\n      return createBindingNodeProperty;\r\n    }\r\n  } else {\r\n    return createBindingNodeProperty;\r\n  }\r\n}\r\n\r\nconst _cache: {[key:string]:CreateBindingNodeFn} = {};\r\n\r\n/**\r\n * バインドのノードプロパティの生成関数を取得する\r\n * @param node ノード\r\n * @param propertyName プロパティ名\r\n * @returns {CreateBindingNodeFn} ノードプロパティのコンストラクタ\r\n */\r\nexport function getBindingNodeCreator(\r\n  node        : Node, \r\n  propertyName: string,\r\n  filterTexts: IFilterText[],\r\n  event       : string | null\r\n): CreateBindingNodeByNodeFn {\r\n  const isComment = node instanceof Comment;\r\n  const isElement = node instanceof Element;\r\n  const key = isComment + \"\\t\" + isElement + \"\\t\" + propertyName;\r\n  const fn = _cache[key] ?? (_cache[key] = _getBindingNodeCreator(isComment, isElement, propertyName));\r\n  return fn(propertyName, filterTexts, event);\r\n}\r\n","\r\nconst symbolName = \"state\";\r\n\r\nexport const GetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.GetByRef`);\r\nexport const SetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.SetByRef`);\r\nexport const SetCacheableSymbol        : unique symbol = Symbol.for(`${symbolName}.SetCacheable`);\r\nexport const ConnectedCallbackSymbol   : unique symbol = Symbol.for(`${symbolName}.ConnectedCallback`);\r\nexport const DisconnectedCallbackSymbol: unique symbol = Symbol.for(`${symbolName}.DisconnectedCallback`);\r\nexport const ResolveSymbol             : unique symbol = Symbol.for(`${symbolName}.Resolve`);\r\nexport const GetAllSymbol              : unique symbol = Symbol.for(`${symbolName}.GetAll`);\r\n","import { raiseError } from '../utils.js';\r\nimport { IStructuredPathInfo } from './types';\r\n\r\n/**\r\n * プロパティ名に\"constructor\"や\"toString\"などの予約語やオブジェクトのプロパティ名を\r\n * 上書きするような名前も指定できるように、Mapを検討したが、そもそもそのような名前を\r\n * 指定することはないと考え、Mapを使わないことにした。\r\n */\r\nconst _cache: { [key:string]: IStructuredPathInfo } = {};\r\n//const _cache: Map<string, IStructuredPathInfo> = new Map();\r\n\r\n/**\r\n * パターン情報を取得します\r\n * @param pattern パターン\r\n * @returns {IPatternInfo} パターン情報\r\n */\r\nclass StructuredPathInfo implements IStructuredPathInfo {\r\n  static id = 0;\r\n  id = ++StructuredPathInfo.id;\r\n  pattern;\r\n  pathSegments;\r\n  lastSegment;\r\n  cumulativePaths;\r\n  cumulativeInfos;\r\n  wildcardPaths;\r\n  wildcardInfos;\r\n  wildcardParentPaths;\r\n  wildcardParentInfos;\r\n  lastWildcardPath;\r\n  lastWildcardInfo;\r\n  parentPath;\r\n  parentInfo;\r\n  wildcardCount;\r\n\r\n  constructor(pattern: string) {\r\n    const getPattern = (_pattern: string): IStructuredPathInfo => {\r\n      return (pattern === _pattern) ? this : getStructuredPathInfo(_pattern);\r\n    };\r\n    const pathSegments = pattern.split(\".\");\r\n    const cumulativePaths = [];\r\n    const cumulativeInfos: IStructuredPathInfo[] = [];\r\n    const wildcardPaths = [];\r\n    const wildcardInfos = [];\r\n    const wildcardParentPaths = [];\r\n    const wildcardParentInfos = [];\r\n    let currentPatternPath = \"\", prevPatternPath = \"\";\r\n    let wildcardCount = 0;\r\n    for(let i = 0; i < pathSegments.length; i++) {\r\n      currentPatternPath += pathSegments[i];\r\n      if (pathSegments[i] === \"*\") {\r\n        wildcardPaths.push(currentPatternPath);\r\n        wildcardInfos.push(getPattern(currentPatternPath));\r\n        wildcardParentPaths.push(prevPatternPath);\r\n        wildcardParentInfos.push(getPattern(prevPatternPath));\r\n        wildcardCount++;\r\n      }\r\n      cumulativePaths.push(currentPatternPath);\r\n      cumulativeInfos.push(getPattern(currentPatternPath));\r\n      prevPatternPath = currentPatternPath;\r\n      currentPatternPath += \".\";\r\n    }\r\n    const lastWildcardPath = wildcardPaths.length > 0 ? wildcardPaths[wildcardPaths.length - 1] : null;\r\n    const parentPath = cumulativePaths.length > 1 ? cumulativePaths[cumulativePaths.length - 2] : null;\r\n    this.pattern = pattern;\r\n    this.pathSegments = pathSegments;\r\n    this.lastSegment = pathSegments[pathSegments.length - 1];\r\n    this.cumulativePaths = cumulativePaths;\r\n    this.cumulativeInfos = cumulativeInfos;\r\n    this.wildcardPaths = wildcardPaths;\r\n    this.wildcardInfos = wildcardInfos;\r\n    this.wildcardParentPaths = wildcardParentPaths;\r\n    this.wildcardParentInfos = wildcardParentInfos;\r\n    this.lastWildcardPath = lastWildcardPath;\r\n    this.lastWildcardInfo = lastWildcardPath ? getPattern(lastWildcardPath) : null;\r\n    this.parentPath = parentPath;\r\n    this.parentInfo = parentPath ? getPattern(parentPath) : null;\r\n    this.wildcardCount = wildcardCount;\r\n  }\r\n}\r\n\r\nconst reservedWords = new Set([\r\n  \"constructor\", \"prototype\", \"__proto__\", \"toString\",\r\n  \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",\r\n  \"watch\", \"unwatch\", \"eval\", \"arguments\",\r\n  \"let\", \"var\", \"const\", \"class\", \"function\",\r\n  \"null\", \"true\", \"false\", \"new\", \"return\",\r\n]);\r\n\r\nexport function getStructuredPathInfo(structuredPath: string): IStructuredPathInfo {\r\n  let info: IStructuredPathInfo | undefined;\r\n  info = _cache[structuredPath];\r\n  if (typeof info !== \"undefined\") {\r\n    return info;\r\n  }\r\n  if (reservedWords.has(structuredPath)) {\r\n    raiseError(`getStructuredPathInfo: pattern is reserved word: ${structuredPath}`);\r\n  }\r\n  return (_cache[structuredPath] = new StructuredPathInfo(structuredPath));\r\n}\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { GetByRefSymbol, SetByRefSymbol } from \"../../StateClass/symbols.js\";\r\nimport { IStateProxy } from \"../../StateClass/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\nclass BindingState implements IBindingState {\r\n  #binding     : IBinding;\r\n  #pattern     : string;\r\n  #info        : IStructuredPathInfo;\r\n  #listIndexRef: WeakRef<IListIndex> | null = null;\r\n  #state       : IStateProxy;\r\n  #filters     : Filters;\r\n  get pattern(): string {\r\n    return this.#pattern;\r\n  }\r\n  get info() {\r\n    return this.#info;\r\n  }\r\n  get listIndex() {\r\n    if (this.#listIndexRef === null) return null;\r\n    return this.#listIndexRef.deref() ?? raiseError(\"listIndex is null\");\r\n  }\r\n  get state() {\r\n    return this.#state;\r\n  }\r\n  get filters() {\r\n    return this.#filters;\r\n  }\r\n  get binding() {\r\n    return this.#binding;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    state  : IStateProxy, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this.#binding = binding;\r\n    this.#pattern = pattern;\r\n    this.#info = getStructuredPathInfo(pattern);\r\n    this.#state = state;\r\n    this.#filters = filters;\r\n  }\r\n  get value(): any {\r\n    return this.#state[GetByRefSymbol](this.info, this.listIndex);\r\n  }\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for(let i = 0; i < this.#filters.length; i++) {\r\n      value = this.#filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  init(): void {\r\n    if (this.info.wildcardCount > 0) {\r\n      const lastWildcardPath = this.info.lastWildcardPath ?? \r\n        raiseError(`BindingState.init: wildcardLastParentPath is null`);\r\n      const loopContext = this.binding.parentBindContent.loopContext?.find(lastWildcardPath) ?? \r\n        raiseError(`BindingState.init: loopContext is null`);\r\n      this.#listIndexRef = loopContext.listIndexRef;\r\n    }\r\n    this.binding.engine.saveBinding(this.info, this.listIndex, this.binding);\r\n  }\r\n  assignValue(value:any) {\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n    const engine = this.binding.engine;\r\n    const stateProxy = engine.stateProxy;\r\n    const bindingState = this.binding.bindingState;\r\n    if (loopContext) {\r\n      engine.setLoopContext(loopContext, async () => {\r\n        // @ts-ignore\r\n        stateProxy[SetByRefSymbol](bindingState.info, bindingState.listIndex, value);\r\n      });\r\n    } else {\r\n      // @ts-ignore\r\n      stateProxy[SetByRefSymbol](bindingState.info, bindingState.listIndex, value);\r\n    }\r\n  }\r\n}\r\n\r\nexport const createBindingState: CreateBindingStateFn = \r\n(name: string, filterTexts: IFilterText[]) => \r\n  (binding:IBinding, state: IStateProxy, filters:FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts); // ToDo:ここは、メモ化できる\r\n    return new BindingState(binding, state, name, filterFns);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStateProxy } from \"../../StateClass/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\nclass BindingStateIndex implements IBindingState {\r\n  #binding     : IBinding;\r\n  #indexNumber : number;\r\n  #listIndexRef: WeakRef<IListIndex> | null = null;\r\n  #state       : IStateProxy;\r\n  #filters     : Filters;\r\n  get pattern(): string {\r\n    return raiseError(\"Not implemented\");\r\n  }\r\n  get info() {\r\n    return raiseError(\"Not implemented\");\r\n  }\r\n  get listIndex() {\r\n    if (this.#listIndexRef === null) return null;\r\n    return this.#listIndexRef.deref() ?? raiseError(\"listIndex is null\");\r\n  }\r\n  get state() {\r\n    return this.#state;\r\n  }\r\n  get filters() {\r\n    return this.#filters;\r\n  }\r\n  get binding() {\r\n    return this.#binding;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    state  : IStateProxy, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this.#binding = binding;\r\n    const indexNumber = Number(pattern.slice(1));\r\n    if (isNaN(indexNumber)) {\r\n      raiseError(\"BindingStateIndex: pattern is not a number\");\r\n    }\r\n    this.#indexNumber = indexNumber;\r\n    this.#state = state;\r\n    this.#filters = filters;\r\n  }\r\n  get value(): any {\r\n    return this.listIndex?.index ?? raiseError(\"listIndex is null\");\r\n  }\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for(let i = 0; i < this.#filters.length; i++) {\r\n      value = this.#filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  init(): void {\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext ??\r\n      raiseError(`BindingState.init: loopContext is null`);\r\n    const loopContexts = loopContext.serialize();\r\n    this.#listIndexRef = loopContexts[this.#indexNumber - 1].listIndexRef ??\r\n      raiseError(`BindingState.init: listIndexRef is null`);\r\n    const listIndex = this.listIndex ?? raiseError(\"listIndex is null\");\r\n    const bindings = this.binding.engine.bindingsByListIndex.get(listIndex);\r\n    if (bindings === undefined) {\r\n      this.binding.engine.bindingsByListIndex.set(listIndex, new Set([this.binding]));\r\n    } else {\r\n      bindings.add(this.binding);\r\n    }\r\n  }\r\n  assignValue(value:any): void {\r\n    raiseError(\"BindingStateIndex: assignValue is not implemented\");\r\n  }\r\n}\r\n\r\nexport const createBindingStateIndex: CreateBindingStateFn = \r\n(name: string, filterTexts: IFilterText[]) => \r\n  (binding:IBinding, state: IStateProxy, filters:FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts); // ToDo:ここは、メモ化できる\r\n\r\n    return new BindingStateIndex(binding, state, name, filterFns);\r\n  }\r\n","import { createBindingState } from \"../DataBinding/BindingState/BindingState.js\";\r\nimport { createBindingStateIndex } from \"../DataBinding/BindingState/BindingStateIndex.js\";\r\nimport { CreateBindingStateByStateFn } from \"../DataBinding/BindingState/types\";\r\nimport { IFilterText } from \"./types\";\r\n\r\nconst ereg = new RegExp(/^\\$\\d+$/);\r\n\r\nexport function getBindingStateCreator(\r\n  name       : string, \r\n  filterTexts: IFilterText[]\r\n): CreateBindingStateByStateFn {\r\n  if (ereg.test(name)) {\r\n    return createBindingStateIndex(name, filterTexts);\r\n  } else {\r\n    return createBindingState(name, filterTexts);\r\n  }\r\n}","import { COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants.js\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { NodeType } from \"./types\";\r\n\r\nconst COMMENT_EMBED_MARK_LEN = COMMENT_EMBED_MARK.length;\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\nconst getTextFromContent   = (node:Node):string        => node.textContent?.slice(COMMENT_EMBED_MARK_LEN).trim() ?? \"\";\r\nconst getTextFromAttribute = (node:HTMLElement):string => node.getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\nconst getTextFromTemplate  = (node:Node):string        => {\r\n  const text = node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN).trim(); \r\n  const id = Number(text);\r\n  const template = getTemplateById(id) ?? raiseError(`Template not found: ${text}`);\r\n  return template.getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n};\r\nconst getTextFromSVGElement = (node:SVGElement):string => node.getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n\r\nconst getTextByNodeType = {\r\n  \"Text\":        getTextFromContent,\r\n  \"HTMLElement\": getTextFromAttribute,\r\n  \"Template\":    getTextFromTemplate,\r\n  \"SVGElement\":  getTextFromSVGElement\r\n};\r\n\r\nexport function getDataBindText(nodeType: NodeType, node: Node): string {\r\n  const bindText = getTextByNodeType[nodeType](node as any) ?? \"\";\r\n  if (nodeType === \"Text\") {\r\n    return \"textContent:\" + bindText;\r\n  } else {\r\n    return bindText;\r\n  }\r\n}\r\n","import { raiseError } from \"../utils.js\";\r\nimport { NodeType } from \"./types\";\r\n\r\nconst createNodeKey = (node:Node):string => node.constructor.name + \"\\t\" + ((node instanceof Comment) ? (node.textContent?.[2] ?? \"\") : \"\");\r\n\r\ntype NodeTypeByNodeKey = {\r\n  [nodeKey:string]:NodeType;\r\n};\r\n\r\nconst nodeTypeByNodeKey:NodeTypeByNodeKey = {};\r\n\r\nconst getNodeTypeByNode = (node:Node):NodeType =>\r\n  (node instanceof Comment && node.textContent?.[2] === \":\") ? \"Text\" : \r\n  (node instanceof HTMLElement) ? \"HTMLElement\" :\r\n  (node instanceof Comment && node.textContent?.[2] === \"|\") ? \"Template\" : \r\n  (node instanceof SVGElement) ? \"SVGElement\" : raiseError(`Unknown NodeType: ${node.nodeType}`);\r\n\r\n/**\r\n * ノードのタイプを取得\r\n * @param node ノード\r\n * @param nodeKey ノードキー\r\n * @returns {NodeType} ノードタイプ\r\n */\r\nexport function getNodeType(\r\n  node   : Node, \r\n  nodeKey: string = createNodeKey(node)\r\n): NodeType {\r\n  return nodeTypeByNodeKey[nodeKey] ?? (nodeTypeByNodeKey[nodeKey] = getNodeTypeByNode(node));\r\n}\r\n","import { IFilterText, IBindText } from \"./types\";\r\n\r\nconst trim = (s:string):string => s.trim();\r\n\r\nconst has = (s:string):boolean => s.length > 0; // check length\r\n\r\nconst re = new RegExp(/^#(.*)#$/);\r\nconst decode = (s:string):string => {\r\n  const m = re.exec(s);\r\n  return m ? decodeURIComponent(m[1]) : s;\r\n};\r\n\r\n/**\r\n * parse filter part\r\n * \"eq,100|falsey\" ---> [Filter(eq, [100]), Filter(falsey)]\r\n */\r\nconst parseFilter = (text:string): IFilterText => {\r\n  const [name, ...options] = text.split(\",\").map(trim);\r\n  return {name, options:options.map(decode)};\r\n};\r\n\r\ntype ReturnParseStateProperty = {property:string,filters:IFilterText[]};\r\n/**\r\n * parse expression\r\n * \"value|eq,100|falsey\" ---> [\"value\", Filter[]]\r\n */\r\nconst parseProperty = (text:string): ReturnParseStateProperty => {\r\n  const [property, ...filterTexts] = text.split(\"|\").map(trim);\r\n  return {property, filters:filterTexts.map(parseFilter)};\r\n};\r\n\r\n/**\r\n * parse expressions\r\n * \"textContent:value|eq,100|falsey\" ---> [\"textContent\", \"value\", Filter[eq, falsey]]\r\n */\r\nconst parseExpression = (expression:string): IBindText => {\r\n  const [ bindExpression, event = null ] = expression.split(\"@\").map(trim);\r\n  const [nodePropertyText, statePropertyText] = bindExpression.split(\":\").map(trim);\r\n  const { property:nodeProperty, filters:inputFilterTexts } = parseProperty(nodePropertyText);\r\n  const { property:stateProperty, filters:outputFilterTexts } = parseProperty(statePropertyText);\r\n  return { nodeProperty, stateProperty, inputFilterTexts, outputFilterTexts, event };\r\n};\r\n\r\n/**\r\n * parse bind text and return BindText[]\r\n */\r\nconst parseExpressions = (text:string): IBindText[] => {\r\n  return text.split(\";\").map(trim).filter(has).map(s => parseExpression(s));\r\n};\r\n\r\nconst cache:{[key:string]: IBindText[]} = {};\r\n\r\n/**\r\n * 取得したバインドテキスト(getBindTextByNodeType)を解析して、バインド情報を取得する\r\n * @param text バインドテキスト\r\n * @param defaultName デフォルト名\r\n * @returns {IBindText[]} バインド情報\r\n */\r\nexport function parseBindText(\r\n  text: string\r\n): IBindText[] {\r\n  if (text.trim() === \"\") {\r\n    return [];\r\n  }\r\n  return cache[text] ?? (cache[text] = parseExpressions(text));\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\nconst DATASET_BIND_PROPERTY = 'data-bind';\r\n\r\nconst removeAttributeFromElement = (node:Node):void => {\r\n  const element = node as Element;\r\n  element.removeAttribute(DATASET_BIND_PROPERTY);\r\n}\r\n\r\ntype RemoveAttributeByNodeType = {\r\n  [key in NodeType]: ((node:Node)=>void) | undefined;\r\n}\r\n\r\nconst removeAttributeByNodeType:RemoveAttributeByNodeType = {\r\n  HTMLElement: removeAttributeFromElement,\r\n  SVGElement : removeAttributeFromElement,\r\n  Text       : undefined,\r\n  Template   : undefined,\r\n}\r\n\r\n/**\r\n * ノードからdata-bind属性を削除\r\n * @param node ノード\r\n * @param nodeType ノードタイプ\r\n * @returns {Node} ノード\r\n */\r\nexport function removeDataBindAttribute(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n):void {\r\n  return removeAttributeByNodeType[nodeType]?.(node);\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\nconst replaceTextNodeText = (node:Node):Node => {\r\n  const textNode = document.createTextNode(\"\");\r\n  node.parentNode?.replaceChild(textNode, node);\r\n  return textNode;\r\n}\r\n\r\ntype ReplaceTextNodeFn = {\r\n  [key in NodeType]: ((node:Node)=>Node) | undefined;\r\n}\r\n\r\nconst replaceTextNodeFn:ReplaceTextNodeFn = {\r\n  Text       : replaceTextNodeText,\r\n  HTMLElement: undefined,\r\n  Template   : undefined,\r\n  SVGElement : undefined\r\n}\r\n\r\n/**\r\n * コメントノードをテキストノードに置き換える\r\n * @param node ノード\r\n * @param nodeType ノードタイプ\r\n * @returns {Node} ノード\r\n */\r\nexport function replaceTextNodeFromComment(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n): Node {\r\n  return replaceTextNodeFn[nodeType]?.(node) ?? node;\r\n}\r\n","import { getAbsoluteNodePath } from \"./getAbsoluteNodePath.js\";\r\nimport { getBindingNodeCreator } from \"./getBindingNodeCreator.js\";\r\nimport { getBindingStateCreator } from \"./getBindingStateCreator.js\";\r\nimport { getDataBindText } from \"./getDataBindText.js\";\r\nimport { getNodeType } from \"./getNodeType.js\";\r\nimport { parseBindText } from \"./parseBindText.js\";\r\nimport { removeDataBindAttribute } from \"./removeDataBindAttribute.js\";\r\nimport { replaceTextNodeFromComment } from \"./replaceTextNodeFromComment.js\";\r\nimport { IBindingCreator, IBindText, IDataBindAttributes, NodePath, NodeType } from \"./types\";\r\n\r\nclass DataBindAttributes implements IDataBindAttributes {\r\n  nodeType     : NodeType; // ノードの種別\r\n  nodePath     : NodePath; // ノードのルート\r\n  bindTexts    : IBindText[]; // BINDテキストの解析結果\r\n  creatorByText: Map<IBindText, IBindingCreator> = new Map(); // BINDテキストからバインディングクリエイターを取得\r\n  constructor(node: Node) {\r\n    this.nodeType = getNodeType(node);\r\n    const text = getDataBindText(this.nodeType, node);\r\n    // CommentNodeをTextに置換、template.contentの内容が書き換わることに注意\r\n    node = replaceTextNodeFromComment(node, this.nodeType);\r\n    // data-bind属性を削除する\r\n    removeDataBindAttribute(node, this.nodeType);\r\n\r\n    this.nodePath = getAbsoluteNodePath(node);\r\n    this.bindTexts = parseBindText(text);\r\n    for(let i = 0; i < this.bindTexts.length; i++) {\r\n      const bindText = this.bindTexts[i];\r\n      const creator: IBindingCreator = {\r\n        createBindingNode : getBindingNodeCreator(\r\n          node, \r\n          bindText.nodeProperty, \r\n          bindText.inputFilterTexts,\r\n          bindText.event\r\n        ),\r\n        createBindingState: getBindingStateCreator(\r\n          bindText.stateProperty, \r\n          bindText.outputFilterTexts\r\n        ),\r\n      }\r\n      this.creatorByText.set(bindText, creator);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport function createDataBindAttributes(node: Node): IDataBindAttributes {\r\n  return new DataBindAttributes(node);\r\n}","import { NodePath } from \"./types\";\r\n\r\nexport function getAbsoluteNodePath(node: Node): NodePath {\r\n  let routeIndexes: NodePath = [];\r\n  while(node.parentNode !== null) {\r\n    const childNodes = Array.from(node.parentNode.childNodes) as Node[];\r\n    routeIndexes = [ childNodes.indexOf(node), ...routeIndexes ];\r\n    node = node.parentNode;\r\n  }\r\n  return routeIndexes;\r\n}","import { DATA_BIND_ATTRIBUTE, COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK } from \"../constants.js\";\r\n\r\n/**\r\n * \"@@:\"もしくは\"@@|\"で始まるコメントノードを取得する\r\n */\r\nfunction isCommentNode(node: Node): boolean {\r\n  return node instanceof Comment && (\r\n    (node.textContent?.indexOf(COMMENT_EMBED_MARK) === 0) || (node.textContent?.indexOf(COMMENT_TEMPLATE_MARK) === 0)\r\n  );\r\n} \r\n\r\nexport function getNodesHavingDataBind(root: Node): Node[] {\r\n  const nodes: Node[] = [];\r\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, {\r\n    acceptNode(node:Node) {\r\n      return (node instanceof Element) ? \r\n        (node.hasAttribute(DATA_BIND_ATTRIBUTE) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP)\r\n        : (isCommentNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\r\n    }\r\n  });\r\n  while (walker.nextNode()) {\r\n    nodes.push(walker.currentNode);\r\n  }\r\n  return nodes;\r\n}\r\n\r\n","import { createDataBindAttributes } from \"./createDataBindAttributes.js\";\r\nimport { getNodesHavingDataBind } from \"./getNodesHavingDataBind.js\";\r\nimport { IDataBindAttributes } from \"./types\";\r\n\r\nconst listDataBindAttributesById: {[key:number]:IDataBindAttributes[]} = {};\r\n\r\nconst listPathsSetById: {[key:number]:Set<string>} = {};\r\n\r\nconst pathsSetById: {[key:number]:Set<string>} = {};\r\n\r\nfunction getDataBindAttributesFromTemplate(content: DocumentFragment): IDataBindAttributes[] {\r\n  const nodes = getNodesHavingDataBind(content);\r\n  return nodes.map(node => createDataBindAttributes(node));\r\n}\r\n\r\nexport function registerDataBindAttributes(\r\n  id     : number, \r\n  content: DocumentFragment,\r\n  rootId : number = id\r\n): IDataBindAttributes[] {\r\n  const dataBindAttributes = getDataBindAttributesFromTemplate(content);\r\n  const paths = pathsSetById[rootId] ?? (pathsSetById[rootId] = new Set<string>());\r\n  const listPaths = listPathsSetById[rootId] ?? (listPathsSetById[rootId] = new Set<string>());\r\n  for(let i = 0; i < dataBindAttributes.length; i++) {\r\n    const attribute = dataBindAttributes[i];\r\n    for(let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      paths.add(bindText.stateProperty);\r\n      if (bindText.nodeProperty === \"for\") {\r\n        listPaths.add(bindText.stateProperty);\r\n      }\r\n    }\r\n  }\r\n  return listDataBindAttributesById[id] = dataBindAttributes;\r\n}\r\n\r\nexport const getDataBindAttributesById = (id: number): IDataBindAttributes[] => {\r\n  return listDataBindAttributesById[id];\r\n}\r\n\r\nexport const getListPathsSetById = (id: number): Set<string> => {\r\n  return listPathsSetById[id] ?? [];\r\n};\r\n\r\nexport const getPathsSetById = (id: number): Set<string> => {\r\n  return pathsSetById[id] ?? [];\r\n};","import { registerDataBindAttributes } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { removeEmptyTextNodes } from \"./removeEmptyTextNodes.js\";\r\n\r\nconst templateById:Record<number, HTMLTemplateElement> = {};\r\n\r\nexport function registerTemplate(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number\r\n): number {\r\n  removeEmptyTextNodes(template.content);\r\n  registerDataBindAttributes(id, template.content, rootId);  \r\n  templateById[id] = template;\r\n  return id;\r\n}\r\n\r\nexport function getTemplateById(id: number): HTMLTemplateElement {\r\n  return templateById[id] ?? raiseError(`getTemplateById: template not found: ${id}`);\r\n}","\r\nexport function removeEmptyTextNodes(content:DocumentFragment):void {\r\n  Array.from(content.childNodes).forEach(node => {\r\n    if (node.nodeType === Node.TEXT_NODE && !(node.nodeValue ?? \"\").trim()) {\r\n      content.removeChild(node);\r\n    }\r\n  });  \r\n}\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { CreateBindingNodeByNodeFn, IBindingNode } from \"./BindingNode/types\";\r\nimport { CreateBindingStateByStateFn, IBindingState } from \"./BindingState/types\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\n\r\nclass Binding implements IBinding {\r\n  parentBindContent: IBindContent;\r\n  node             : Node;\r\n  engine           : IComponentEngine;\r\n  bindingNode      : IBindingNode;\r\n  bindingState     : IBindingState;\r\n  constructor(\r\n    parentBindContent : IBindContent,\r\n    node              : Node,\r\n    engine            : IComponentEngine,\r\n    createBindingNode : CreateBindingNodeByNodeFn, \r\n    createBindingState: CreateBindingStateByStateFn,\r\n  ) {\r\n    this.parentBindContent = parentBindContent\r\n    this.node = node;\r\n    this.engine = engine\r\n    this.bindingNode = createBindingNode(this, node, engine.inputFilters);\r\n    this.bindingState = createBindingState(this, engine.stateProxy, engine.outputFilters);\r\n  }\r\n\r\n  get bindContents() {\r\n    return this.bindingNode.bindContents;\r\n  }\r\n\r\n  init() {\r\n    this.bindingNode.init();\r\n    this.bindingState.init();\r\n  }\r\n\r\n  render() {\r\n    this.bindingNode.update();\r\n  }\r\n\r\n  updateStateValue(value: any) {\r\n    const engine = this.engine;\r\n    const bindingState = this.bindingState;\r\n    engine.updater.addProcess(() => {\r\n      return bindingState.assignValue(value);\r\n    });\r\n  }\r\n}\r\n\r\nexport function createBinding(\r\n  parentBindContent : IBindContent,\r\n  node              : Node, \r\n  engine            : IComponentEngine, \r\n  createBindingNode : CreateBindingNodeByNodeFn, \r\n  createBindingState: CreateBindingStateByStateFn\r\n): IBinding {\r\n  return new Binding(\r\n    parentBindContent, \r\n    node, \r\n    engine, \r\n    createBindingNode, \r\n    createBindingState\r\n  );\r\n}","import { IBindContent } from \"../DataBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { ILoopContext } from \"./types\";\r\n\r\nclass LoopContext implements ILoopContext {\r\n  #path     : string;\r\n  #info        : IStructuredPathInfo;\r\n  #listIndexRef: WeakRef<IListIndex> | null;\r\n  #bindContent : IBindContent;\r\n  constructor(\r\n    path    : string | null,\r\n    listIndex  : IListIndex,\r\n    bindContent: IBindContent\r\n  ) {\r\n    this.#path = path ?? raiseError(\"name is required\");\r\n    this.#info = getStructuredPathInfo(this.#path);\r\n    this.#listIndexRef = new WeakRef(listIndex);\r\n    this.#bindContent = bindContent;\r\n  }\r\n  get path(): string {\r\n    return this.#path;\r\n  }\r\n  get info(): IStructuredPathInfo {\r\n    return this.#info;\r\n  }\r\n  get listIndex(): IListIndex {\r\n    return this.#listIndexRef?.deref() ?? raiseError(\"listIndex is null\");\r\n  }\r\n  get listIndexRef(): WeakRef<IListIndex> {\r\n    return this.#listIndexRef ?? raiseError(\"listIndexRef is null\");\r\n  }\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    this.#listIndexRef = new WeakRef(listIndex);\r\n    // 構造は変わらないので、#parentLoopContext、#cacheはクリアする必要はない\r\n  }\r\n  clearListIndex():void {\r\n    this.#listIndexRef = null;\r\n  }\r\n  get bindContent(): IBindContent {\r\n    return this.#bindContent;\r\n  }\r\n\r\n  #parentLoopContext: ILoopContext | null | undefined;\r\n  get parentLoopContext(): ILoopContext | null {\r\n    if (typeof this.#parentLoopContext === \"undefined\") {\r\n      let currentBinding: IBindContent | null = this.bindContent;\r\n      while(currentBinding !== null) {\r\n        if (currentBinding.loopContext !== null && currentBinding.loopContext !== this) {\r\n          this.#parentLoopContext = currentBinding.loopContext;\r\n          break;\r\n        }\r\n        currentBinding = currentBinding.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      if (typeof this.#parentLoopContext === \"undefined\") this.#parentLoopContext = null;\r\n    }\r\n    return this.#parentLoopContext;\r\n  }\r\n\r\n  #cache:Record<string, ILoopContext | null> = {};\r\n  find(name: string): ILoopContext | null {\r\n    let loopContext = this.#cache[name];\r\n    if (typeof loopContext === \"undefined\") {\r\n      let currentLoopContext: ILoopContext | null = this;\r\n      while(currentLoopContext !== null) {\r\n        if (currentLoopContext.path === name) break;\r\n        currentLoopContext = currentLoopContext.parentLoopContext;\r\n      }\r\n      loopContext = this.#cache[name] = currentLoopContext;\r\n    }\r\n    return loopContext;\r\n  }\r\n\r\n  walk(callback: (loopContext: ILoopContext) => void): void {\r\n    let currentLoopContext: ILoopContext | null = this;\r\n    while(currentLoopContext !== null) {\r\n      callback(currentLoopContext);\r\n      currentLoopContext = currentLoopContext.parentLoopContext;\r\n    }\r\n  }\r\n\r\n  serialize(): ILoopContext[] {\r\n    const results: ILoopContext[] = [];\r\n    this.walk((loopContext) => {\r\n      results.unshift(loopContext);\r\n    });\r\n    return results;\r\n  }\r\n\r\n}\r\n\r\n// 生成されたあと、IBindContentのloopContextに登録される\r\n// IBindContentにずっと保持される\r\nexport function createLoopContext(\r\n  pattern: string | null,\r\n  listIndex: IListIndex,\r\n  bindContent: IBindContent\r\n): ILoopContext {\r\n  return new LoopContext(pattern, listIndex, bindContent);\r\n}","import { IBinding } from \"../DataBinding/types\";\r\n\r\nexport function render(bindings: IBinding[]) {\r\n  const bindingsWithSelectElement = [];\r\n  for(let i = 0; i < bindings.length; i++) {\r\n    const binding = bindings[i];\r\n    if (binding.bindingNode.isSelectElement) {\r\n      bindingsWithSelectElement.push(binding);\r\n    } else {\r\n      binding.render();\r\n    }\r\n  }\r\n  for(let i = 0; i < bindingsWithSelectElement.length; i++) {\r\n    bindingsWithSelectElement[i].render();\r\n  }\r\n}\r\n","import { resolveNodeFromPath } from \"../BindingBuilder/resolveNodeFromPath.js\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { createBinding } from \"./Binding.js\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\nimport { createLoopContext } from \"../LoopContext/createLoopContext.js\";\r\nimport { render } from \"../Render/render.js\";\r\nimport { getDataBindAttributesById } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\n\r\nfunction createContent(id: number): DocumentFragment {\r\n  const template = getTemplateById(id) ?? \r\n    raiseError(`BindContent: template is not found: ${id}`);\r\n  return document.importNode(template.content, true);\r\n}\r\n\r\nfunction createBindings(\r\n  bindContent: IBindContent, \r\n  id         : number, \r\n  engine     : IComponentEngine, \r\n  content    : DocumentFragment\r\n): IBinding[] {\r\n  const attributes = getDataBindAttributesById(id) ?? \r\n    raiseError(`BindContent: data-bind is not set`);\r\n  const bindings: IBinding[] = [];\r\n  for(let i = 0; i < attributes.length; i++) {\r\n    const attribute = attributes[i];\r\n    const node = resolveNodeFromPath(content, attribute.nodePath) ?? \r\n      raiseError(`BindContent: node is not found: ${attribute.nodePath}`);\r\n    for(let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      const creator = attribute.creatorByText.get(bindText) ?? \r\n        raiseError(`BindContent: creator is not found: ${bindText}`);\r\n      const binding = createBinding(\r\n        bindContent, \r\n        node, \r\n        engine, \r\n        creator.createBindingNode, \r\n        creator.createBindingState\r\n      );\r\n      bindings.push(binding);\r\n    }\r\n  }\r\n  return bindings;\r\n}\r\n\r\nclass BindContent implements IBindContent {\r\n  loopContext  : ILoopContext | null;\r\n  parentBinding: IBinding | null;\r\n  childNodes   : Node[];\r\n  fragment     : DocumentFragment;\r\n  engine       : IComponentEngine | undefined;\r\n  #id;\r\n  get id() {\r\n    return this.#id;\r\n  }\r\n  get isMounted() {\r\n    return this.childNodes.length > 0 && this.childNodes[0].parentNode !== this.fragment;\r\n  }\r\n  get firstChildNode() {\r\n    return this.childNodes[0] ?? null;\r\n  }\r\n  get lastChildNode() {\r\n    return this.childNodes[this.childNodes.length - 1] ?? null;\r\n  }\r\n  getLastNode(parentNode: Node): Node | null {\r\n    const lastBinding = this.bindings[this.bindings.length - 1];\r\n    const lastChildNode = this.lastChildNode;\r\n    if (lastBinding.node === lastChildNode) {\r\n      if (lastBinding.bindContents.size > 0) {\r\n        const childBindContent = Array.from(lastBinding.bindContents).at(-1) ?? raiseError(`BindContent: childBindContent is not found`);\r\n        const lastNode = childBindContent.getLastNode(parentNode);\r\n        if (lastNode !== null) {\r\n          return lastNode;\r\n        }\r\n      }\r\n    }\r\n    if (parentNode !== lastChildNode?.parentNode) {\r\n      return null;\r\n    }\r\n    return lastChildNode;\r\n  }\r\n  #currentLoopContext: ILoopContext | null | undefined;\r\n  get currentLoopContext(): ILoopContext | null {\r\n    if (typeof this.#currentLoopContext === \"undefined\") {\r\n      let bindContent: IBindContent | null = this;\r\n      while(bindContent !== null) {\r\n        if (bindContent.loopContext !== null) break; ;\r\n        bindContent = bindContent.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      this.#currentLoopContext = bindContent?.loopContext ?? null;\r\n    }\r\n    return this.#currentLoopContext;\r\n  }\r\n  constructor(\r\n    parentBinding: IBinding | null,\r\n    id           : number, \r\n    engine       : IComponentEngine, \r\n    loopContext  : string | null,\r\n    listIndex    : IListIndex | null\r\n  ) {\r\n    this.parentBinding = parentBinding;\r\n    this.#id = id;\r\n    this.fragment = createContent(id);\r\n    this.childNodes = Array.from(this.fragment.childNodes);\r\n    this.engine = engine;\r\n    this.loopContext = (listIndex !== null) ? createLoopContext(loopContext, listIndex, this) : null;\r\n    this.bindings = createBindings(\r\n      this, \r\n      id, \r\n      engine, \r\n      this.fragment\r\n    );\r\n  }\r\n  mount(parentNode: Node) {\r\n    parentNode.appendChild(this.fragment);\r\n  }\r\n  mountBefore(parentNode: Node, beforeNode: Node | null) {\r\n    parentNode.insertBefore(this.fragment, beforeNode);\r\n  }\r\n  mountAfter(parentNode: Node, afterNode: Node | null) {\r\n    parentNode.insertBefore(\r\n      this.fragment, \r\n      afterNode?.nextSibling ?? null\r\n    );\r\n  }\r\n  unmount() {\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      this.fragment.appendChild(this.childNodes[i]);\r\n    }\r\n  }\r\n  bindings: IBinding[] = [];\r\n  render() {\r\n    render(this.bindings);\r\n  }\r\n  init() {\r\n    this.bindings.forEach(binding => binding.init());\r\n  }\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    if (this.loopContext == null) raiseError(`BindContent: loopContext is null`);\r\n    this.loopContext.assignListIndex(listIndex);\r\n    this.init();\r\n  }\r\n}\r\n\r\nexport function createBindContent(\r\n  parentBinding: IBinding | null,\r\n  id           : number, \r\n  engine       :IComponentEngine, \r\n  loopContext  : string | null, \r\n  listIndex    :IListIndex | null\r\n):IBindContent {\r\n  const bindContent = new BindContent(\r\n    parentBinding, \r\n    id, \r\n    engine, \r\n    loopContext, \r\n    listIndex\r\n  );\r\n  bindContent.init();\r\n  return bindContent;\r\n}","import { NodePath } from \"./types\";\r\n\r\nexport function resolveNodeFromPath(root: Node, path: NodePath): Node | null {\r\n  return path.reduce((node, index) => node?.childNodes[index] ?? null, root);\r\n}","import { IListIndex } from \"./types\";\r\n\r\nclass ListIndex implements IListIndex {\r\n  static id: number = 0;\r\n  id              : number = ++ListIndex.id;\r\n  #parentListIndex: IListIndex | null = null;\r\n  get parentListIndex(): IListIndex | null {\r\n    return this.#parentListIndex;\r\n  }\r\n  index: number;\r\n  get indexes(): number[] {\r\n    const indexes = this.parentListIndex?.indexes ?? [];\r\n    indexes.push(this.index);\r\n    return indexes;\r\n  }\r\n\r\n  get position(): number {\r\n    return (this.parentListIndex?.position ?? -1) + 1;\r\n  }\r\n\r\n  constructor(\r\n    parentListIndex: IListIndex | null,\r\n    index: number\r\n  ) {\r\n    this.#parentListIndex = parentListIndex;\r\n    this.index = index;\r\n  }\r\n  \r\n  truncate(length: number): IListIndex | null {\r\n    let listIndex: IListIndex | null = this;\r\n    while(listIndex !== null) {\r\n      if (listIndex.position < length) return listIndex;\r\n      listIndex = listIndex.parentListIndex;\r\n    }\r\n    return null;\r\n  }\r\n  add(value: number): IListIndex {\r\n    return new ListIndex(this, value);\r\n  }\r\n\r\n  *reverseIterator(): Generator<IListIndex> {\r\n    yield this;\r\n    if (this.parentListIndex !== null) {\r\n      yield* this.parentListIndex.reverseIterator();\r\n    }\r\n    return;\r\n  }\r\n\r\n  *iterator(): Generator<IListIndex> {\r\n    if (this.parentListIndex !== null) {\r\n      yield* this.parentListIndex.iterator();\r\n    }\r\n    yield this;\r\n    return;\r\n  }\r\n\r\n  toString(): string {\r\n    const parentListIndex = this.parentListIndex?.toString();\r\n    return (parentListIndex !== null) ? parentListIndex + \",\" + this.index.toString() : this.index.toString();\r\n  }\r\n\r\n  at(position: number): IListIndex | null {\r\n    let iterator;\r\n    if (position >= 0) {\r\n      iterator = this.iterator();\r\n    } else {\r\n      position = - position - 1 \r\n      iterator = this.reverseIterator();\r\n    }\r\n    let next;\r\n    while(position >= 0) {\r\n      next = iterator.next();\r\n      position--;\r\n    }\r\n    return next?.value ?? null;\r\n  }\r\n  \r\n}\r\n\r\nexport function createListIndex(\r\n  parentListIndex: IListIndex | null,\r\n  index          : number\r\n): IListIndex {\r\n  return new ListIndex(parentListIndex, index);\r\n}\r\n\r\nexport function getMaxListIndexId(): number {\r\n  return ListIndex.id;\r\n}\r\n","import { getMaxListIndexId } from \"../ListIndex/createListIndex.js\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\n\r\n/**\r\n * 参照用のIDを生成する\r\n * ListIndexのIDは最大値を取得してから計算するため、ListIndexの構築が完了していない場合、重複が発生する可能性がある\r\n */\r\n/**\r\n * ToDo:ListIndexの構築が完了していない状態で、IDを取得すると例外を発生させる仕組みが必要\r\n */\r\nexport function getStatePropertyRefId(info: IStructuredPathInfo, listIndex: IListIndex | null): number {\r\n  const listIndexMaxId = getMaxListIndexId();\r\n  return info.id * (listIndexMaxId + 1) + (listIndex?.id ?? 0);\r\n}","import { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { getStatePropertyRefId } from \"../../StatePropertyRef/getStatePropertyRefId.js\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\nimport { setTracking } from \"./setTracking.js\";\r\n\r\nfunction _getByRef(\r\n  target   : Object, \r\n  info     : IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n  receiver : IStateProxy,\r\n  handler  : IStateHandler\r\n): any {\r\n  if (handler.lastTrackingStack != null && handler.lastTrackingStack !== info) {\r\n    const lastPattern = handler.lastTrackingStack;\r\n    if (lastPattern.parentInfo !== info) {\r\n      handler.engine.addDependentProp(lastPattern, info);\r\n    }\r\n  }\r\n\r\n  let refId = 0;\r\n  if (handler.cacheable) {\r\n    refId = getStatePropertyRefId(info, listIndex);\r\n    const value = handler.cache[refId];\r\n    if (typeof value !== \"undefined\") {\r\n      return value;\r\n    }\r\n    if (refId in handler.cache) {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  let value;\r\n  try {\r\n    if (info.pattern in target) {\r\n      return (value = handler.engine.setStatePropertyRef(info, listIndex, () => {\r\n        return Reflect.get(target, info.pattern, receiver);\r\n      }));\r\n    } else {\r\n      const parentInfo = info.parentInfo ?? raiseError(`propRef.stateProp.parentInfo is undefined`);\r\n      const parentListIndex = parentInfo.wildcardCount < info.wildcardCount ? (listIndex?.parentListIndex ?? null) : listIndex;\r\n      const parentValue = getByRef(target, parentInfo, parentListIndex, receiver, handler);\r\n      const lastSegment = info.lastSegment;\r\n      if (lastSegment === \"*\") {\r\n        const index = listIndex?.index ?? raiseError(`propRef.listIndex?.index is undefined`);\r\n        return (value = Reflect.get(parentValue, index));\r\n      } else {\r\n        return (value = Reflect.get(parentValue, lastSegment));\r\n      }\r\n    }\r\n  } finally {\r\n    if (handler.cacheable && !(refId in handler.cache)) {\r\n      handler.cache[refId] = value;\r\n    }\r\n  }\r\n}\r\n\r\nexport function getByRef(\r\n    target   : Object, \r\n    info     : IStructuredPathInfo,\r\n    listIndex: IListIndex | null,\r\n    receiver : IStateProxy,\r\n    handler  : IStateHandler\r\n  ): any {\r\n    if (handler.engine.trackedGetters.has(info.pattern)) {\r\n      return setTracking(info, handler, () => {\r\n        return _getByRef(target, info, listIndex, receiver, handler);\r\n      });\r\n    } else {\r\n      return _getByRef(target, info, listIndex, receiver, handler);\r\n    }\r\n\r\n  }\r\n","import { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\nexport function setTracking(info: IStructuredPathInfo, handler: IStateHandler, callback: () => any): any {\r\n  handler.trackingStack.push(info);\r\n  handler.lastTrackingStack = info;\r\n  try {\r\n    return callback();\r\n  } finally {\r\n    handler.trackingStack.pop();\r\n    handler.lastTrackingStack = handler.trackingStack[handler.trackingStack.length - 1] ?? null;\r\n  }\r\n}\r\n","import { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\nimport { getByRef as methodGetByRef } from \"../methods/getByRef.js\";\r\n\r\nexport function getByRef(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n):Function {\r\n  return (pattern: IStructuredPathInfo, listIndex: IListIndex | null) => \r\n    methodGetByRef(target, pattern, listIndex, receiver, handler);\r\n} \r\n","import { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\nimport { getByRef } from \"./getByRef.js\";\r\n\r\nexport function setByRef(\r\n    target   : Object, \r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex | null, \r\n    value    : any, \r\n    receiver : IStateProxy,\r\n    handler  : IStateHandler\r\n): any {\r\n  try {\r\n    if (info.pattern in target) {\r\n      if (info.wildcardCount > 0) {\r\n        if (listIndex === null) {\r\n          raiseError(`propRef.listIndex is null`);\r\n        }\r\n        return handler.engine.setStatePropertyRef(info, listIndex, () => {\r\n          return Reflect.set(target, info.pattern, value, receiver);\r\n        });\r\n      } else {\r\n        return Reflect.set(target, info.pattern, value, receiver);\r\n      }\r\n    } else {\r\n      const parentInfo = info.parentInfo ?? raiseError(`propRef.stateProp.parentInfo is undefined`);\r\n      const parentListIndex = parentInfo.wildcardCount < info.wildcardCount ? (listIndex?.parentListIndex ?? null) : listIndex;\r\n      const parentValue = getByRef(target, parentInfo, parentListIndex, receiver, handler);\r\n      const lastSegment = info.lastSegment;\r\n      if (lastSegment === \"*\") {\r\n        const index = listIndex?.index ?? raiseError(`propRef.listIndex?.index is undefined`);\r\n        return Reflect.set(parentValue, index, value);\r\n      } else {\r\n        return Reflect.set(parentValue, lastSegment, value);\r\n      }\r\n    }\r\n  } finally {\r\n    handler.engine.updater.addUpdatedStatePropertyRefValue(info, listIndex, value);\r\n  }\r\n}\r\n","import { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\nimport { setByRef as methodSetByRef } from \"../methods/setByRef.js\";\r\n\r\nexport function setByRef(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n):Function {\r\n  return (pattern: IStructuredPathInfo, listIndex: IListIndex | null, value: any) => \r\n    methodSetByRef(target, pattern, listIndex, value, receiver, handler);\r\n}","import { IStateHandler, IStateProxy } from \"../types\";\r\nimport { setCacheable as methodSetChargeable } from \"../methods/setCacheable.js\";\r\n\r\nexport function setCacheable(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n):Function {\r\n  return async (callback: () => Promise<void>) => {\r\n    await methodSetChargeable(handler, callback);\r\n  }\r\n}","import { IStateHandler } from \"../types\";\r\n\r\nexport async function setCacheable(handler: IStateHandler, callback: () => Promise<void>): Promise<void> {\r\n  handler.cacheable = true;\r\n  handler.cache = {}\r\n  try {\r\n    await callback();\r\n  } finally {\r\n    handler.cacheable = false;\r\n  }\r\n}\r\n","import { IStateHandler, IStateProxy } from \"../types\";\r\n\r\nconst CONNECTED_CALLBACK = \"$connectedCallback\";\r\n\r\nexport function connectedCallback(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n):Function {\r\n  return async () => {\r\n    const callback = Reflect.get(target, CONNECTED_CALLBACK);\r\n    if (typeof callback === \"function\") {\r\n      await callback.call(target, receiver);\r\n    }\r\n  };\r\n}","import { IStateHandler, IStateProxy } from \"../types\";\r\n\r\nconst DISCONNECTED_CALLBACK = \"$disconnectedCallback\";\r\n\r\nexport function disconnectedCallback(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n):Function {\r\n  return async () => {\r\n    const callback = Reflect.get(target, DISCONNECTED_CALLBACK);\r\n    if (typeof callback === \"function\") {\r\n      await callback.call(target, receiver);\r\n    }\r\n  };\r\n}","import { IListIndex } from \"../../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\nimport { getByRef } from \"../methods/getByRef.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\n\r\nexport function resolve(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n):Function {\r\n  return (path: string, indexes: number[], value?:any): any => {\r\n    const info = getStructuredPathInfo(path);\r\n    let listIndex: IListIndex | null = null;\r\n    for(let i = 0; i < info.wildcardParentInfos.length; i++) {\r\n      const wildcardParentPattern = info.wildcardParentInfos[i] ?? raiseError(`wildcardParentPath is null`);\r\n      const listIndexes: IListIndex[] = Array.from(handler.engine.getListIndexesSet(wildcardParentPattern, listIndex) ?? []);\r\n      const index = indexes[i] ?? raiseError(`index is null`);\r\n      listIndex = listIndexes[index] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n    }\r\n    if (typeof value === \"undefined\") {\r\n      return getByRef(target, info, listIndex, receiver, handler);\r\n    } else {\r\n      return setByRef(target, info, listIndex, value, receiver, handler);\r\n    }\r\n  };\r\n} ","import { IListIndex } from \"../../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\nimport { resolve as _resolve } from \"./resolve.js\";\r\n\r\nexport function getAll(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n):Function {\r\n    const resolve = _resolve(target, prop, receiver, handler);\r\n    return (path: string, indexes?: number[]): any[] => {\r\n      const info = getStructuredPathInfo(path);\r\n      if (handler.lastTrackingStack != null && handler.lastTrackingStack !== info) {\r\n        const lastPattern = handler.lastTrackingStack;\r\n        if (lastPattern.parentInfo !== info) {\r\n          handler.engine.addDependentProp(lastPattern, info);\r\n        }\r\n      }\r\n  \r\n      if (typeof indexes === \"undefined\") {\r\n        for(let i = 0; i < info.wildcardInfos.length; i++) {\r\n          const wildcardPattern = info.wildcardInfos[i] ?? raiseError(`wildcardPattern is null`);\r\n          const listIndex = handler.engine.getContextListIndex(wildcardPattern.pattern);\r\n          if (listIndex) {\r\n            indexes = listIndex.indexes;\r\n            break;\r\n          }\r\n        }\r\n        if (typeof indexes === \"undefined\") {\r\n          indexes = [];\r\n        }\r\n      }\r\n      const walkWildcardPattern = (\r\n        wildcardParentInfos: IStructuredPathInfo[],\r\n        wildardIndexPos: number,\r\n        listIndex: IListIndex | null,\r\n        indexes: number[],\r\n        indexPos: number,\r\n        parentIndexes: number[],\r\n        results: number[][]\r\n      ) => {\r\n        const wildcardParentPattern = wildcardParentInfos[wildardIndexPos] ?? null;\r\n        if (wildcardParentPattern === null) {\r\n          results.push(parentIndexes);\r\n          return;\r\n        }\r\n        const listIndexSet = handler.engine.getListIndexesSet(wildcardParentPattern, listIndex) ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n        const listIndexes = Array.from(listIndexSet);\r\n        const index = indexes[indexPos] ?? null;\r\n        if (index === null) {\r\n          for(let i = 0; i < listIndexes.length; i++) {\r\n            const listIndex = listIndexes[i];\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results);\r\n          }\r\n        } else {\r\n          const listIndex = listIndexes[index] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n          if ((wildardIndexPos + 1) < wildcardParentInfos.length) {\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results\r\n            );\r\n          }\r\n        }\r\n      }\r\n      const resultIndexes: number[][] = [];\r\n      walkWildcardPattern(\r\n        info.wildcardParentInfos, \r\n        0, \r\n        null, \r\n        indexes, \r\n        0, \r\n        [], \r\n        resultIndexes\r\n      );\r\n      const resultValues: any[] = [];\r\n      for(let i = 0; i < resultIndexes.length; i++) {\r\n        resultValues.push(resolve(\r\n          info.pattern,\r\n          resultIndexes[i]\r\n        ));\r\n      }\r\n      return resultValues;\r\n    }\r\n  }","\r\nimport { IResolvedPathInfo, WildcardType } from './types';\r\nimport { getStructuredPathInfo } from './getStructuredPathInfo.js';\r\n\r\n/**\r\n * プロパティ名に\"constructor\"や\"toString\"などの予約語やオブジェクトのプロパティ名を\r\n * 上書きするような名前も指定できるように、Mapを検討したが、そもそもそのような名前を\r\n * 指定することはないと考え、Mapを使わないことにした。\r\n */\r\nconst _cache: { [key:string]: IResolvedPathInfo } = {};\r\n//const _cache: Map<string, IResolvedPathInfo> = new Map();\r\n\r\nclass ResolvedPathInfo implements IResolvedPathInfo {\r\n  static id = 0;\r\n  id = ++ResolvedPathInfo.id;\r\n  name;\r\n  elements;\r\n  paths;\r\n  wildcardCount;\r\n  wildcardType;\r\n  wildcardIndexes;\r\n  info;\r\n  constructor(name: string) {\r\n    const elements = name.split(\".\");\r\n    const tmpPatternElements = elements.slice();\r\n    const paths = [];\r\n    let incompleteCount = 0;\r\n    let completeCount = 0;\r\n    let lastPath = \"\";\r\n    let wildcardCount = 0;\r\n    let wildcardType: WildcardType = \"none\";\r\n    let wildcardIndexes: (number | null)[] = [];\r\n    for(let i = 0; i < elements.length; i++) {\r\n      const element = elements[i];\r\n      if (element === \"*\") {\r\n        tmpPatternElements[i] = \"*\";\r\n        wildcardIndexes.push(null);\r\n        incompleteCount++;\r\n        wildcardCount++;\r\n      } else {\r\n        const number = Number(element);\r\n        if (!Number.isNaN(number)) {\r\n          tmpPatternElements[i] = \"*\";\r\n          wildcardIndexes.push(number);\r\n          completeCount++;\r\n          wildcardCount++;\r\n        }\r\n      }\r\n      lastPath += element;\r\n      paths.push(lastPath);\r\n      lastPath += (i < elements.length - 1 ? \".\" : \"\");\r\n    }\r\n    const pattern = tmpPatternElements.join(\".\");\r\n    const info = getStructuredPathInfo(pattern);\r\n    if (incompleteCount > 0 || completeCount > 0) {\r\n      if (incompleteCount === wildcardCount) {\r\n        wildcardType = \"context\";\r\n      } else if (completeCount === wildcardCount) {\r\n        wildcardType = \"all\";\r\n      } else {\r\n        wildcardType = \"partial\";\r\n      }\r\n    }\r\n    this.name = name;\r\n    this.elements = elements;\r\n    this.paths = paths;\r\n    this.wildcardCount = wildcardCount;\r\n    this.wildcardType = wildcardType;\r\n    this.wildcardIndexes = wildcardIndexes;\r\n    this.info = info;\r\n  }\r\n}\r\n\r\nexport function getResolvedPathInfo(name:string):IResolvedPathInfo {\r\n  let nameInfo: IResolvedPathInfo | undefined;\r\n//  return _cache.get(name) ?? (_cache.set(name, nameInfo = new ResolvedPathInfo(name)), nameInfo);\r\n  return _cache[name] ?? (_cache[name] = new ResolvedPathInfo(name));\r\n}","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IResolvedPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils.js\";\r\n\r\nexport function getListIndex(\r\n  info: IResolvedPathInfo, \r\n  engine: IComponentEngine\r\n): IListIndex | null {\r\n  if (info.info.wildcardCount === 0) {\r\n    return null;\r\n  }\r\n  let listIndex: IListIndex | null = null;\r\n  const lastWildcardPath = info.info.lastWildcardPath ?? \r\n    raiseError(`lastWildcardPath is null`);\r\n  if (info.wildcardType === \"context\") {\r\n    listIndex = engine.getContextListIndex(lastWildcardPath) ?? \r\n      raiseError(`ListIndex not found: ${info.info.pattern}`);\r\n  } else if (info.wildcardType === \"all\") {\r\n    let parentListIndex = null;\r\n    for(let i = 0; i < info.info.wildcardCount; i++) {\r\n      const wildcardParentPattern = info.info.wildcardParentInfos[i] ?? raiseError(`wildcardParentPattern is null`);\r\n      const listIndexes: IListIndex[] = Array.from(engine.getListIndexesSet(wildcardParentPattern, parentListIndex) ?? []);\r\n      const wildcardIndex = info.wildcardIndexes[i] ?? raiseError(`wildcardIndex is null`);\r\n      parentListIndex = listIndexes[wildcardIndex] ?? raiseError(`ListIndex not found: ${wildcardParentPattern.pattern}`);\r\n    }\r\n    listIndex = parentListIndex;\r\n  } else if (info.wildcardType === \"partial\") {\r\n    // ToDo:listIndexを取得する必要がある\r\n  } else if (info.wildcardType === \"none\") {\r\n  }\r\n  return listIndex;\r\n}\r\n","import { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { getAll } from \"../apis/getAll.js\";\r\nimport { resolve } from \"../apis/resolve.js\";\r\nimport { getListIndex } from \"../getListIndex.js\";\r\nimport { getByRef } from \"../methods/getByRef.js\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\nconst matchIndexPropertyName = new RegExp(/^\\$(\\d+)$/);\r\n\r\nexport function get(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler  : IStateHandler\r\n): any {\r\n  let value;\r\n  if (typeof prop === \"string\") {\r\n    if (matchIndexPropertyName.test(prop)) {\r\n      const number = prop.slice(1);\r\n      const index = Number(number);\r\n      const ref = handler.engine.getLastStatePropertyRef() ?? \r\n        raiseError(`get: this.engine.getLastStatePropertyRef() is null`);\r\n      return ref.listIndex?.at(index - 1)?.index ?? raiseError(`ListIndex not found: ${prop}`);\r\n    } else if (prop === \"$resolve\") {\r\n      return resolve(target, prop, receiver, handler);\r\n    } else if (prop === \"$getAll\") {\r\n      return getAll(target, prop, receiver, handler);\r\n    } else {\r\n      const resolvedInfo = getResolvedPathInfo(prop);\r\n      const listIndex = getListIndex(resolvedInfo, handler.engine);\r\n      value = getByRef(\r\n        target, \r\n        resolvedInfo.info, \r\n        listIndex, \r\n        receiver,\r\n        handler\r\n      );\r\n    }\r\n  } else if (typeof prop === \"symbol\") {\r\n    if (prop in handler.callableApi) {\r\n      return handler.callableApi[prop](target, prop, receiver, handler);\r\n    }\r\n    value = Reflect.get(\r\n      target, \r\n      prop, \r\n      receiver\r\n    );\r\n  }\r\n  return value;\r\n}\r\n","import { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetAllSymbol, GetByRefSymbol, ResolveSymbol, SetByRefSymbol, SetCacheableSymbol } from \"./symbols.js\";\r\nimport { IState, IStateHandler, IStateProxy } from \"./types\";\r\nimport { getByRef as apiGetByRef } from \"./apis/getByRef.js\";\r\nimport { setByRef as apiSetByRef } from \"./apis/setByRef.js\";\r\nimport { setCacheable as apiSetCacheable } from \"./apis/setCacheable.js\";\r\nimport { connectedCallback } from \"./apis/connectedCallback.js\";\r\nimport { disconnectedCallback } from \"./apis/disconnectedCallback.js\";\r\nimport { resolve } from \"./apis/resolve.js\";\r\nimport { getAll } from \"./apis/getAll.js\";\r\nimport { get as trapGet } from \"./traps/get.js\";\r\nimport { set as trapSet } from \"./traps/set.js\";\r\n\r\nclass StateHandler implements IStateHandler {\r\n  engine   : IComponentEngine;\r\n  cacheable: boolean = false;\r\n  cache    : {[key:number]:any} = {};\r\n  lastTrackingStack: IStructuredPathInfo | null = null;\r\n  trackingStack: IStructuredPathInfo[] = [];\r\n  \r\n  constructor(engine: IComponentEngine) {\r\n    this.engine = engine;\r\n  }\r\n\r\n  callableApi: { [key:symbol]: Function } = {\r\n    [GetByRefSymbol]: apiGetByRef, \r\n    [SetByRefSymbol]: apiSetByRef, \r\n    [SetCacheableSymbol]: apiSetCacheable, \r\n    [ConnectedCallbackSymbol]: connectedCallback, \r\n    [DisconnectedCallbackSymbol]: disconnectedCallback, \r\n    [ResolveSymbol]: resolve, \r\n    [GetAllSymbol]: getAll,\r\n  };\r\n\r\n  get(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    receiver: IStateProxy\r\n  ): any {\r\n    return trapGet(target, prop, receiver, this);\r\n  }\r\n\r\n  set(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    value   : any, \r\n    receiver: IStateProxy\r\n  ): boolean {\r\n    return trapSet(target, prop, value, receiver, this);\r\n  }\r\n}\r\n\r\nexport function createStateProxy(\r\n  engine: IComponentEngine, \r\n  state: Object\r\n): IStateProxy {\r\n  return new Proxy<IState>(state, new StateHandler(engine)) as IStateProxy;\r\n}\r\n\r\n","import { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { getListIndex } from \"../getListIndex.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\nexport function set(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  value   : any, \r\n  receiver: IStateProxy,\r\n  handler : IStateHandler\r\n): boolean {\r\n  if (typeof prop === \"string\") {\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, handler.engine);\r\n    return setByRef(\r\n      target, \r\n      resolvedInfo.info, \r\n      listIndex, \r\n      value, \r\n      receiver,\r\n      handler\r\n    );\r\n  } else {\r\n    return Reflect.set(\r\n      target, \r\n      prop, \r\n      value, \r\n      receiver\r\n    );\r\n  }\r\n}\r\n","import { createListIndex } from \"../ListIndex/createListIndex.js\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { GetByRefSymbol } from \"./symbols.js\";\r\n\r\nconst BLANK_LISTINDEXES_SET = new Set<IListIndex>();\r\n\r\nfunction buildListIndexTreeSub(\r\n  engine   : IComponentEngine, \r\n  listInfos: Set<IStructuredPathInfo>,\r\n  info     : IStructuredPathInfo,\r\n  listIndex: IListIndex | null, \r\n  value: any[]\r\n): void {\r\n  const oldValue = engine.getList(info, listIndex) ?? [];\r\n  if (oldValue === value) {\r\n    return;\r\n  }\r\n  const oldListIndexesSet = engine.getListIndexesSet(info, listIndex) ?? BLANK_LISTINDEXES_SET;\r\n  const oldListIndexesByItem = Map.groupBy(oldListIndexesSet, listIndex => oldValue[listIndex.index]);\r\n  const newListIndexesSet:Set<IListIndex> = new Set();\r\n  for(let i = 0; i < value.length; i++) {\r\n    const item = value[i];\r\n    const oldListIndexes = oldListIndexesByItem.get(item);\r\n    let curListIndex = oldListIndexes?.shift();\r\n    if (!curListIndex) {\r\n      curListIndex = createListIndex(listIndex, i);\r\n    } else {\r\n      if (curListIndex.index !== i) {\r\n        curListIndex.index = i;\r\n        engine.updater.addUpdatedListIndex(curListIndex);\r\n      }\r\n    }\r\n    newListIndexesSet.add(curListIndex);\r\n  }\r\n  engine.saveListIndexesSet(info, listIndex, newListIndexesSet);\r\n  engine.saveList(info, listIndex, value.slice(0));\r\n\r\n  const searchPath = info.pattern + \".*\";\r\n  for(const info of listInfos) {\r\n    if (searchPath !== info.lastWildcardPath) {\r\n      continue;\r\n    }\r\n    for(const subListIndex of newListIndexesSet) {\r\n      const subValue = engine.stateProxy[GetByRefSymbol](info, subListIndex);\r\n      buildListIndexTreeSub(\r\n        engine, \r\n        listInfos, \r\n        info, \r\n        subListIndex, \r\n        subValue ?? []\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport function buildListIndexTree(\r\n  engine   : IComponentEngine, \r\n  info     : IStructuredPathInfo,\r\n  listIndex: IListIndex | null, \r\n  value    : any\r\n): void {\r\n  const listInfos = engine.listInfoSet;\r\n  // 配列じゃなければ何もしない\r\n  if (!engine.listInfoSet.has(info)) {\r\n    return;\r\n  }\r\n  const values = (value ?? []) as any[];\r\n  buildListIndexTreeSub(\r\n    engine, \r\n    engine.listInfoSet, \r\n    info, \r\n    listIndex, \r\n    values\r\n  );\r\n}\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\n\r\nfunction extractListIndexes(\r\n  info: IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n  engine: IComponentEngine,\r\n): IListIndex[] {\r\n  const wildcardParentInfos: IStructuredPathInfo[] = info.wildcardParentInfos ?? [];\r\n  const _extractListIndexes = (pos:number, currentListIndex: IListIndex | null, resultListIndexes: IListIndex[]) => {\r\n    const wildcardParentInfo = wildcardParentInfos[pos];\r\n    if (!wildcardParentInfo) {\r\n      if (currentListIndex) {\r\n        resultListIndexes.push(currentListIndex);\r\n      }\r\n      return;\r\n    }\r\n    const subListIndex = listIndex?.at(pos) ?? null;\r\n    if (subListIndex) {\r\n      _extractListIndexes(pos + 1, subListIndex, resultListIndexes);\r\n    } else {\r\n      const listIndexes = engine.getListIndexesSet(wildcardParentInfo, currentListIndex);\r\n      for(const loopListIndex of listIndexes ?? []) {\r\n        _extractListIndexes(pos + 1, loopListIndex, resultListIndexes);\r\n      }\r\n    }\r\n  }\r\n  const resultListIndexes: IListIndex[] = [];\r\n  _extractListIndexes(0, listIndex, resultListIndexes);\r\n  return resultListIndexes;\r\n}\r\n\r\nfunction _collectAffectedGetters(\r\n  refInfo        : IStructuredPathInfo,\r\n  refListIndex   : IListIndex | null,\r\n  engine         : IComponentEngine,\r\n  resultPathInfos: Set<IStructuredPathInfo>,\r\n  resultRefs     : {info:IStructuredPathInfo, listIndex:IListIndex | null}[],\r\n) {\r\n//  if (engine.listInfoSet.has(refInfo)) return;\r\n  if (resultPathInfos.has(refInfo)) return;\r\n  const dependentPathInfos = engine.dependentTree.get(refInfo);\r\n  for(const dependentPathInfo of dependentPathInfos ?? []) {\r\n    if (engine.listInfoSet.has(refInfo) && dependentPathInfo.parentInfo === refInfo && dependentPathInfo.lastSegment === \"*\") {\r\n      continue;\r\n    }\r\n    let dependentListIndex = null;\r\n    let updateList = false;\r\n    for(let i = dependentPathInfo.wildcardParentInfos.length - 1; i >= 0; i--) {\r\n      const wildcardParentInfo = dependentPathInfo.wildcardParentInfos[i];\r\n      if (resultPathInfos.has(wildcardParentInfo)) {\r\n        updateList = true;\r\n        break;\r\n      }\r\n      const pos = refInfo.wildcardParentInfos.indexOf(wildcardParentInfo);\r\n      if (pos < 0) continue;\r\n      dependentListIndex = refListIndex?.at(pos) ?? null;\r\n      if (dependentListIndex !== null) break;\r\n    }\r\n    if (updateList) {\r\n      continue;\r\n    }\r\n    if (dependentPathInfo.wildcardParentInfos.length > 0) {\r\n      const extractlistIndexes = extractListIndexes(dependentPathInfo, dependentListIndex, engine);\r\n      for(const listIndex of extractlistIndexes) {\r\n        resultRefs.push({info: dependentPathInfo, listIndex});\r\n        _collectAffectedGetters(dependentPathInfo, listIndex, engine, resultPathInfos, resultRefs);\r\n      }\r\n    } else {\r\n      resultRefs.push({info: dependentPathInfo, listIndex: null});\r\n      _collectAffectedGetters(dependentPathInfo, null, engine, resultPathInfos, resultRefs);\r\n    }\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\nexport function collectAffectedGetters(\r\n  updateRefs: {info:IStructuredPathInfo, listIndex:IListIndex | null}[],\r\n  engine: IComponentEngine,\r\n): {info:IStructuredPathInfo, listIndex:IListIndex | null}[] {\r\n  const resultPathInfos = new Set<IStructuredPathInfo>();\r\n  const resultRefs: {info:IStructuredPathInfo, listIndex:IListIndex | null}[] = [];\r\n  for(const ref of updateRefs) {\r\n    const info = ref.info;\r\n    const listIndex = ref.listIndex;\r\n    if (resultPathInfos.has(info)) continue;\r\n    _collectAffectedGetters(info, listIndex, engine, resultPathInfos, resultRefs);\r\n    resultPathInfos.add(info);\r\n  }\r\n  return resultRefs;\r\n\r\n}\r\n\r\n","import { IBinding } from \"../DataBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { render } from \"../Render/render.js\";\r\nimport { buildListIndexTree } from \"../StateClass/buildListIndexTree.js\";\r\nimport { SetCacheableSymbol } from \"../StateClass/symbols.js\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRefId } from \"../StatePropertyRef/getStatePropertyRefId.js\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { getGlobalConfig } from \"../WebComponents/getGlobalConfig.js\";\r\nimport { IUpdater } from \"./types\";\r\nimport { collectAffectedGetters } from \"./collectAffectedGetters.js\";\r\n\r\ntype UpdatedArrayElementBinding = {\r\n  parentRef: {info: IStructuredPathInfo, listIndex: IListIndex | null};\r\n  binding: IBinding;\r\n  listIndexes: IListIndex[];\r\n  values: any[];\r\n};\r\n\r\nclass Updater implements IUpdater {\r\n  processList      : (() => Promise<void> | void)[] = [];\r\n  updatedProperties: Set<{info:IStructuredPathInfo, listIndex:IListIndex | null} | IListIndex> = \r\n    new Set<{info:IStructuredPathInfo, listIndex:IListIndex | null} | IListIndex>();\r\n  updatedValues    : {[key:number]: any} = {};\r\n  engine           : IComponentEngine;\r\n\r\n  constructor(engine: IComponentEngine) {\r\n    this.engine = engine;\r\n  }\r\n\r\n  addProcess(process: () => Promise<void> | void): void {\r\n    this.processList.push(process);\r\n    this.waitForQueueEntry.resolve();\r\n  }\r\n\r\n  addUpdatedStatePropertyRefValue(\r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex | null, \r\n    value    : any\r\n  ): void {\r\n    const refId = getStatePropertyRefId(info, listIndex);\r\n    this.updatedProperties.add({info, listIndex});\r\n    this.updatedValues[refId] = value;\r\n    this.waitForQueueEntry.resolve();\r\n  }\r\n\r\n  addUpdatedListIndex(listIndex: IListIndex): void {\r\n    this.updatedProperties.add(listIndex);\r\n    this.waitForQueueEntry.resolve();\r\n  }\r\n\r\n  terminate(): PromiseWithResolvers<void> {\r\n    const waitForMainLoopTerminate = Promise.withResolvers<void>();\r\n    this.waitForQueueEntry.resolve(waitForMainLoopTerminate);\r\n    return waitForMainLoopTerminate;\r\n  }\r\n\r\n  waitForQueueEntry: PromiseWithResolvers<PromiseWithResolvers<void> | void> = \r\n    Promise.withResolvers<PromiseWithResolvers<void> | void>();\r\n  async main(waitForComponentInit: PromiseWithResolvers<void>) {\r\n    await waitForComponentInit.promise;\r\n    const config = getGlobalConfig();\r\n    while (true) {\r\n      try {\r\n        const waitForMainLoopTerminate: (PromiseWithResolvers<void> | void) = \r\n          await this.waitForQueueEntry.promise;\r\n          config.debug && performance.mark(`start`);\r\n        Updater.updatingCount++;\r\n        try {\r\n          await this.exec();\r\n          if (config.debug) {\r\n            performance.mark(`end`);\r\n            performance.measure(`exec`, `start`, `end`);\r\n            console.log(performance.getEntriesByType(\"measure\"));    \r\n            performance.clearMeasures(`exec`);\r\n            performance.clearMarks(`start`);\r\n            performance.clearMarks(`end`);\r\n          }\r\n        } finally {\r\n          Updater.updatingCount--;\r\n          if (waitForMainLoopTerminate) {\r\n            waitForMainLoopTerminate.resolve();\r\n            break;\r\n          }\r\n        }\r\n      } catch(e) {\r\n        console.error(e);\r\n      } finally {\r\n        this.waitForQueueEntry = Promise.withResolvers<PromiseWithResolvers<void> | void>();\r\n      }\r\n    }\r\n  }\r\n\r\n  async updateState() {\r\n    while(this.processList.length > 0) {\r\n      const processList = this.processList;\r\n      this.processList = [];\r\n      for(let i = 0; i < processList.length; i++) {\r\n        const process = processList[i];\r\n        await process();\r\n      }\r\n    }\r\n  }\r\n\r\n  async rebuild(): Promise<{bindings: IBinding[], arrayElementBindings: UpdatedArrayElementBinding[]}> {\r\n    const retArrayElementBindings: UpdatedArrayElementBinding[] = [];\r\n    const retBindings: IBinding[] = [];\r\n    const engine = this.engine;\r\n    const processedListIndexes = new Set<IListIndex>();\r\n    const processedPropertyRefIdsSet = new Set<number>();\r\n    while(this.updatedProperties.size > 0) {\r\n      const updatedProiperties = Array.from(this.updatedProperties.values());\r\n\r\n      const updatedRefs = []; // 更新されたプロパティ参照のリスト\r\n      const arrayPropertyRefs = [];\r\n      const arrayElementPropertyRefs = [];\r\n      this.updatedProperties.clear();\r\n      for(let i = 0; i < updatedProiperties.length; i++) {\r\n        const item = updatedProiperties[i];\r\n        let bindings;\r\n        if (\"index\" in item) {\r\n          if (processedListIndexes.has(item)) continue;\r\n          const listIndex = item as IListIndex;\r\n          bindings = engine.bindingsByListIndex.get(listIndex);\r\n          processedListIndexes.add(listIndex);\r\n        } else {\r\n          const statePropertyRefId = getStatePropertyRefId(item.info, item.listIndex);\r\n          if (processedPropertyRefIdsSet.has(statePropertyRefId)) continue;\r\n          const statePropertyRef = item as {info:IStructuredPathInfo, listIndex:IListIndex | null};\r\n          if (engine.listInfoSet.has(statePropertyRef.info)) {\r\n            arrayPropertyRefs.push(statePropertyRef);\r\n          }\r\n          if (engine.elementInfoSet.has(statePropertyRef.info)) {\r\n            arrayElementPropertyRefs.push(statePropertyRef);\r\n          }\r\n          bindings = engine.getBindings(item.info, item.listIndex);\r\n          processedPropertyRefIdsSet.add(statePropertyRefId);\r\n          updatedRefs.push(statePropertyRef);\r\n        }\r\n        retBindings.push(...bindings ?? []);\r\n      }\r\n\r\n      // リストインデックスの構築\r\n      const builtStatePropertyRefIds = new Set<number>();\r\n      for(let i = 0; i < arrayPropertyRefs.length; i++) {\r\n        const arrayPropertyRef = arrayPropertyRefs[i];\r\n        const statePropertyRefId = getStatePropertyRefId(arrayPropertyRef.info, arrayPropertyRef.listIndex);\r\n        const value = this.updatedValues[statePropertyRefId] ?? null;\r\n        buildListIndexTree(engine, arrayPropertyRef.info, arrayPropertyRef.listIndex, value);\r\n        builtStatePropertyRefIds.add(statePropertyRefId);\r\n      }\r\n\r\n      const parentRefByRefId: {[parentRefId: number]: {info: IStructuredPathInfo, listIndex: IListIndex | null }} = {};\r\n      const statePropertyRefByStatePropertyRefId = Object.groupBy(arrayElementPropertyRefs, ref => {\r\n        if (ref.info.parentInfo === null) raiseError(`parentInfo is null`);\r\n        const parentInfo = ref.info.parentInfo;\r\n        const parentListIndex = (ref.info.wildcardCount === ref.info.parentInfo.wildcardCount) ?\r\n          ref.listIndex : (ref.listIndex?.parentListIndex ?? null);\r\n        const parentRefId = getStatePropertyRefId(parentInfo, parentListIndex);\r\n        if (!(parentRefId in parentRefByRefId)) {\r\n          parentRefByRefId[parentRefId] = {info: parentInfo, listIndex: parentListIndex};\r\n        }\r\n        return parentRefId;\r\n      });\r\n      for(const [parentRefIdKey, refs] of Object.entries(statePropertyRefByStatePropertyRefId)) {\r\n        const parentRefId = Number(parentRefIdKey);\r\n        if (builtStatePropertyRefIds.has(parentRefId)) continue;\r\n        if (typeof refs === \"undefined\") continue;\r\n        const parentRef = parentRefByRefId[parentRefId];\r\n        if (parentRef === null) continue;\r\n\r\n        const values = [];\r\n        const listIndexes = [];\r\n        for(let j = 0; j < refs.length; j++) {\r\n          const ref = refs[j];\r\n          const statePropertyRefId = getStatePropertyRefId(ref.info, ref.listIndex);\r\n          const value = this.updatedValues[statePropertyRefId] ?? null;\r\n          values.push(value);\r\n          const listIndex = ref.listIndex;\r\n          if (listIndex === null) {\r\n            throw new Error(\"listIndex is null\");\r\n          }\r\n          listIndexes.push(listIndex);\r\n        }\r\n        const bindings = engine.getBindings(parentRef.info, parentRef.listIndex);\r\n        for(const binding of bindings) {\r\n          const arrayElementBinding: UpdatedArrayElementBinding = {\r\n            parentRef,\r\n            binding,\r\n            listIndexes,\r\n            values\r\n          };\r\n          retArrayElementBindings.push(arrayElementBinding);\r\n        }\r\n      }\r\n      \r\n      const updatingRefs = collectAffectedGetters(updatedRefs, engine);\r\n      for(const updatingRef of updatingRefs) {\r\n        const bindings = engine.getBindings(updatingRef.info, updatingRef.listIndex);\r\n        retBindings.push(...bindings ?? []);\r\n      }\r\n      \r\n    }\r\n    this.updatedValues = {};\r\n    return {bindings: retBindings, arrayElementBindings: retArrayElementBindings};\r\n  }\r\n\r\n  async render(bindings: IBinding[]) {\r\n    await this.engine.stateProxy[SetCacheableSymbol](async () => {\r\n      return render(bindings);\r\n    });\r\n  }\r\n\r\n  async exec() {\r\n    while(this.processList.length !== 0 || this.updatedProperties.size !== 0) {\r\n      // update state\r\n      await this.updateState();\r\n      // rebuild\r\n      const { bindings, arrayElementBindings } = await this.rebuild();\r\n      // render\r\n      for(const arrayElementBinding of arrayElementBindings) {\r\n        arrayElementBinding.binding.bindingNode.updateElements(arrayElementBinding.listIndexes, arrayElementBinding.values);\r\n      }\r\n      if (bindings.length > 0) {\r\n        await this.render(bindings);\r\n      }\r\n    }\r\n  }\r\n\r\n  static updatingCount = 0;\r\n}\r\n\r\nexport function createUpdater(engine: IComponentEngine): IUpdater {\r\n  return new Updater(engine);\r\n}\r\n\r\nexport function getUpdatingCount(): number {\r\n  return Updater.updatingCount;\r\n}","import { raiseError } from \"../utils.js\";\r\nimport { IComponentConfig } from \"../WebComponents/types\";\r\nimport { canHaveShadowRoot } from \"./canHaveShadowRoot.js\";\r\n\r\nfunction getParentShadowRoot(parentNode: Node | null): ShadowRoot|undefined{\r\n  let node: Node | null = parentNode;\r\n  while(node) {\r\n    if (node instanceof ShadowRoot) {\r\n      return node;\r\n    }\r\n    node = node.parentNode;\r\n  }\r\n}\r\n\r\nexport function attachShadow(element: HTMLElement, config: IComponentConfig, styleSheet: CSSStyleSheet): void {\r\n    if (config.enableShadowDom) {\r\n      if (config.extends === null || canHaveShadowRoot(config.extends)) {\r\n        const shadowRoot = element.attachShadow({ mode: 'open' });\r\n        shadowRoot.adoptedStyleSheets = [styleSheet];\r\n      } else {\r\n        raiseError(`ComponentEngine: Shadow DOM not supported for builtin components that extend ${config.extends}`);\r\n      }\r\n    } else {\r\n      const shadowRootOrDocument = getParentShadowRoot(element.parentNode) || document;\r\n      const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n      if (!styleSheets.includes(styleSheet)) {\r\n        shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, styleSheet];\r\n      }\r\n    }\r\n\r\n}","export function canHaveShadowRoot(tagName: string): boolean {\r\n  try {\r\n    // 一時的に要素を作成\r\n    const element = document.createElement(tagName);\r\n    // `attachShadow` メソッドが存在し、実行可能かを確認\r\n    return typeof element.attachShadow === \"function\";\r\n  } catch {\r\n    // 無効なタグ名などが渡された場合は false を返す\r\n    return false;\r\n  }\r\n}","import { createBindContent } from \"../DataBinding/BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../DataBinding/types\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { IState, IStateProxy, IStructiveState } from \"../StateClass/types\";\r\nimport { createStateProxy } from \"../StateClass/createStateProxy.js\";\r\nimport { IUpdater } from \"../Updater/types\";\r\nimport { createUpdater } from \"../Updater/updater.js\";\r\nimport { ComponentType, IComponentConfig, IComponentStatic, StructiveComponent } from \"../WebComponents/types\";\r\nimport { attachShadow } from \"./attachShadow.js\";\r\nimport { ISaveInfoByResolvedPathInfo, IComponentEngine } from \"./types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { buildListIndexTree } from \"../StateClass/buildListIndexTree.js\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, SetByRefSymbol, SetCacheableSymbol } from \"../StateClass/symbols.js\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { BindParentComponentSymbol } from \"../ComponentState/symbols.js\";\r\n\r\nexport class ComponentEngine implements IComponentEngine {\r\n  type          : ComponentType = 'autonomous';\r\n  config        : IComponentConfig;\r\n  template      : HTMLTemplateElement;\r\n  styleSheet    : CSSStyleSheet;\r\n  stateClass    : IStructiveState;\r\n  state         : IState;\r\n  stateProxy    : IStateProxy;\r\n  updater       : IUpdater;\r\n  inputFilters  : FilterWithOptions;\r\n  outputFilters : FilterWithOptions;\r\n  bindContent   : IBindContent;\r\n  baseClass     : typeof HTMLElement = HTMLElement;\r\n  owner         : StructiveComponent;\r\n  trackedGetters: Set<string>;\r\n\r\n  listInfoSet       : Set<IStructuredPathInfo> = new Set();\r\n  elementInfoSet: Set<IStructuredPathInfo> = new Set();\r\n  bindingsByListIndex                  : WeakMap<IListIndex, Set<IBinding>> = new WeakMap();\r\n  dependentTree                        : Map<IStructuredPathInfo, Set<IStructuredPathInfo>> = new Map();\r\n\r\n  bindingsByComponent: WeakMap<StructiveComponent, Set<IBinding>> = new WeakMap();\r\n\r\n  #waitForInitialize : PromiseWithResolvers<void> = Promise.withResolvers<void>();\r\n  #loopContext       : ILoopContext | null = null;\r\n  #stackStructuredPathInfo  : IStructuredPathInfo[] = [];\r\n  #stackListIndex    : (IListIndex | null)[] = [];\r\n\r\n  constructor(config: IComponentConfig, owner: StructiveComponent) {\r\n    this.config = config;\r\n    if (this.config.extends) {\r\n      this.type = 'builtin';\r\n    }\r\n    const componentClass = owner.constructor as IComponentStatic;\r\n    this.template = componentClass.template;\r\n    this.styleSheet = componentClass.styleSheet;\r\n    this.stateClass = componentClass.stateClass;\r\n    this.state = new this.stateClass();\r\n    this.stateProxy = createStateProxy(this, this.state);\r\n    this.updater = createUpdater(this);\r\n    this.inputFilters = componentClass.inputFilters;\r\n    this.outputFilters = componentClass.outputFilters;\r\n    this.owner = owner;\r\n    this.trackedGetters = componentClass.trackedGetters;\r\n    // 依存関係の木を作成する\r\n    const checkDependentProp = (info: IStructuredPathInfo) => {\r\n      const parentInfo = info.parentInfo;\r\n      if (parentInfo === null) return;\r\n      this.addDependentProp(info, parentInfo);\r\n      checkDependentProp(parentInfo);\r\n    }\r\n    for(const path of componentClass.paths) {\r\n      const info = getStructuredPathInfo(path);\r\n      checkDependentProp(info);\r\n    }\r\n    // 配列のプロパティ、配列要素のプロパティを登録する\r\n    for(const listPath of componentClass.listPaths) {\r\n      this.listInfoSet.add(getStructuredPathInfo(listPath));\r\n      this.elementInfoSet.add(getStructuredPathInfo(listPath + \".*\"));\r\n    }\r\n    this.bindContent = createBindContent(null, componentClass.id, this, null, null); // this.stateArrayPropertyNamePatternsが変更になる可能性がある\r\n    for(const info of this.listInfoSet) {\r\n      if (info.wildcardCount > 0) continue;\r\n      const value = this.stateProxy[GetByRefSymbol](info, null)\r\n      buildListIndexTree(this, info, null, value);\r\n    }\r\n  \r\n    this.updater.main(this.#waitForInitialize);\r\n  }\r\n\r\n  async connectedCallback(): Promise<void> {\r\n    this.owner.state[BindParentComponentSymbol]();\r\n    attachShadow(this.owner, this.config, this.styleSheet);\r\n    await this.stateProxy[ConnectedCallbackSymbol]();\r\n    await this.stateProxy[SetCacheableSymbol](async () => {\r\n      this.bindContent.render();\r\n    });\r\n    this.bindContent.mount(this.owner.shadowRoot ?? this.owner);\r\n    this.#waitForInitialize.resolve();\r\n  }\r\n\r\n  async disconnectedCallback(): Promise<void> {\r\n    await this.stateProxy[DisconnectedCallbackSymbol]();\r\n  }\r\n\r\n  async setLoopContext(loopContext: ILoopContext, callback: ()=>Promise<void>): Promise<void> {\r\n    try {\r\n      if (this.#loopContext !== null) {\r\n        throw new Error(\"loopContext is already set\");\r\n      }\r\n      this.#loopContext = loopContext;\r\n      await this.asyncSetStatePropertyRef(loopContext.info, loopContext.listIndex, async () => {\r\n        await callback();\r\n      });\r\n    } finally {\r\n      this.#loopContext = null;\r\n    }\r\n  }\r\n\r\n  async asyncSetStatePropertyRef(\r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex | null, \r\n    callback : ()=>Promise<any>\r\n  ): Promise<any> {\r\n    this.#stackStructuredPathInfo.push(info);\r\n    this.#stackListIndex.push(listIndex);\r\n    try {\r\n      return await callback();\r\n    } finally {\r\n      this.#stackStructuredPathInfo.pop();\r\n      this.#stackListIndex.pop();\r\n    }\r\n  }\r\n\r\n  setStatePropertyRef(\r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex | null, \r\n    callback : ()=>any\r\n  ): any {\r\n    this.#stackStructuredPathInfo.push(info);\r\n    this.#stackListIndex.push(listIndex);\r\n    try {\r\n      return callback();\r\n    } finally {\r\n      this.#stackStructuredPathInfo.pop();\r\n      this.#stackListIndex.pop();\r\n    }\r\n  }\r\n\r\n  getLastStatePropertyRef(): {info:IStructuredPathInfo, listIndex:IListIndex | null} | null {\r\n    if (this.#stackStructuredPathInfo.length === 0) {\r\n      return null;\r\n    }\r\n    const info = this.#stackStructuredPathInfo[this.#stackStructuredPathInfo.length - 1];\r\n    if (typeof info === \"undefined\") {\r\n      return null;\r\n    }\r\n    const listIndex = this.#stackListIndex[this.#stackListIndex.length - 1];\r\n    if (typeof listIndex === \"undefined\") {\r\n      return null;\r\n    }\r\n    return {info, listIndex};\r\n  }\r\n\r\n  getContextListIndex(structuredPath: string): IListIndex | null{\r\n    const lastRef = this.getLastStatePropertyRef();\r\n    if (lastRef === null) {\r\n      return null;\r\n    }\r\n    const info = lastRef.info;\r\n    const index = info.wildcardPaths.indexOf(structuredPath);\r\n    if (index >= 0) {\r\n      return lastRef.listIndex?.at(index) ?? null;\r\n    }\r\n    return null;\r\n  }\r\n  getLoopContexts():ILoopContext[] {\r\n    if (this.#loopContext === null) {\r\n      throw new Error(\"loopContext is null\");\r\n    }\r\n    return this.#loopContext.serialize();\r\n  }\r\n\r\n  #saveInfoByListIndexByResolvedPathInfoId: { [id:number]: WeakMap<IListIndex,ISaveInfoByResolvedPathInfo> } = {};\r\n  #saveInfoByStructuredPathId: { [id:number]: ISaveInfoByResolvedPathInfo } = {};\r\n\r\n  createSaveInfo():ISaveInfoByResolvedPathInfo {\r\n    return {\r\n      list          : null,\r\n      listIndexesSet: null,\r\n      bindings      : [],\r\n    }\r\n  }\r\n\r\n  getSaveInfoByStatePropertyRef(info:IStructuredPathInfo, listIndex:IListIndex | null): ISaveInfoByResolvedPathInfo {\r\n    if (listIndex === null) {\r\n      let saveInfo = this.#saveInfoByStructuredPathId[info.id];\r\n      if (typeof saveInfo === \"undefined\") {\r\n        saveInfo = this.createSaveInfo();\r\n        this.#saveInfoByStructuredPathId[info.id] = saveInfo;\r\n      }\r\n      return saveInfo;\r\n    } else {\r\n      let saveInfoByListIndex = this.#saveInfoByListIndexByResolvedPathInfoId[info.id];\r\n      if (typeof saveInfoByListIndex === \"undefined\") {\r\n        saveInfoByListIndex = new WeakMap<IListIndex, ISaveInfoByResolvedPathInfo>();\r\n        this.#saveInfoByListIndexByResolvedPathInfoId[info.id] = saveInfoByListIndex;\r\n      }\r\n      let saveInfo = saveInfoByListIndex.get(listIndex);\r\n      if (typeof saveInfo === \"undefined\") {\r\n        saveInfo = this.createSaveInfo();\r\n        saveInfoByListIndex.set(listIndex, saveInfo);\r\n      }\r\n      return saveInfo;\r\n    }\r\n  }\r\n  saveBinding(\r\n    info     : IStructuredPathInfo, \r\n    listIndex: IListIndex | null, \r\n    binding  : IBinding\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.bindings.push(binding);\r\n  }\r\n  saveListIndexesSet(\r\n    info              :IStructuredPathInfo, \r\n    listIndex         :IListIndex | null, \r\n    saveListIndexesSet:Set<IListIndex>\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.listIndexesSet = saveListIndexesSet;\r\n  }\r\n  saveList(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null, \r\n    list     :any[]\r\n  ): void {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    saveInfo.list = list;\r\n  }\r\n  getBindings(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null\r\n  ): IBinding[] {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return saveInfo.bindings;\r\n  }\r\n  getListIndexesSet(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null\r\n  ): Set<IListIndex> | null {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return saveInfo.listIndexesSet;\r\n  }\r\n  getList(\r\n    info     :IStructuredPathInfo, \r\n    listIndex:IListIndex | null\r\n  ): any[] | null {\r\n    const saveInfo = this.getSaveInfoByStatePropertyRef(info, listIndex);\r\n    return saveInfo.list;\r\n  }\r\n\r\n  addDependentProp(info: IStructuredPathInfo, refInfo: IStructuredPathInfo) {\r\n    let dependents = this.dependentTree.get(refInfo);\r\n    if (typeof dependents === \"undefined\") {\r\n      dependents = new Set<IStructuredPathInfo>();\r\n      this.dependentTree.set(refInfo, dependents);\r\n    }\r\n    dependents.add(info);\r\n  }\r\n\r\n  getPropertyValue(info: IStructuredPathInfo, listIndex:IListIndex | null): any {\r\n    // プロパティの値を取得する\r\n    return this.stateProxy[GetByRefSymbol](info, listIndex);\r\n  }\r\n  setPropertyValue(info: IStructuredPathInfo, listIndex:IListIndex | null, value: any): void {\r\n    // プロパティの値を設定する\r\n    this.updater.addProcess(() => {\r\n      this.stateProxy[SetByRefSymbol](info, listIndex, value);\r\n    });\r\n  }\r\n}\r\n\r\nexport function createComponentEngine(config: IComponentConfig, component: StructiveComponent): IComponentEngine {\r\n  return new ComponentEngine(config, component);\r\n}","import { COMMENT_EMBED_MARK } from \"../constants.js\";\r\nimport { raiseError } from \"../utils.js\";\r\n\r\nconst MUSTACHE_REGEXP = /\\{\\{([^\\}]+)\\}\\}/g;\r\nconst MUSTACHE_TYPES:Set<string> = new Set(['if', 'for', 'endif', 'endfor', 'elseif', 'else']);\r\n\r\ntype MustacheType = 'if' | 'for' | 'endif' | 'endfor' | 'elseif' | 'else';\r\ntype MustacheInfo = {\r\n  type: MustacheType;\r\n  remain: string; // after first ':'\r\n  expr: string;\r\n}\r\n\r\nexport function replaceMustacheWithTemplateTag(html: string): string {\r\n  const stack:MustacheInfo[] = [];\r\n  return html.replaceAll(MUSTACHE_REGEXP, (match, expr) => {\r\n    expr = expr.trim();\r\n    const [ type ] = expr.split(':');\r\n    if (!MUSTACHE_TYPES.has(type)) {\r\n      // embed\r\n      return `<!--${COMMENT_EMBED_MARK}${expr}-->`;\r\n    }\r\n    const remain = expr.slice(type.length + 1).trim();\r\n    const currentInfo:MustacheInfo = { type, expr, remain };\r\n    if (type === 'if' || type === 'for') {\r\n      stack.push(currentInfo);\r\n      return `<template data-bind=\"${expr}\">`;\r\n    } else if (type === 'endif') {\r\n      const endTags = [];\r\n      do {\r\n        const info = stack.pop() ?? raiseError('replaceMustacheToTemplateOrEmbed: endif without if');\r\n        if (info.type === 'if') {\r\n          endTags.push('</template>');\r\n          break;\r\n        } else if (info.type === 'elseif') {\r\n          endTags.push('</template>');\r\n        } else {\r\n          raiseError('replaceMustacheToTemplateOrEmbed: endif without if');\r\n        }\r\n      } while(true);\r\n      return endTags.join('');\r\n    } else if (type === 'endfor') {\r\n      const info = stack.pop() ?? raiseError('replaceMustacheToTemplateOrEmbed: endif without if');\r\n      if (info.type === 'for') {\r\n        return '</template>';\r\n      } else {\r\n        raiseError('replaceMustacheToTemplateOrEmbed: endfor without for');\r\n      }\r\n    } else if (type === 'elseif') {\r\n      const lastInfo = stack.at(-1) ?? raiseError('replaceMustacheToTemplateOrEmbed: elseif without if');\r\n      if (lastInfo.type === 'if' || lastInfo.type === 'elseif') {\r\n        stack.push(currentInfo);\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\"><template data-bind=\"if:${remain}\">`;\r\n      } else {\r\n        raiseError('replaceMustacheToTemplateOrEmbed: elseif without if');\r\n      }\r\n    } else if (type === 'else') {\r\n      const lastInfo = stack.at(-1) ?? raiseError('replaceMustacheToTemplateOrEmbed: else without if');\r\n      if (lastInfo.type === 'if') {\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\">`;\r\n      } else {\r\n        raiseError('replaceMustacheToTemplateOrEmbed: else without if');\r\n      }\r\n    } else {\r\n      raiseError('replaceMustacheToTemplateOrEmbed: unknown type');\r\n    }\r\n  });\r\n}\r\n\r\n\r\n\r\n","import { COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants.js\";\r\nimport { generateId } from \"../GlobalId/generateId.js\";\r\nimport { registerTemplate } from \"./registerTemplate.js\";\r\n\r\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\r\n\r\nexport function replaceTemplateTagWithComment(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number = id\r\n):number {\r\n  // テンプレートの親ノードが存在する場合は、テンプレートをコメントノードに置き換える\r\n  template.parentNode?.replaceChild(document.createComment(`${COMMENT_TEMPLATE_MARK}${id}`), template);\r\n  if (template.namespaceURI === SVG_NS) {\r\n    // SVGタグ内のtemplateタグを想定\r\n    const newTemplate = document.createElement(\"template\");\r\n    for(let childNode of Array.from(template.childNodes)) {\r\n      newTemplate.content.appendChild(childNode);\r\n    }\r\n    const bindText = template.getAttribute(DATA_BIND_ATTRIBUTE);\r\n    newTemplate.setAttribute(DATA_BIND_ATTRIBUTE, bindText ?? \"\");\r\n    template = newTemplate;\r\n  }\r\n  template.content.querySelectorAll(\"template\").forEach(template => {\r\n    replaceTemplateTagWithComment(generateId(), template, rootId);\r\n  });\r\n  registerTemplate(id, template, rootId);\r\n  return id;\r\n}\r\n","import { replaceMustacheWithTemplateTag } from \"./replaceMustacheWithTemplateTag.js\";\r\nimport { replaceTemplateTagWithComment } from \"./replaceTemplateTagWithComment.js\";\r\n\r\nexport function registerHtml(id: number, html:string) {\r\n  const template = document.createElement(\"template\");\r\n  template.dataset.id = id.toString();\r\n  template.innerHTML = replaceMustacheWithTemplateTag(html);\r\n  replaceTemplateTagWithComment(id, template);\r\n}","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IBinding } from \"../DataBinding/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { BindParentComponentSymbol, RenderSymbol } from \"./symbols.js\";\r\nimport { IComponentState, IComponentStateHandler, IComponentStateProxy } from \"./types\";\r\n\r\nclass ComponentState implements IComponentState {\r\n  engine: IComponentEngine;\r\n  constructor(engine: IComponentEngine) {\r\n    this.engine = engine;\r\n  }\r\n\r\n  bindParentProperty(binding: IBinding): void {\r\n    const propName = binding.bindingNode.subName;\r\n    Object.defineProperty(this.engine.state, propName, {\r\n      get: () => {\r\n        return binding.bindingState.filteredValue;\r\n      },\r\n      set: (value: any) => {\r\n        return binding.updateStateValue(value);\r\n      },\r\n    });\r\n  }\r\n\r\n  bindParentComponent(): void {\r\n    // bindParentComponent\r\n    const parent = this.engine.owner.parentStructiveComponent;\r\n    if (parent === null) {\r\n      return;\r\n    }\r\n    const bindings = parent.getBindingsFromChild(this.engine.owner);\r\n    for (const binding of bindings ?? []) {\r\n      this.bindParentProperty(binding);\r\n    }\r\n  }\r\n\r\n  render(name: string, value:any): void {\r\n    // render\r\n    const info = getStructuredPathInfo(name);\r\n    this.engine.updater.addUpdatedStatePropertyRefValue(info, null, value)\r\n  }\r\n\r\n  getPropertyValue(name: string): any {\r\n    // getPropertyValue\r\n    const info = getStructuredPathInfo(name);\r\n    return this.engine.getPropertyValue(info, null);\r\n  }\r\n\r\n  setPropertyValue(name: string, value: any): void {\r\n    // setPropertyValue\r\n    const info = getStructuredPathInfo(name);\r\n    this.engine.setPropertyValue(info, null, value); \r\n  }\r\n}\r\n\r\nclass ComponentStateHandler implements IComponentStateHandler {\r\n  get(state: IComponentState, prop: PropertyKey, receiver: IComponentState): any {\r\n    if (prop === RenderSymbol) {\r\n      return state.render.bind(state);\r\n    } else if (prop === BindParentComponentSymbol) {\r\n      return state.bindParentComponent.bind(state);\r\n    } else if (typeof prop === 'string') {\r\n      return state.getPropertyValue(prop);\r\n    } else {\r\n      return Reflect.get(state, prop, receiver);\r\n    }\r\n  }\r\n\r\n  set(state: IComponentState, prop: PropertyKey, value: any, receiver: IComponentState): boolean {\r\n    if (typeof prop === 'string') {\r\n      state.setPropertyValue(prop, value);\r\n      return true;\r\n    } else {\r\n      return Reflect.set(state, prop, value, receiver);\r\n    }\r\n  }\r\n};\r\n\r\nexport const createComponentState = (engine: IComponentEngine): IComponentStateProxy => {\r\n  return new Proxy<IComponentState>(new ComponentState(engine), new ComponentStateHandler()) as IComponentStateProxy;\r\n}","import { inputBuiltinFilters, outputBuiltinFilters } from \"../Filter/builtinFilters.js\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { generateId } from \"../GlobalId/generateId.js\";\r\nimport { getStateClassById, registerStateClass } from \"../StateClass/registerStateClass.js\";\r\nimport { getStyleSheetById } from \"../StyleSheet/registerStyleSheet.js\";\r\nimport { registerCss } from \"../StyleSheet/regsiterCss.js\";\r\nimport { createComponentEngine } from \"../ComponentEngine/ComponentEngine.js\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types.js\";\r\nimport { registerHtml } from \"../Template/registerHtml.js\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { getBaseClass } from \"./getBaseClass.js\";\r\nimport { getComponentConfig } from \"./getComponentConfig.js\";\r\nimport { IComponent, IUserComponentData, IUserConfig, StructiveComponentClass, StructiveComponent } from \"./types\";\r\nimport { getListPathsSetById, getPathsSetById } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { IStructiveState, IStructiveStaticState } from \"../StateClass/types\";\r\nimport { IBinding } from \"../DataBinding/types\";\r\nimport { IComponentStateProxy } from \"../ComponentState/types\";\r\nimport { createComponentState } from \"../ComponentState/createComponentState.js\";\r\n\r\nfunction findStructiveParent(el:StructiveComponent): IComponent | null {\r\n  let current = el.parentNode;\r\n  while (current) {\r\n    if ((current as StructiveComponent).state && (current as StructiveComponent).isStructive) {\r\n      return current as StructiveComponent;\r\n    }\r\n    current = current.parentNode;\r\n    if (current instanceof ShadowRoot) {\r\n      if (current.host && (current.host as StructiveComponent).state && (current.host as StructiveComponent).isStructive) {\r\n        return current.host as StructiveComponent;\r\n      }\r\n      current = current.host;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function createComponentClass(componentData: IUserComponentData): StructiveComponentClass {\r\n  const config = (componentData.stateClass.$config ?? {})as IUserConfig;\r\n  const componentConfig = getComponentConfig(config);\r\n  const id = generateId();\r\n  const { html, css, stateClass } = componentData;\r\n  const inputFilters:FilterWithOptions = Object.assign({}, inputBuiltinFilters);\r\n  const outputFilters:FilterWithOptions = Object.assign({}, outputBuiltinFilters);\r\n  stateClass.$isStructive = true;\r\n  registerHtml(id, html);\r\n  registerCss(id, css);\r\n  registerStateClass(id, stateClass);\r\n  const baseClass = getBaseClass(componentConfig.extends);\r\n  const extendTagName = componentConfig.extends;\r\n  return class extends baseClass implements IComponent {\r\n    #engine: IComponentEngine;\r\n    #componentState: IComponentStateProxy;\r\n\r\n    constructor() {\r\n      super();\r\n      this.#engine = createComponentEngine(componentConfig, this as StructiveComponent);\r\n      this.#componentState = createComponentState(this.#engine);\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.#engine.connectedCallback();\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.#engine.disconnectedCallback();\r\n    }\r\n\r\n    #parentStructiveComponent: IComponent | null | undefined;\r\n    get parentStructiveComponent(): IComponent | null {\r\n      if (typeof this.#parentStructiveComponent === \"undefined\") {\r\n        this.#parentStructiveComponent = findStructiveParent(this as StructiveComponent);\r\n      }\r\n      return this.#parentStructiveComponent;\r\n    }\r\n\r\n    get state(): IComponentStateProxy {\r\n      return this.#componentState;\r\n    }\r\n\r\n    get isStructive(): boolean {\r\n      return this.#engine.stateClass.$isStructive ?? false;\r\n    }\r\n\r\n    getBindingsFromChild(component: IComponent): Set<IBinding> | null {\r\n      return this.#engine.bindingsByComponent.get(component as StructiveComponent) ?? null;\r\n    }\r\n\r\n    static define(tagName:string) {\r\n      if (extendTagName) {\r\n        customElements.define(tagName, this, { extends: extendTagName });\r\n      } else {\r\n        customElements.define(tagName, this);\r\n      }\r\n    }\r\n\r\n    static get id():number {\r\n      return id;\r\n    }\r\n    static #html:string = html;\r\n    static get html():string {\r\n      return this.#html;\r\n    }\r\n    static set html(value:string) {\r\n      this.#html = value;\r\n      registerHtml(this.id, value);\r\n      this.#template = null;\r\n    }\r\n\r\n    static #css:string = css;\r\n    static get css() {\r\n      return this.#css;\r\n    }\r\n    static set css(value:string) {\r\n      this.#css = value;\r\n      registerCss(this.id, value);\r\n      this.#styleSheet = null;\r\n    }\r\n    static #template: HTMLTemplateElement | null = null;\r\n    static get template():HTMLTemplateElement {\r\n      if (!this.#template) {\r\n        this.#template = getTemplateById(this.id);\r\n      }\r\n      return this.#template;\r\n    }\r\n    static #styleSheet: CSSStyleSheet | null = null;\r\n    static get styleSheet():CSSStyleSheet {\r\n      if (!this.#styleSheet) {\r\n        this.#styleSheet = getStyleSheetById(this.id);\r\n      }\r\n      return this.#styleSheet;\r\n    }\r\n    static #stateClass: IStructiveState | null = null;\r\n    static get stateClass():IStructiveState {\r\n      if (!this.#stateClass) {\r\n        this.#stateClass = getStateClassById(this.id) as IStructiveState;\r\n      }\r\n      return this.#stateClass;\r\n    }\r\n    static #inputFilters:FilterWithOptions = inputFilters;\r\n    static get inputFilters():FilterWithOptions {\r\n      return this.#inputFilters;\r\n    }\r\n    static #outputFilters:FilterWithOptions = outputFilters;\r\n    static get outputFilters():FilterWithOptions {\r\n      return this.#outputFilters;\r\n    }\r\n    static get listPaths(): Set<string> {\r\n      return getListPathsSetById(this.id);\r\n    }\r\n    static get paths(): Set<string> {\r\n      return getPathsSetById(this.id);\r\n    }\r\n    static #trackedGetters: Set<string> | null = null;\r\n    static get trackedGetters(): Set<string> {\r\n      if(this.#trackedGetters === null) {\r\n        this.#trackedGetters = new Set<string>();\r\n        let currentProto = this.stateClass.prototype;\r\n        while (currentProto && currentProto !== Object.prototype) {\r\n          const trackedGetters = Object.getOwnPropertyDescriptors(currentProto);\r\n          if (trackedGetters) {\r\n            for (const [key, desc] of Object.entries(trackedGetters)) {\r\n              if ((desc as PropertyDescriptor).get) {\r\n                this.#trackedGetters.add(key);\r\n              }\r\n            }\r\n          }\r\n          currentProto = Object.getPrototypeOf(currentProto);\r\n        }\r\n      }\r\n      return this.#trackedGetters;\r\n\r\n    }\r\n  } as StructiveComponentClass;\r\n}\r\n","import { getGlobalConfig } from \"./getGlobalConfig.js\";\r\nimport { IUserConfig, IComponentConfig } from \"./types\";\r\n\r\nexport function getComponentConfig(userConfig: IUserConfig): IComponentConfig {\r\n  const globalConfig = getGlobalConfig();\r\n  return {\r\n    enableShadowDom: userConfig.enableShadowDom ?? globalConfig.enableShadowDom,\r\n    extends        : userConfig.extends ?? null,\r\n  };\r\n}","import { Constructor } from \"./types\";\r\n\r\nexport function getBaseClass(extendTagName: string | null):Constructor<HTMLElement> {\r\n  return extendTagName ? (document.createElement(extendTagName).constructor as Constructor<HTMLElement>) : HTMLElement;\r\n}","import { IStructiveState } from \"../StateClass/types\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nfunction escapeEmbed(html: string): string {\r\n  return html.replaceAll(/\\{\\{([^\\}]+)\\}\\}/g, (match, expr) => {\r\n    return `<!--{{${expr}}}-->`;\r\n  });\r\n}\r\n\r\nfunction unescapeEmbed(html:string):string {\r\n  return html.replaceAll(/<!--\\{\\{([^\\}]+)\\}\\}-->/g, (match, expr) => {\r\n    return `{{${expr}}}`;\r\n  });\r\n}\r\n\r\nexport async function createSingleFileComponent(text: string): Promise<IUserComponentData> {\r\n  const template = document.createElement(\"template\");\r\n  template.innerHTML = escapeEmbed(text);\r\n\r\n  const html = template.content.querySelector(\"template\");\r\n  html?.remove();\r\n\r\n  const script = template.content.querySelector(\"script[type=module]\") as HTMLScriptElement;\r\n  const scriptModule = script ? await import(\"data:text/javascript;charset=utf-8,\" + script.text) : {};\r\n  script?.remove();\r\n\r\n  const style = template.content.querySelector(\"style\");\r\n  style?.remove();\r\n\r\n  const stateClass = (scriptModule.default ?? class {}) as IStructiveState;\r\n  \r\n  return {\r\n    text,\r\n    html      : unescapeEmbed(html?.innerHTML ?? \"\").trim(),\r\n    css       : style?.textContent ?? \"\",\r\n    stateClass,\r\n  }\r\n}","import { createSingleFileComponent } from \"./createSingleFileComponent.js\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nexport async function loadSingleFileComponent(path: string): Promise<IUserComponentData> {\r\n  const response = await fetch(import.meta.resolve(path));\r\n  const text = await response.text();\r\n  return createSingleFileComponent(text);\r\n}\r\n","import { StructiveComponentClass } from \"./types\";\r\n\r\nexport function registerComponentClass(tagName: string, componentClass: StructiveComponentClass) {\r\n  componentClass.define(tagName);\r\n}","import { raiseError } from \"../utils\";\r\nimport { config } from \"../WebComponents/getGlobalConfig\";\r\n\r\nconst SLOT_KEY = \"router\";\r\nconst DEFAULT_LAYOUT = `<slot name=\"${SLOT_KEY}\"></slot>`;\r\n\r\nexport class MainWrapper extends HTMLElement {\r\n  constructor() {\r\n    super();\r\n    if (config.enableShadowDom) {\r\n      this.attachShadow({ mode: 'open' });\r\n    }\r\n  }\r\n\r\n  async connectedCallback() {\r\n    await this.loadLayout();\r\n    this.render();\r\n  }\r\n\r\n  get root(): ShadowRoot | HTMLElement {\r\n    return this.shadowRoot ?? this;\r\n  }\r\n\r\n  async loadLayout() {\r\n    if (config.layoutPath) {\r\n      const response = await fetch(config.layoutPath);\r\n      if (response.ok) {\r\n        const layoutText = await response.text();\r\n        const workTemplate = document.createElement(\"template\");\r\n        workTemplate.innerHTML = layoutText;\r\n      \r\n        const template = workTemplate.content.querySelector(\"template\");\r\n        const style = workTemplate.content.querySelector(\"style\") as CSSStyleSheet | null;\r\n      \r\n        this.root.appendChild(template?.content ?? document.createDocumentFragment());\r\n        if (style) {\r\n          const shadowRootOrDocument = this.shadowRoot ?? document;\r\n          const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n          if (!styleSheets.includes(style)) {\r\n            shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, style];\r\n          }\r\n        }\r\n      } else {\r\n        raiseError(`Failed to load layout from ${config.layoutPath}`);\r\n      }\r\n    } else {\r\n      this.root.innerHTML = DEFAULT_LAYOUT;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    // add router\r\n    if (config.enableRouter) {\r\n      const router = document.createElement(config.routerTagName);\r\n      router.setAttribute('slot', SLOT_KEY);\r\n      this.root.appendChild(router);\r\n    }\r\n  }\r\n}\r\n","import { createComponentClass } from \"./createComponentClass\";\r\nimport { loadImportmap } from \"./loadImportmap\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent\";\r\nimport { registerComponentClass } from \"./registerComponentClass\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nconst ROUTES_KEY = \"@routes/\";\r\nconst COMPONENTS_KEY = \"@components/\";\r\n\r\nexport async function loadFromImportMap(): Promise<void> {\r\n  const importmap = loadImportmap();\r\n  if (importmap.imports) {\r\n    for (const [alias, value] of Object.entries(importmap.imports)) {\r\n      let tagName;\r\n      if (alias.startsWith(ROUTES_KEY)) {\r\n        const path = alias.slice(ROUTES_KEY.length - 1); // remove the prefix '@routes'\r\n        tagName = \"routes-\" + path.replace(/\\//g, \"-\"); // replace '/' with '-'\r\n      } if (alias.startsWith(COMPONENTS_KEY)) {\r\n        tagName = alias.slice(COMPONENTS_KEY.length - 1); // remove the prefix '@components'\r\n      }\r\n      if (!tagName) {\r\n        continue;\r\n      }\r\n      let componentData : IUserComponentData | null = null;\r\n      componentData = await loadSingleFileComponent(alias);\r\n      const componentClass = createComponentClass(componentData);\r\n      registerComponentClass(tagName, componentClass);\r\n    }\r\n  }\r\n\r\n} \r\n","import { IImportMap } from \"./types\";\r\n\r\nexport function loadImportmap():IImportMap {\r\n  const importmap: IImportMap = {};\r\n  document.querySelectorAll(\"script[type='importmap']\").forEach(script => {\r\n    const scriptImportmap = JSON.parse(script.innerHTML);\r\n    if (scriptImportmap.imports) {\r\n      importmap.imports = Object.assign(importmap.imports || {}, scriptImportmap.imports);\r\n    }\r\n  });\r\n  return importmap;\r\n}\r\n\r\n","import { registerSingleFileComponents } from \"./WebComponents/registerSingleFIleComponents.js\";\r\nimport { bootstrap } from \"./bootstrap.js\";\r\nimport { config as _config } from \"./WebComponents/getGlobalConfig.js\";\r\nimport { IConfig } from \"./WebComponents/types\";\r\n\r\nexport const config: IConfig = _config;\r\n\r\nlet initialized = false;\r\nexport async function defineComponents(singleFileComponents: Record<string, string>):Promise<void> {\r\n  await registerSingleFileComponents(singleFileComponents);\r\n  if (config.autoInit) {\r\n    await bootstrapStructive();\r\n  }\r\n}\r\n\r\nexport async function bootstrapStructive():Promise<void> {\r\n  if (!initialized) {\r\n    await bootstrap();\r\n    initialized = true;\r\n  }\r\n}\r\n\r\n","import { entryRoute } from \"../Router/Router.js\";\r\nimport { createComponentClass } from \"./createComponentClass.js\";\r\nimport { config } from \"./getGlobalConfig.js\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent.js\";\r\nimport { registerComponentClass } from \"./registerComponentClass.js\";\r\nimport { IUserComponentData, SingleFileComponents } from \"./types\";\r\n\r\nexport async function registerSingleFileComponents(singleFileComponents:SingleFileComponents):Promise<void> {\r\n  for(const [ tagName, path ] of Object.entries(singleFileComponents)) {\r\n    let componentData : IUserComponentData | null = null;\r\n    if (config.enableRouter) {\r\n      const routePath = path.startsWith(\"@routes\") ? path.slice(7) : path; // remove the prefix 'routes:'\r\n      entryRoute(tagName, routePath === \"/root\" ? \"/\" : routePath); // routing\r\n    }\r\n    componentData = await loadSingleFileComponent(path);\r\n    const componentClass = createComponentClass(componentData);\r\n    registerComponentClass(tagName, componentClass);\r\n  }\r\n}","import { MainWrapper } from \"./MainWrapper/MainWrapper.js\";\r\nimport { Router } from \"./Router/Router.js\";\r\nimport { config } from \"./WebComponents/getGlobalConfig.js\";\r\nimport { loadFromImportMap } from \"./WebComponents/loadFromImportMap.js\";\r\n\r\nexport async function bootstrap(): Promise<void> {\r\n  if (config.autoLoadFromImportMap) {\r\n    await loadFromImportMap();\r\n  }\r\n\r\n  if (config.enableRouter) {\r\n    customElements.define(config.routerTagName, Router);\r\n  }\r\n\r\n  if (config.enableMainWrapper) {\r\n    customElements.define(config.mainTagName, MainWrapper);\r\n    if (config.autoInsertMainWrapper) {\r\n      const mainWrapper = document.createElement(config.mainTagName);\r\n      document.body.appendChild(mainWrapper);\r\n    }\r\n  }\r\n}"],"names":["ROUTE_PATH_PREFIX","routeMap","Router","HTMLElement","_popstateHandler","constructor","super","this","popstateHandler","bind","connectedCallback","innerHTML","window","addEventListener","dispatchEvent","Event","disconnectedCallback","removeEventListener","event","render","routePath","location","pathname","tagName","params","path","tag","Object","entries","regex","RegExp","replace","test","matches","match","forEach","key","index","substring","customElement","document","createElement","setAttribute","JSON","stringify","appendChild","messageElement","textContent","entryRoute","startsWith","globalConfig","debug","locale","enableShadowDom","enableMainWrapper","enableRouter","autoInsertMainWrapper","autoInit","mainTagName","routerTagName","layoutPath","autoLoadFromImportMap","getGlobalConfig","config","optionsRequired","fnName","Error","optionMustBeNumber","valueMustBeNumber","valueMustBeDate","builtinFilters","eq","options","opt","optValue","Number","isNaN","value","ne","not","valueMustBeBoolean","lt","le","gt","ge","inc","dec","mul","div","fix","toFixed","toLocaleString","uc","toString","toUpperCase","lc","toLowerCase","cap","v","length","charAt","slice","trim","substr","opt1","opt1Value","opt2","opt2Value","pad","padStart","rep","repeat","rev","split","reverse","join","int","parseInt","float","parseFloat","round","Math","pow","floor","ceil","percent","date","Date","toLocaleDateString","time","toLocaleTimeString","datetime","ymd","year","getFullYear","month","getMonth","day","getDate","falsy","truthy","defaults","boolean","Boolean","number","string","String","null","outputBuiltinFilters","inputBuiltinFilters","id","generateId","raiseError","message","stateClassById","styleSheetById","registerCss","css","styleSheet","CSSStyleSheet","replaceSync","registerStyleSheet","textToFilter","filters","text","filter","name","cache","Map","createFilters","texts","result","get","i","push","set","BindingNode","binding","node","bindContents","Set","subName","init","update","assignValue","bindingState","filteredValue","updateElements","listIndexes","values","isSelectElement","HTMLSelectElement","BindingNodeAttribute","BindingNodeCheckbox","Array","isArray","element","checked","map","_val","includes","BindingNodeClassList","className","BindingNodeClassName","classList","add","remove","BindingNodeEvent","e","handler","engine","stateProxy","updater","loopContext","parentBindContent","currentLoopContext","indexes","serialize","context","listIndex","preventDefault","addProcess","async","typeOfValue","setLoopContext","Reflect","apply","createBindingNodeEvent","filterTexts","filterFns","DATA_BIND_ATTRIBUTE","COMMENT_EMBED_MARK","COMMENT_TEMPLATE_MARK","BindingNodeBlock","BindingNodeIf","bindContent","trueBindContents","falseBindContents","createBindContent","parentNode","mountBefore","nextSibling","unmount","BindingNodeFor","bindContentsSet","bindContentByListIndex","WeakMap","bindContentPool","bindContentLastIndex","assignListIndex","pattern","deleteBindContent","clearListIndex","poolLength","listIndexesSet","getListIndexesSet","info","newBindContensSet","lastBindContent","lastNode","getLastNode","mountAfter","firstChildNode","removeBindContentsSet","difference","oldListValues","getList","currentBindContents","from","targetBindContents","lastChildNode","oldValue","targetIndex","indexOf","prevBindContent","saveList","createBindingNodeFor","DEFAULT_PROPERTY","defaultPropertyByElementType","$t","Pt","button","_cache","getDefaultPropertyByNodeType","HTMLTextAreaElement","HTMLOptionElement","HTMLButtonElement","HTMLAnchorElement","HTMLFormElement","HTMLInputElement","type","SVGElement","undefined","Text","Template","defaultEventByName","selected","BindingNodeProperty","defaultName","nodeType","getDefaultName","eventName","updateStateValue","createBindingNodeProperty","BindingNodeRadio","BindingNodeStyle","style","setProperty","symbolName","RenderSymbol","Symbol","for","BindParentComponentSymbol","BindingNodeComponent","bindings","bindingsByComponent","state","nodePropertyConstructorByNameByIsComment","Vt","Ft","nodePropertyConstructorByFirstName","Ot","getBindingNodeCreator","propertyName","isComment","Comment","isElement","Element","fn","bindingNodeCreatorByName","nameElements","bindingNodeCreatorByFirstName","_getBindingNodeCreator","GetByRefSymbol","SetByRefSymbol","SetCacheableSymbol","ConnectedCallbackSymbol","DisconnectedCallbackSymbol","ResolveSymbol","GetAllSymbol","StructuredPathInfo","static","pathSegments","lastSegment","cumulativePaths","cumulativeInfos","wildcardPaths","wildcardInfos","wildcardParentPaths","wildcardParentInfos","lastWildcardPath","lastWildcardInfo","parentPath","parentInfo","wildcardCount","getPattern","_pattern","getStructuredPathInfo","currentPatternPath","prevPatternPath","reservedWords","structuredPath","has","BindingState","listIndexRef","deref","find","saveBinding","BindingStateIndex","indexNumber","loopContexts","bindingsByListIndex","ereg","getBindingStateCreator","createBindingStateIndex","createBindingState","getTextByNodeType","getAttribute","Mt","getTemplateById","nodeTypeByNodeKey","getNodeType","nodeKey","createNodeKey","getNodeTypeByNode","s","re","decode","m","exec","decodeURIComponent","parseFilter","parseProperty","property","parseExpressions","expression","bindExpression","nodePropertyText","statePropertyText","nodeProperty","inputFilterTexts","stateProperty","outputFilterTexts","parseExpression","removeAttributeFromElement","removeAttribute","removeAttributeByNodeType","replaceTextNodeFn","textNode","createTextNode","replaceChild","DataBindAttributes","nodePath","bindTexts","creatorByText","bindText","getDataBindText","removeDataBindAttribute","replaceTextNodeFromComment","routeIndexes","childNodes","getAbsoluteNodePath","parseBindText","creator","createBindingNode","getNodesHavingDataBind","root","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","SHOW_COMMENT","acceptNode","hasAttribute","FILTER_ACCEPT","FILTER_SKIP","isCommentNode","nextNode","currentNode","listDataBindAttributesById","listPathsSetById","pathsSetById","getDataBindAttributesFromTemplate","content","createDataBindAttributes","templateById","registerTemplate","template","rootId","Node","TEXT_NODE","nodeValue","removeChild","dataBindAttributes","paths","listPaths","attribute","j","registerDataBindAttributes","Binding","bindingNode","inputFilters","outputFilters","createBinding","LoopContext","WeakRef","parentLoopContext","currentBinding","parentBinding","walk","callback","results","unshift","bindingsWithSelectElement","createBindings","attributes","getDataBindAttributesById","reduce","BindContent","fragment","isMounted","lastBinding","size","at","importNode","createContent","createLoopContext","mount","beforeNode","insertBefore","afterNode","ListIndex","parentListIndex","position","truncate","reverseIterator","iterator","next","getStatePropertyRefId","listIndexMaxId","_getByRef","target","receiver","lastTrackingStack","lastPattern","addDependentProp","refId","cacheable","setStatePropertyRef","parentValue","getByRef","trackedGetters","trackingStack","pop","setTracking","prop","methodGetByRef","setByRef","addUpdatedStatePropertyRefValue","methodSetByRef","setCacheable","methodSetChargeable","call","resolve","wildcardParentPattern","getAll","_resolve","wildcardPattern","getContextListIndex","walkWildcardPattern","wildardIndexPos","indexPos","parentIndexes","listIndexSet","concat","resultIndexes","resultValues","ResolvedPathInfo","elements","wildcardType","wildcardIndexes","tmpPatternElements","incompleteCount","completeCount","lastPath","getResolvedPathInfo","getListIndex","matchIndexPropertyName","StateHandler","callableApi","apiGetByRef","apiSetByRef","apiSetCacheable","ref","getLastStatePropertyRef","resolvedInfo","trapGet","trapSet","BLANK_LISTINDEXES_SET","buildListIndexTreeSub","listInfos","oldListIndexesSet","oldListIndexesByItem","groupBy","newListIndexesSet","item","oldListIndexes","curListIndex","shift","addUpdatedListIndex","saveListIndexesSet","searchPath","subListIndex","subValue","buildListIndexTree","listInfoSet","extractListIndexes","_extractListIndexes","pos","currentListIndex","resultListIndexes","wildcardParentInfo","loopListIndex","_collectAffectedGetters","refInfo","refListIndex","resultPathInfos","resultRefs","dependentPathInfos","dependentTree","dependentPathInfo","dependentListIndex","updateList","extractlistIndexes","collectAffectedGetters","updateRefs","Updater","processList","updatedProperties","updatedValues","process","waitForQueueEntry","terminate","waitForMainLoopTerminate","Promise","withResolvers","main","waitForComponentInit","promise","performance","mark","updatingCount","measure","console","log","getEntriesByType","clearMeasures","clearMarks","error","updateState","rebuild","retArrayElementBindings","retBindings","processedListIndexes","processedPropertyRefIdsSet","updatedProiperties","updatedRefs","arrayPropertyRefs","arrayElementPropertyRefs","clear","statePropertyRefId","statePropertyRef","elementInfoSet","getBindings","builtStatePropertyRefIds","arrayPropertyRef","parentRefByRefId","statePropertyRefByStatePropertyRefId","parentRefId","parentRefIdKey","refs","parentRef","arrayElementBinding","updatingRefs","updatingRef","arrayElementBindings","ye","Xe","attachShadow","extends","canHaveShadowRoot","mode","adoptedStyleSheets","shadowRootOrDocument","ShadowRoot","getParentShadowRoot","styleSheets","ComponentEngine","stateClass","baseClass","owner","waitForInitialize","stackStructuredPathInfo","stackListIndex","componentClass","Proxy","createUpdater","checkDependentProp","listPath","shadowRoot","asyncSetStatePropertyRef","lastRef","getLoopContexts","saveInfoByListIndexByResolvedPathInfoId","saveInfoByStructuredPathId","createSaveInfo","list","getSaveInfoByStatePropertyRef","saveInfo","saveInfoByListIndex","dependents","getPropertyValue","setPropertyValue","MUSTACHE_REGEXP","MUSTACHE_TYPES","replaceTemplateTagWithComment","createComment","namespaceURI","newTemplate","childNode","querySelectorAll","registerHtml","html","dataset","stack","replaceAll","expr","remain","currentInfo","endTags","lastInfo","replaceMustacheWithTemplateTag","ComponentState","bindParentProperty","propName","defineProperty","bindParentComponent","parent","parentStructiveComponent","getBindingsFromChild","ComponentStateHandler","createComponentClass","componentData","componentConfig","userConfig","Ye","getComponentConfig","$config","wn","Nn","tn","assign","$isStructive","registerStateClass","extendTagName","getBaseClass","componentState","component","createComponentEngine","el","current","isStructive","host","findStructiveParent","define","customElements","getStyleSheetById","getStateClassById","getListPathsSetById","getPathsSetById","currentProto","prototype","getOwnPropertyDescriptors","desc","getPrototypeOf","unescapeEmbed","loadSingleFileComponent","response","fetch","escapeEmbed","querySelector","script","scriptModule","import","default","createSingleFileComponent","registerComponentClass","SLOT_KEY","DEFAULT_LAYOUT","MainWrapper","loadLayout","ok","layoutText","workTemplate","createDocumentFragment","router","ROUTES_KEY","COMPONENTS_KEY","loadFromImportMap","importmap","scriptImportmap","parse","imports","loadImportmap","alias","_config","initialized","defineComponents","singleFileComponents","registerSingleFileComponents","bootstrapStructive","mainWrapper","body","bootstrap"],"mappings":"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"}