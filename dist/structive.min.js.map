{"version":3,"file":"structive.min.js","sources":["../src/WebComponents/getGlobalConfig.ts","../src/utils.ts","../src/Filter/errorMessages.ts","../src/Filter/builtinFilters.ts","../src/GlobalId/generateId.ts","../src/StateClass/registerStateClass.ts","../src/StyleSheet/registerStyleSheet.ts","../src/StyleSheet/regsiterCss.ts","../src/BindingBuilder/resolveNodeFromPath.ts","../src/BindingBuilder/createFilters.ts","../src/DataBinding/BindingNode/BindingNode.ts","../src/DataBinding/BindingNode/BindingNodeAttribute.ts","../src/DataBinding/BindingNode/BindingNodeCheckbox.ts","../src/DataBinding/BindingNode/BindingNodeClassList.ts","../src/DataBinding/BindingNode/BindingNodeClassName.ts","../src/constants.ts","../src/StateProperty/getStructuredPathInfo.ts","../src/PathTree/PathNode.ts","../src/StateProperty/getResolvedPathInfo.ts","../src/StatePropertyRef/StatepropertyRef.ts","../src/StateClass/methods/getContextListIndex.ts","../src/StateClass/methods/getListIndex.ts","../src/StateClass/symbols.ts","../src/StateClass/methods/checkDependency.ts","../src/StateClass/methods/getByRefWritable.ts","../src/StateClass/methods/setByRef.ts","../src/StateClass/methods/getByRefReadonly.ts","../src/StateClass/apis/resolve.ts","../src/StateClass/apis/trackDependency.ts","../src/StateClass/traps/indexByIndexName.ts","../src/StateClass/traps/getWritable.ts","../src/StateClass/apis/getAllWritable.ts","../src/StateClass/apis/connectedCallback.ts","../src/StateClass/apis/disconnectedCallback.ts","../src/StateClass/useWritableStateProxy.ts","../src/StateClass/traps/set.ts","../src/StateClass/methods/setLoopContext.ts","../src/StateClass/methods/asyncSetStatePropertyRef.ts","../src/ListIndex/ListIndex.ts","../src/StateClass/traps/getReadonly.ts","../src/StateClass/apis/getAllReadonly.ts","../src/StateClass/methods/setCacheable.ts","../src/StateClass/createReadonlyStateProxy.ts","../src/Updater/Renderer.ts","../src/ListDiff/ListDiff.ts","../src/Updater/Updater.ts","../src/DataBinding/BindingNode/BindingNodeEvent.ts","../src/DataBinding/BindingNode/BindingNodeBlock.ts","../src/DataBinding/BindingNode/BindingNodeIf.ts","../src/DataBinding/BindingNode/BindingNodeFor.ts","../src/BindingBuilder/getDefaultName.ts","../src/DataBinding/BindingNode/BindingNodeProperty.ts","../src/DataBinding/BindingNode/BindingNodeRadio.ts","../src/DataBinding/BindingNode/BindingNodeStyle.ts","../src/ComponentStateInput/symbols.ts","../src/WebComponents/findStructiveParent.ts","../src/DataBinding/BindingNode/BindingNodeComponent.ts","../src/BindingBuilder/getBindingNodeCreator.ts","../src/DataBinding/BindingState/BindingState.ts","../src/DataBinding/BindingState/BindingStateIndex.ts","../src/BindingBuilder/getBindingStateCreator.ts","../src/BindingBuilder/getNodeType.ts","../src/BindingBuilder/parseBindText.ts","../src/BindingBuilder/removeDataBindAttribute.ts","../src/BindingBuilder/replaceTextNodeFromComment.ts","../src/BindingBuilder/createDataBindAttributes.ts","../src/BindingBuilder/getDataBindText.ts","../src/BindingBuilder/getAbsoluteNodePath.ts","../src/BindingBuilder/getNodesHavingDataBind.ts","../src/BindingBuilder/registerDataBindAttributes.ts","../src/Template/registerTemplate.ts","../src/Template/removeEmptyTextNodes.ts","../src/DataBinding/Binding.ts","../src/LoopContext/createLoopContext.ts","../src/DataBinding/BindContent.ts","../src/WebComponents/loadFromImportMap.ts","../src/ComponentEngine/attachShadow.ts","../src/ComponentEngine/canHaveShadowRoot.ts","../src/ComponentStateBinding/createComponentStateBinding.ts","../src/ComponentStateInput/createComponentStateInput.ts","../src/ComponentStateOutput/createComponentStateOutput.ts","../src/ComponentEngine/ComponentEngine.ts","../src/Template/replaceMustacheWithTemplateTag.ts","../src/Template/replaceTemplateTagWithComment.ts","../src/Template/registerHtml.ts","../src/StateProperty/createAccessorFunctions.ts","../src/PathManager/PathManager.ts","../src/WebComponents/createComponentClass.ts","../src/WebComponents/getComponentConfig.ts","../src/WebComponents/getBaseClass.ts","../src/WebComponents/createSingleFileComponent.ts","../src/WebComponents/loadSingleFileComponent.ts","../src/WebComponents/registerComponentClass.ts","../src/WebComponents/loadImportmap.ts","../src/Router/Router.ts","../src/MainWrapper/MainWrapper.ts","../src/exports.ts","../src/WebComponents/registerSingleFIleComponents.ts","../src/bootstrap.ts"],"sourcesContent":["/**\r\n * getGlobalConfig.ts\r\n *\r\n * Structive全体で利用するグローバル設定（IConfig）を定義・取得するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - globalConfig: デフォルトのグローバル設定値（debug, locale, enableShadowDom等）を定義\r\n * - getGlobalConfig: グローバル設定オブジェクトを返す関数\r\n * - config: getGlobalConfig()のエイリアスとして即時取得用にエクスポート\r\n *\r\n * 設計ポイント:\r\n * - コンポーネント全体で共通利用する設定値を一元管理\r\n * - デフォルト値を明示し、拡張やカスタマイズにも対応しやすい設計\r\n */\r\nimport { IConfig } from \"./types\";\r\n\r\nconst globalConfig: IConfig = {\r\n  \"debug\"                : false,\r\n  \"locale\"               : \"en-US\", // The locale of the component, ex. \"en-US\", default is \"en-US\"\r\n  \"enableShadowDom\"      : true, // Whether to use Shadow DOM or not\r\n  \"enableMainWrapper\"    : true, // Whether to use the main wrapper or not\r\n  \"enableRouter\"         : true, // Whether to use the router or not\r\n  \"autoInsertMainWrapper\": false, // Whether to automatically insert the main wrapper or not\r\n  \"autoInit\"             : true, // Whether to automatically initialize the component or not\r\n  \"mainTagName\"          : \"app-main\", // The tag name of the main wrapper, default is \"app-main\"\r\n  \"routerTagName\"        : \"view-router\", // The tag name of the router, default is \"view-router\"\r\n  \"layoutPath\"           : \"\", // The path to the layout file, default is \"\"\r\n  \"autoLoadFromImportMap\": false, // Whether to automatically load the component from the import map or not\r\n  \"optimizeList\"         : true, // Whether to optimize the list or not\r\n  \"optimizeListElements\" : true, // Whether to optimize the list elements or not\r\n  \"optimizeAccessor\"     : true, // Whether to optimize the accessors or not\r\n};\r\n\r\n\r\nexport function getGlobalConfig():IConfig {\r\n  return globalConfig;\r\n}\r\n\r\nexport const config = getGlobalConfig();\r\n","/**\r\n * エラー生成ユーティリティ\r\n *\r\n * 目的:\r\n * - 例外を構造化メタ情報付きで投げる（コード、コンテキスト、ヒント、ドキュメントURL、重大度、原因）\r\n * - 既存の Error を踏襲しつつ、プロパティに追加情報を付与してデバッグ性を高める\r\n *\r\n * 使用例:\r\n * raiseError({\r\n *   code: 'UPD-001',\r\n *   message: 'Engine not initialized',\r\n *   context: { where: 'Renderer.render' },\r\n *   docsUrl: './docs/error-codes.md#upd'\r\n * });\r\n */\r\nexport type StructiveErrorPayload = {\r\n  code: string;\r\n  message: string;\r\n  context?: Record<string, unknown>;\r\n  hint?: string;\r\n  docsUrl?: string;\r\n  severity?: \"error\" | \"warn\";\r\n  cause?: unknown;\r\n};\r\n\r\nexport function raiseError(message: string): never;\r\nexport function raiseError(payload: StructiveErrorPayload): never;\r\nexport function raiseError(messageOrPayload: string | StructiveErrorPayload): never {\r\n  if (typeof messageOrPayload === \"string\") {\r\n    throw new Error(messageOrPayload);\r\n  }\r\n  const { message, code, context, hint, docsUrl, severity, cause } = messageOrPayload;\r\n  const err = new Error(message);\r\n  // 追加情報はプロパティとして付与（メッセージは既存互換のまま）\r\n  (err as any).code = code;\r\n  if (context) (err as any).context = context;\r\n  if (hint) (err as any).hint = hint;\r\n  if (docsUrl) (err as any).docsUrl = docsUrl;\r\n  if (severity) (err as any).severity = severity;\r\n  if (cause) (err as any).cause = cause;\r\n  throw err;\r\n}\r\n","/**\r\n * errorMessages.ts\r\n *\r\n * フィルタ関数などで利用するエラーメッセージ生成ユーティリティです。\r\n *\r\n * 主な役割:\r\n * - フィルタのオプションや値の型チェックで条件を満たさない場合に、分かりやすいエラーメッセージを投げる\r\n * - 関数名を引数に取り、どのフィルタでエラーが発生したかを明示\r\n *\r\n * 設計ポイント:\r\n * - optionsRequired: オプションが必須なフィルタで未指定時にエラー\r\n * - optionMustBeNumber: オプション値が数値でない場合にエラー\r\n * - valueMustBeNumber: 値が数値でない場合にエラー\r\n * - valueMustBeBoolean: 値がbooleanでない場合にエラー\r\n * - valueMustBeDate: 値がDateでない場合にエラー\r\n */\r\nimport { raiseError } from \"../utils\";\r\n\r\nexport function optionsRequired(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires at least one option`,\r\n    context: { fnName },\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\nexport function optionMustBeNumber(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a number as option`,\r\n    context: { fnName },\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\nexport function valueMustBeNumber(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a number value`,\r\n    context: { fnName },\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\nexport function valueMustBeBoolean(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a boolean value`,\r\n    context: { fnName },\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}\r\n\r\nexport function valueMustBeDate(fnName:string): never {\r\n  raiseError({\r\n    code: \"FLT-202\",\r\n    message: `${fnName} requires a date value`,\r\n    context: { fnName },\r\n    docsUrl: \"./docs/error-codes.md#flt\",\r\n  });\r\n}","/**\r\n * builtinFilters.ts\r\n *\r\n * Structiveで利用可能な組み込みフィルタ関数群の実装ファイルです。\r\n *\r\n * 主な役割:\r\n * - 数値・文字列・日付・真偽値などの変換・比較・整形・判定用フィルタを提供\r\n * - フィルタ名ごとにオプション付きの関数を定義し、バインディング時に柔軟に利用可能\r\n * - input/output両方のフィルタとして共通利用できる設計\r\n *\r\n * 設計ポイント:\r\n * - eq, ne, lt, gt, inc, fix, locale, uc, lc, cap, trim, slice, pad, int, float, round, date, time, ymd, falsy, truthy, defaults, boolean, number, string, null など多彩なフィルタを網羅\r\n * - オプション値の型チェックやエラーハンドリングも充実\r\n * - FilterWithOptions型でフィルタ関数群を一元管理し、拡張も容易\r\n * - builtinFilterFnでフィルタ名・オプションからフィルタ関数を動的に取得可能\r\n */\r\nimport { getGlobalConfig } from \"../WebComponents/getGlobalConfig.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { optionMustBeNumber, optionsRequired, valueMustBeBoolean, valueMustBeDate, valueMustBeNumber } from \"./errorMessages.js\";\r\nimport { FilterWithOptions } from \"./types\";\r\n\r\nconst config = getGlobalConfig();\r\n\r\nconst eq = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('eq');\r\n  return (value: any) => {\r\n    // 型を揃えて比較\r\n    if (typeof value === 'number') {\r\n      const optValue = Number(opt);\r\n      if (isNaN(optValue)) optionMustBeNumber('eq');\r\n      return value === optValue;\r\n    }\r\n    if (typeof value === 'string') {\r\n      return value === opt;\r\n    }\r\n    // その他は厳密等価\r\n    return value === opt;\r\n  }\r\n}\r\n\r\nconst ne = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('ne');\r\n  return (value: any) => {\r\n    // 型を揃えて比較\r\n    if (typeof value === 'number') {\r\n      const optValue = Number(opt);\r\n      if (isNaN(optValue)) optionMustBeNumber('eq');\r\n      return value !== optValue;\r\n    }\r\n    if (typeof value === 'string') {\r\n      return value !== opt;\r\n    }\r\n    // その他は厳密等価\r\n    return value !== opt;\r\n  }\r\n}\r\n\r\nconst not = (options?:string[]) => {\r\n  return (value: any) => {\r\n    if (typeof value !== 'boolean') valueMustBeBoolean('not');\r\n    return !value;\r\n  }\r\n}\r\n\r\nconst lt = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('lt');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('lt');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('lt');\r\n    return value < optValue;\r\n  }\r\n}\r\n\r\nconst le = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('le');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('le');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('le');\r\n    return value <= optValue;\r\n  }\r\n}\r\n\r\nconst gt = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('gt');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('gt');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('gt');\r\n    return value > optValue;\r\n  }\r\n}\r\n\r\nconst ge = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('ge');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('ge');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ge');\r\n    return value >= optValue;\r\n  }\r\n}\r\n\r\nconst inc = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('inc');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('inc');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('inc');\r\n    return value + optValue;\r\n  }\r\n}\r\n\r\nconst dec = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('dec');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('dec');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('dec');\r\n    return value - optValue;\r\n  }\r\n}\r\n\r\nconst mul = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('mul');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('mul');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('mul');\r\n    return value * optValue;\r\n  }\r\n}\r\n\r\nconst div = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('div');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('div');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('div');\r\n    return value / optValue;\r\n  }\r\n}\r\n\r\nconst fix = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('div');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('div');\r\n    return value.toFixed(optValue);\r\n  }\r\n}\r\n\r\nconst locale = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('locale');\r\n    return value.toLocaleString(opt);\r\n  }\r\n}\r\n\r\nconst uc = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().toUpperCase();\r\n  }\r\n}\r\n\r\nconst lc = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().toLowerCase();\r\n  }\r\n}\r\n\r\nconst cap = (options?:string[]) => {\r\n  return (value: any) => {\r\n    const v = value.toString();\r\n    if (v.length === 0) return v;\r\n    if (v.length === 1) return v.toUpperCase();\r\n    return v.charAt(0).toUpperCase() + v.slice(1);\r\n  }\r\n}\r\n\r\nconst trim = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().trim();\r\n  }\r\n}\r\n\r\nconst slice = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('slice');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('slice');\r\n  return (value: any) => {\r\n    return value.toString().slice(optValue);\r\n  }\r\n}\r\n\r\nconst substr = (options?:string[]) => {\r\n  const opt1 = options?.[0] ?? optionsRequired('substr');\r\n  const opt1Value = Number(opt1);\r\n  if (isNaN(opt1Value)) optionMustBeNumber('substr');\r\n  const opt2 = options?.[1] ?? optionsRequired('substr');\r\n  const opt2Value = Number(opt2);\r\n  if (isNaN(opt2Value)) optionMustBeNumber('substr');\r\n  return (value: any) => {\r\n    return value.toString().substr(opt1Value, opt2Value);\r\n  }\r\n}\r\n\r\nconst pad = (options?:string[]) => {\r\n  const opt1 = options?.[0] ?? optionsRequired('pad');\r\n  const opt1Value = Number(opt1);\r\n  if (isNaN(opt1Value)) optionMustBeNumber('pad');\r\n  const opt2 = options?.[1] ?? '0';\r\n  const opt2Value = opt2;\r\n  return (value: any) => {\r\n    return value.toString().padStart(opt1Value, opt2Value);\r\n  }\r\n}\r\n\r\nconst rep = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('rep');\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('rep');\r\n  return (value: any) => {\r\n    return value.toString().repeat(optValue);\r\n  }\r\n}\r\n\r\nconst rev = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return value.toString().split('').reverse().join('');\r\n  }\r\n}\r\n\r\nconst int = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return parseInt(value, 10);\r\n  }\r\n}\r\n\r\nconst float = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return parseFloat(value);\r\n  }\r\n}\r\n\r\nconst round = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('round');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('round');\r\n    return Math.round(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst floor = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('floor');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('floor');\r\n    return Math.floor(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst ceil = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Math.pow(10, Number(opt));\r\n  if (isNaN(optValue)) optionMustBeNumber('ceil');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('ceil');\r\n    return Math.ceil(value * optValue) / optValue;\r\n  }\r\n}\r\n\r\nconst percent = (options?:string[]) => {\r\n  const opt = options?.[0] ?? 0;\r\n  const optValue = Number(opt);\r\n  if (isNaN(optValue)) optionMustBeNumber('percent');\r\n  return (value: any) => {\r\n    if (typeof value !== 'number') valueMustBeNumber('percent');\r\n    return value.toFixed(optValue) + '%';\r\n  }\r\n}\r\n\r\nconst date = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date))  valueMustBeDate('date');\r\n    return value.toLocaleDateString(opt);\r\n  }\r\n}\r\n\r\nconst time = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('time');\r\n    return value.toLocaleTimeString(opt);\r\n  }\r\n}\r\n\r\nconst datetime = (options?:string[]) => {\r\n  const opt = options?.[0] ?? config.locale;\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('datetime');\r\n    return value.toLocaleString(opt);\r\n  }\r\n}\r\n\r\nconst ymd = (options?:string[]) => {\r\n  const opt = options?.[0] ?? '-';\r\n  return (value: any) => {\r\n    if (!(value instanceof Date)) valueMustBeDate('ymd');\r\n    const year = value.getFullYear().toString();\r\n    const month = (value.getMonth() + 1).toString().padStart(2, '0');\r\n    const day = value.getDate().toString().padStart(2, '0');\r\n    return `${year}${opt}${month}${opt}${day}`;\r\n  }\r\n}\r\n\r\nconst falsy = (options?:string[]) => {\r\n  return (value: any) => value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value);\r\n}\r\n\r\nconst truthy = (options?:string[]) => {\r\n  return (value: any) =>value !== false && value !== null && value !== undefined && value !== 0 && value !== '' && !Number.isNaN(value);\r\n}\r\n\r\nconst defaults = (options?:string[]) => {\r\n  const opt = options?.[0] ?? optionsRequired('defaults');\r\n  return (value: any) => {\r\n    if (value === false || value === null || value === undefined || value === 0 || value === '' || Number.isNaN(value)) return opt;\r\n    return value;\r\n  }\r\n}\r\n\r\nconst boolean = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return Boolean(value);\r\n  }\r\n}\r\n\r\nconst number = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return Number(value);\r\n  }\r\n}\r\n\r\nconst string = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return String(value);\r\n  }\r\n}\r\n\r\nconst _null = (options?:string[]) => {\r\n  return (value: any) => {\r\n    return (value === \"\") ? null : value;\r\n  } \r\n}\r\n\r\nconst builtinFilters: FilterWithOptions = {\r\n  \"eq\": eq,\r\n  \"ne\": ne,\r\n  \"not\": not,\r\n\r\n  \"lt\": lt,\r\n  \"le\": le,\r\n  \"gt\": gt,\r\n  \"ge\": ge,\r\n\r\n  \"inc\": inc,\r\n  \"dec\": dec,\r\n  \"mul\": mul,\r\n  \"div\": div,\r\n\r\n  \"fix\": fix,\r\n  \"locale\": locale,\r\n  \"uc\": uc,\r\n  \"lc\": lc,\r\n  \"cap\": cap,\r\n  \"trim\": trim,\r\n  \"slice\": slice,\r\n  \"substr\": substr,\r\n  \"pad\": pad,\r\n  \"rep\": rep,\r\n  \"rev\": rev,\r\n\r\n  \"int\": int,\r\n  \"float\": float,\r\n  \"round\": round,\r\n  \"floor\": floor,\r\n  \"ceil\": ceil,\r\n  \"percent\": percent,\r\n\r\n  \"date\": date,\r\n  \"time\": time,\r\n  \"datetime\": datetime,\r\n  \"ymd\": ymd,\r\n\r\n  \"falsy\": falsy,\r\n  \"truthy\": truthy,\r\n  \"defaults\": defaults,\r\n\r\n  \"boolean\": boolean,\r\n  \"number\": number,\r\n  \"string\": string,\r\n  \"null\": _null,\r\n};\r\n\r\nexport const outputBuiltinFilters = builtinFilters;\r\nexport const inputBuiltinFilters = builtinFilters;\r\n\r\nexport const builtinFilterFn = (name:string, options: string[]) => (filters: FilterWithOptions) => {\r\n  const filter = filters[name];\r\n  if (!filter) {\r\n    raiseError({\r\n      code: \"FLT-201\",\r\n      message: `Filter not found: ${name}`,\r\n      context: { where: 'builtinFilterFn', name },\r\n      docsUrl: \"./docs/error-codes.md#flt\",\r\n    });\r\n  }\r\n  return filter(options);\r\n}\r\n\r\n","\r\nlet id = 0;\r\n\r\nexport function generateId(): number {\r\n  return ++id;\r\n}","/**\r\n * registerStateClass.ts\r\n *\r\n * StateClassインスタンスをIDで登録・取得するための管理モジュールです。\r\n *\r\n * 主な役割:\r\n * - stateClassById: IDをキーにStateClassインスタンスを管理するレコード\r\n * - registerStateClass: 指定IDでStateClassインスタンスを登録\r\n * - getStateClassById: 指定IDのStateClassインスタンスを取得（未登録時はエラーを投げる）\r\n *\r\n * 設計ポイント:\r\n * - グローバルにStateClassインスタンスを一元管理し、ID経由で高速にアクセス可能\r\n * - 存在しないIDアクセス時はraiseErrorで明確な例外を発生\r\n */\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IStructiveState } from \"./types\";\r\n\r\nconst stateClassById: Record<number,IStructiveState> = {};\r\n\r\nexport function registerStateClass(id: number, stateClass: IStructiveState) {\r\n  stateClassById[id] = stateClass;\r\n}\r\n\r\nexport function getStateClassById(id: number): IStructiveState {\r\n  return stateClassById[id] ?? raiseError({\r\n    code: \"STATE-101\",\r\n    message: `StateClass not found: ${id}`,\r\n    context: { where: 'registerStateClass.getStateClassById', stateClassId: id },\r\n    docsUrl: \"./docs/error-codes.md#state\",\r\n  });\r\n}\r\n","/**\r\n * registerStyleSheet.ts\r\n *\r\n * CSSStyleSheetインスタンスをIDで登録・取得するための管理モジュールです。\r\n *\r\n * 主な役割:\r\n * - styleSheetById: IDをキーにCSSStyleSheetインスタンスを管理するレコード\r\n * - registerStyleSheet: 指定IDでCSSStyleSheetインスタンスを登録\r\n * - getStyleSheetById: 指定IDのCSSStyleSheetインスタンスを取得（未登録時はエラーを投げる）\r\n *\r\n * 設計ポイント:\r\n * - グローバルにCSSStyleSheetインスタンスを一元管理し、ID経由で高速にアクセス可能\r\n * - 存在しないIDアクセス時はraiseErrorで明確な例外を発生\r\n */\r\nimport { raiseError } from \"../utils.js\";\r\n\r\nconst styleSheetById: Record<number,CSSStyleSheet> = {};\r\n\r\nexport function registerStyleSheet(id: number, css: CSSStyleSheet) {\r\n  styleSheetById[id] = css;\r\n}\r\n\r\nexport function getStyleSheetById(id: number): CSSStyleSheet {\r\n  return styleSheetById[id] ?? raiseError({\r\n    code: \"CSS-001\",\r\n    message: `Stylesheet not found: ${id}`,\r\n    context: { where: 'registerStyleSheet.getStyleSheetById', styleSheetId: id },\r\n    docsUrl: \"./docs/error-codes.md#css\",\r\n  });\r\n}","/**\r\n * regsiterCss.ts\r\n *\r\n * CSS文字列をCSSStyleSheetとして生成し、IDで登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - CSS文字列からCSSStyleSheetインスタンスを生成\r\n * - registerStyleSheetを利用して、指定IDでCSSStyleSheetを登録\r\n *\r\n * 設計ポイント:\r\n * - styleSheet.replaceSyncで同期的にCSSを適用\r\n * - グローバルなスタイル管理や動的スタイル適用に利用可能\r\n */\r\nimport { registerStyleSheet } from \"./registerStyleSheet.js\";\r\n\r\nexport function registerCss(id: number, css: string) {\r\n  const styleSheet = new CSSStyleSheet();\r\n  styleSheet.replaceSync(css);\r\n  registerStyleSheet(id, styleSheet);\r\n}","import { NodePath } from \"./types\";\r\n\r\n/**\r\n * ルートノードとノードパス（インデックス配列）から、該当するノードを辿って取得するユーティリティ関数。\r\n *\r\n * - NodePathは各階層でのchildNodesのインデックスを表す配列\r\n * - ルートから順にchildNodes[index]を辿り、該当ノードを返す\r\n * - パスが不正な場合やノードが存在しない場合はnullを返す\r\n *\r\n * @param root  探索の起点となるルートノード\r\n * @param path  各階層のインデックス配列（NodePath）\r\n * @returns     パスで指定されたノード、またはnull\r\n */\r\nexport function resolveNodeFromPath(root: Node, path: NodePath): Node | null {\r\n  let node = root;\r\n  if (path.length === 0) return node;\r\n  // path.reduce()だと途中でnullになる可能性があるので、\r\n  for(let i = 0; i < path.length; i++) {\r\n    node = node?.childNodes[path[i]] ?? null;\r\n    if (node === null) break;\r\n  }\r\n  return node;\r\n}","import { FilterFn, Filters, FilterWithOptions } from \"../Filter/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IFilterText } from \"./types\";\r\n\r\n/**\r\n * フィルターテキスト（nameとoptionsを持つ）から、実際のフィルター関数（FilterFn）を生成する。\r\n * \r\n * - textToFilter: フィルターテキストから対応するフィルター関数を取得し、オプションを適用して返す。\r\n * - createFilters: フィルターテキスト配列からフィルター関数配列を生成し、同じ入力にはキャッシュを利用する。\r\n */\r\nfunction textToFilter(filters:FilterWithOptions, text: IFilterText): FilterFn {\r\n  const filter = filters[text.name];\r\n  if (!filter) {\r\n    raiseError({\r\n      code: 'FLT-201',\r\n      message: `Filter not found: ${text.name}`,\r\n      context: { where: 'createFilters.textToFilter', name: text.name },\r\n      docsUrl: './docs/error-codes.md#flt',\r\n    });\r\n  }\r\n  return filter(text.options);\r\n}\r\n\r\nconst cache : Map<IFilterText[], Filters> = new Map();\r\n\r\n/**\r\n * フィルターテキスト配列（texts）からフィルター関数配列（Filters）を生成する。\r\n * すでに同じtextsがキャッシュされていればそれを返す。\r\n * \r\n * @param filters フィルター名→関数の辞書\r\n * @param texts   フィルターテキスト配列\r\n * @returns       フィルター関数配列\r\n */\r\nexport function createFilters(filters:FilterWithOptions, texts: IFilterText[]): Filters {\r\n  let result = cache.get(texts);\r\n  if (typeof result === \"undefined\") {\r\n    result = [];\r\n    for(let i = 0; i < texts.length; i++) {\r\n      result.push(textToFilter(filters, texts[i]));\r\n    }\r\n    cache.set(texts, result);\r\n  }\r\n  return result;\r\n}\r\n","import { Filters } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IReadonlyStateProxy } from \"../../StateClass/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IRenderer } from \"../../Updater/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { IBindingNode } from \"./types\";\r\n\r\n/**\r\n * BindingNodeクラスは、1つのバインディング対象ノード（ElementやTextなど）に対する\r\n * バインディング処理の基底クラスです。\r\n *\r\n * 主な役割:\r\n * - ノード・プロパティ名・フィルタ・デコレータ・バインディング情報の保持\r\n * - バインディング値の更新（update）、値の割り当て（assignValue）のインターフェース提供\r\n * - 複数バインド内容（bindContents）の管理\r\n * - サブクラスでassignValueやupdateElementsを実装し、各種ノード・プロパティごとのバインディング処理を拡張\r\n *\r\n * 設計ポイント:\r\n * - assignValue, updateElementsは未実装（サブクラスでオーバーライド必須）\r\n * - isSelectElement, value, filteredValue, isForなどはサブクラスで用途に応じて拡張\r\n * - フィルタやデコレータ、バインド内容の管理も柔軟に対応\r\n */\r\nexport class BindingNode implements IBindingNode {\r\n  #binding: IBinding;\r\n  #node: Node;\r\n  #name: string;\r\n  #filters: Filters;\r\n  #decorates: string[];\r\n  #bindContents: IBindContent[] = [];\r\n  get node(): Node {\r\n    return this.#node;\r\n  }\r\n  get name(): string {\r\n    return this.#name;\r\n  }\r\n  get subName(): string {\r\n    return this.#name;\r\n  }\r\n  get binding(): IBinding {\r\n    return this.#binding;\r\n  }\r\n  get decorates(): string[] {\r\n    return this.#decorates;\r\n  }\r\n  get filters(): Filters {\r\n    return this.#filters;\r\n  }\r\n  get bindContents(): IBindContent[] {\r\n    return this.#bindContents;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    this.#binding = binding;\r\n    this.#node = node;\r\n    this.#name = name;\r\n    this.#filters = filters;\r\n    this.#decorates = decorates;\r\n  }\r\n  init():void {\r\n    // サブクラスで初期化処理を実装可能\r\n  }\r\n  assignValue(value: any): void {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Not implemented',\r\n      context: { where: 'BindingNode.assignValue', name: this.name },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n    });\r\n  }\r\n  updateElements(listIndexes: IListIndex[], values: any[]) {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Not implemented',\r\n      context: { where: 'BindingNode.updateElements', name: this.name },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n    });\r\n  }\r\n  notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    // サブクラスで親子関係を考慮してバインディングの更新を通知する実装が可能\r\n  }\r\n  applyChange(renderer: IRenderer): void {\r\n    if (renderer.updatedBindings.has(this.binding)) return;\r\n    const filteredValue = this.binding.bindingState.getFilteredValue(renderer.readonlyState, renderer.readonlyHandler);\r\n    this.assignValue(filteredValue);\r\n    renderer.updatedBindings.add(this.binding);\r\n  }\r\n\r\n  get isSelectElement(): boolean {\r\n    return this.node instanceof HTMLSelectElement;\r\n  }\r\n  get value():any {\r\n    return null;\r\n  }\r\n  get filteredValue():any {\r\n    return null;\r\n  }\r\n  get isFor(): boolean {\r\n    return false;\r\n  }\r\n\r\n  get isBlock(): boolean {\r\n    return false;\r\n  }\r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeAttributeクラスは、属性バインディング（例: attr.src, attr.alt など）を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - ノード属性名（subName）を抽出し、値を属性としてElementにセット\r\n * - null/undefined/NaNの場合は空文字列に変換してセット\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - nameから属性名（subName）を抽出（例: \"attr.src\" → \"src\"）\r\n * - assignValueで属性値を常に文字列として設定\r\n * - createBindingNodeAttributeファクトリでフィルタ適用済みインスタンスを生成\r\n */\r\nclass BindingNodeAttribute extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as Element;\r\n    element.setAttribute(this.subName, value.toString());\r\n  }\r\n}\r\n\r\n/**\r\n * 属性バインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeAttributeインスタンスを生成\r\n */\r\nexport const createBindingNodeAttribute: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeAttribute(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * チェックボックス（input[type=\"checkbox\"]）のバインディング。\r\n *\r\n * - 値（配列）に input.value が含まれるかで checked を制御\r\n *\r\n * Throws:\r\n * - BIND-201 Value is not array: 配列以外が渡された\r\n */\r\nclass BindingNodeCheckbox extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Value is not array',\r\n        context: { where: 'BindingNodeCheckbox.update', receivedType: typeof value },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value.map(_val => _val.toString()).includes(element.value);\r\n  }\r\n}\r\n\r\n/**\r\n * チェックボックス用バインディングノード生成ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeCheckboxインスタンスを生成\r\n */\r\nexport const createBindingNodeCheckbox: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeCheckbox(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * class 属性（classList）バインディング。\r\n *\r\n * - 値（配列）を空白区切りで結合して className へ反映\r\n *\r\n * Throws:\r\n * - BIND-201 Value is not array: 配列以外が渡された\r\n */\r\nclass BindingNodeClassList extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (!Array.isArray(value)) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Value is not array',\r\n        context: { where: 'BindingNodeClassList.update', receivedType: typeof value },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    const element = this.node as Element;\r\n    element.className = value.join(\" \");\r\n  }\r\n}\r\n\r\n/**\r\n * classList用バインディングノード生成ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeClassListインスタンスを生成\r\n */\r\nexport const createBindingNodeClassList: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeClassList(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * class の個別クラス名（例: class.active）に対するバインディング。\r\n *\r\n * - name から subName を抽出し、boolean 値で add/remove を切り替え\r\n *\r\n * Throws:\r\n * - BIND-201 Value is not boolean: boolean 以外が渡された\r\n */\r\nclass BindingNodeClassName extends BindingNode {\r\n  #subName: string;\r\n  get subName(): string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (typeof value !== \"boolean\") {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Value is not boolean',\r\n        context: { where: 'BindingNodeClassName.update', receivedType: typeof value },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    const element = this.node as Element;\r\n    if (value) {\r\n      element.classList.add(this.subName);\r\n    } else {\r\n      element.classList.remove(this.subName);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * class名バインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeClassNameインスタンスを生成\r\n */\r\nexport const createBindingNodeClassName: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeClassName(binding, node, name, filterFns, decorates);\r\n  }\r\n","export const DATA_BIND_ATTRIBUTE = \"data-bind\";\r\nexport const COMMENT_EMBED_MARK = \"@@:\"; // 埋め込み変数のマーク\r\nexport const COMMENT_TEMPLATE_MARK = \"@@|\"; // テンプレートのマーク\r\nexport const MAX_WILDCARD_DEPTH = 32; // ワイルドカードの最大深度\r\nexport const WILDCARD = \"*\"; // ワイルドカード\r\nexport const RESERVED_WORD_SET = new Set([\r\n  \"constructor\", \"prototype\", \"__proto__\", \"toString\",\r\n  \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",\r\n  \"watch\", \"unwatch\", \"eval\", \"arguments\",\r\n  \"let\", \"var\", \"const\", \"class\", \"function\",\r\n  \"null\", \"true\", \"false\", \"new\", \"return\",\r\n]);\r\n\r\n","/**\r\n * getStructuredPathInfo.ts\r\n *\r\n * Stateプロパティのパス文字列から、詳細な構造化パス情報（IStructuredPathInfo）を生成・キャッシュするユーティリティです。\r\n *\r\n * 主な役割:\r\n * - パス文字列を分割し、各セグメントやワイルドカード（*）の位置・親子関係などを解析\r\n * - cumulativePaths/wildcardPaths/parentPathなど、パス階層やワイルドカード階層の情報を構造化\r\n * - 解析結果をIStructuredPathInfoとしてキャッシュし、再利用性とパフォーマンスを両立\r\n * - reservedWords（予約語）チェックで安全性を担保\r\n *\r\n * 設計ポイント:\r\n * - パスごとにキャッシュし、同じパスへの複数回アクセスでも高速に取得可能\r\n * - ワイルドカードや親子関係、階層構造を厳密に解析し、バインディングや多重ループに最適化\r\n * - childrenプロパティでパス階層のツリー構造も構築\r\n * - 予約語や危険なパスはraiseErrorで例外を発生\r\n */\r\nimport { RESERVED_WORD_SET } from '../constants.js';\r\nimport { raiseError } from '../utils.js';\r\nimport { IStructuredPathInfo } from './types';\r\n\r\n/**\r\n * プロパティ名に\"constructor\"や\"toString\"などの予約語やオブジェクトのプロパティ名を\r\n * 上書きするような名前も指定できるように、Mapを検討したが、そもそもそのような名前を\r\n * 指定することはないと考え、Mapを使わないことにした。\r\n */\r\nconst _cache: { [key:string]: IStructuredPathInfo } = {};\r\n\r\n/**\r\n * パターン情報を取得します\r\n * @param pattern パターン\r\n * @returns {IPatternInfo} パターン情報\r\n */\r\nclass StructuredPathInfo implements IStructuredPathInfo {\r\n  static id : number = 0;\r\n  id = ++StructuredPathInfo.id;\r\n  sid = this.id.toString();\r\n  pattern;\r\n  pathSegments;\r\n  lastSegment;\r\n  cumulativePaths;\r\n  cumulativePathSet;\r\n  cumulativeInfos;\r\n  cumulativeInfoSet;\r\n  wildcardPaths;\r\n  wildcardPathSet;\r\n  wildcardInfos;\r\n  indexByWildcardPath;\r\n  wildcardInfoSet;\r\n  wildcardParentPaths;\r\n  wildcardParentPathSet;\r\n  wildcardParentInfos;\r\n  wildcardParentInfoSet;\r\n  lastWildcardPath;\r\n  lastWildcardInfo;\r\n  parentPath;\r\n  parentInfo;\r\n  wildcardCount;\r\n  children = {};\r\n\r\n  constructor(pattern: string) {\r\n    const getPattern = (_pattern: string): IStructuredPathInfo => {\r\n      return (pattern === _pattern) ? this : getStructuredPathInfo(_pattern);\r\n    };\r\n    const pathSegments = pattern.split(\".\");\r\n    const cumulativePaths = [];\r\n    const cumulativeInfos: IStructuredPathInfo[] = [];\r\n    const wildcardPaths = [];\r\n    const indexByWildcardPath: Record<string, number> = {};\r\n    const wildcardInfos = [];\r\n    const wildcardParentPaths = [];\r\n    const wildcardParentInfos = [];\r\n    let currentPatternPath = \"\", prevPatternPath = \"\";\r\n    let wildcardCount = 0;\r\n    for(let i = 0; i < pathSegments.length; i++) {\r\n      currentPatternPath += pathSegments[i];\r\n      if (pathSegments[i] === \"*\") {\r\n        wildcardPaths.push(currentPatternPath);\r\n        indexByWildcardPath[currentPatternPath] = wildcardCount;\r\n        wildcardInfos.push(getPattern(currentPatternPath));\r\n        wildcardParentPaths.push(prevPatternPath);\r\n        wildcardParentInfos.push(getPattern(prevPatternPath));\r\n        wildcardCount++;\r\n      }\r\n      cumulativePaths.push(currentPatternPath);\r\n      cumulativeInfos.push(getPattern(currentPatternPath));\r\n      prevPatternPath = currentPatternPath;\r\n      currentPatternPath += \".\";\r\n    }\r\n    const lastWildcardPath = wildcardPaths.length > 0 ? wildcardPaths[wildcardPaths.length - 1] : null;\r\n    const parentPath = cumulativePaths.length > 1 ? cumulativePaths[cumulativePaths.length - 2] : null;\r\n    this.pattern = pattern;\r\n    this.pathSegments = pathSegments;\r\n    this.lastSegment = pathSegments[pathSegments.length - 1];\r\n    this.cumulativePaths = cumulativePaths;\r\n    this.cumulativePathSet = new Set(cumulativePaths);\r\n    this.cumulativeInfos = cumulativeInfos;\r\n    this.cumulativeInfoSet = new Set(cumulativeInfos);\r\n    this.wildcardPaths = wildcardPaths;\r\n    this.wildcardPathSet = new Set(wildcardPaths);\r\n    this.indexByWildcardPath = indexByWildcardPath;\r\n    this.wildcardInfos = wildcardInfos;\r\n    this.wildcardInfoSet = new Set(wildcardInfos);\r\n    this.wildcardParentPaths = wildcardParentPaths;\r\n    this.wildcardParentPathSet = new Set(wildcardParentPaths);\r\n    this.wildcardParentInfos = wildcardParentInfos;\r\n    this.wildcardParentInfoSet = new Set(wildcardParentInfos);\r\n    this.lastWildcardPath = lastWildcardPath;\r\n    this.lastWildcardInfo = lastWildcardPath ? getPattern(lastWildcardPath) : null;\r\n    this.parentPath = parentPath;\r\n    this.parentInfo = parentPath ? getPattern(parentPath) : null;\r\n    this.wildcardCount = wildcardCount;\r\n    if (this.parentInfo) {\r\n      this.parentInfo.children[this.lastSegment] = this;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport function getStructuredPathInfo(structuredPath: string): IStructuredPathInfo {\r\n  if (RESERVED_WORD_SET.has(structuredPath)) {\r\n    raiseError({\r\n      code: 'STATE-202',\r\n      message: `Pattern is reserved word: ${structuredPath}`,\r\n      context: { where: 'getStructuredPathInfo', structuredPath },\r\n      docsUrl: './docs/error-codes.md#state',\r\n    });\r\n  }\r\n  const info = _cache[structuredPath];\r\n  if (typeof info !== \"undefined\") {\r\n    return info;\r\n  }\r\n  return (_cache[structuredPath] = new StructuredPathInfo(structuredPath));\r\n}\r\n","import { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IPathNode } from \"./types\";\r\n\r\nclass NodePath implements IPathNode {\r\n  parentPath: string;\r\n  currentPath: string;\r\n  name: string;\r\n  childNodeByName: Map<string, IPathNode>;\r\n  level: number;\r\n\r\n  constructor(parentPath: string, name: string, level: number) {\r\n    this.parentPath = parentPath;\r\n    this.currentPath = parentPath ? parentPath + \".\" + name : name;\r\n    this.name = name;\r\n    this.level = level;\r\n    this.childNodeByName = new Map<string, IPathNode>();\r\n  }\r\n\r\n  find(segments: string[], segIndex: number = 0): IPathNode | null {\r\n    if (segIndex >= segments.length) {\r\n      return null;\r\n    }\r\n\r\n    const currentSegment = segments[segIndex];\r\n    const childNode = this.childNodeByName.get(currentSegment);\r\n\r\n    if (childNode) {\r\n      if (segIndex === segments.length - 1) {\r\n        return childNode;\r\n      }\r\n      return childNode.find(segments, segIndex + 1);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  appendChild(childName: string): IPathNode {\r\n    let childNode = this.childNodeByName.get(childName);\r\n    if (!childNode) {\r\n      const currentPath = this.parentPath ? this.parentPath + \".\" + this.name : this.name;\r\n      childNode = new NodePath(currentPath, childName, this.level + 1);\r\n      this.childNodeByName.set(childName, childNode);\r\n    }\r\n    return childNode;\r\n  }\r\n}\r\n\r\nexport function createRootNode(): IPathNode {\r\n  return new NodePath(\"\", \"\", 0);\r\n}\r\n\r\nconst cache = new Map<IPathNode, Map<string, IPathNode | null>>();\r\nexport function findPathNodeByPath(rootNode: IPathNode, path: string): IPathNode | null {\r\n  let nodeCache = cache.get(rootNode);\r\n  if (!nodeCache) {\r\n    nodeCache = new Map<string, IPathNode>();\r\n    cache.set(rootNode, nodeCache);\r\n  }\r\n  let cachedNode = nodeCache.get(path) ?? null;\r\n  if (cachedNode) {\r\n    return cachedNode;\r\n  }\r\n  const info = getStructuredPathInfo(path);\r\n  cachedNode = rootNode.find(info.pathSegments);\r\n  nodeCache.set(path, cachedNode);\r\n  return cachedNode;\r\n}\r\n\r\nexport function addPathNode(rootNode: IPathNode, path: string): IPathNode {\r\n  const info = getStructuredPathInfo(path);\r\n  if (info.parentPath === null) {\r\n    return rootNode.appendChild(path);\r\n  } else {\r\n    let parentNode = findPathNodeByPath(rootNode, info.parentPath);\r\n    if (parentNode === null) {\r\n      parentNode = addPathNode(rootNode, info.parentPath);\r\n    }\r\n    return parentNode.appendChild(info.lastSegment);\r\n  }\r\n}\r\n","/**\r\n * getResolvedPathInfo.ts\r\n *\r\n * Stateプロパティ名（パス文字列）から、ワイルドカードやインデックス情報を含む\r\n * 詳細なパス情報（IResolvedPathInfo）を解析・生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - プロパティ名を分解し、ワイルドカードやインデックスの有無・種別を判定\r\n * - context/all/partial/none のワイルドカード種別を自動判定\r\n * - パスごとにキャッシュし、再利用性とパフォーマンスを両立\r\n * - getStructuredPathInfoで構造化パス情報も取得\r\n *\r\n * 設計ポイント:\r\n * - \"constructor\"や\"toString\"などの予約語も扱えるよう、Mapではなくオブジェクトでキャッシュ\r\n * - ワイルドカード（*）や数値インデックスを柔軟に判定し、wildcardIndexesに格納\r\n * - context型は未確定インデックス、all型は全て確定インデックス、partial型は混在を示す\r\n * - ResolvedPathInfoクラスでパス解析・情報保持を一元化\r\n */\r\nimport { IResolvedPathInfo, WildcardType } from './types';\r\nimport { getStructuredPathInfo } from './getStructuredPathInfo.js';\r\n\r\n/**\r\n * プロパティ名に\"constructor\"や\"toString\"などの予約語やオブジェクトのプロパティ名を\r\n * 上書きするような名前も指定できるように、Mapを検討したが、そもそもそのような名前を\r\n * 指定することはないと考え、Mapを使わないことにした。\r\n */\r\nconst _cache: Map<string, IResolvedPathInfo> = new Map();\r\n\r\nclass ResolvedPathInfo implements IResolvedPathInfo {\r\n  static id : number = 0;\r\n  id = ++ResolvedPathInfo.id;\r\n  name;\r\n  elements;\r\n  paths;\r\n  wildcardCount;\r\n  wildcardType;\r\n  wildcardIndexes;\r\n  info;\r\n  constructor(name: string) {\r\n    const elements = name.split(\".\");\r\n    const tmpPatternElements = elements.slice();\r\n    const paths = [];\r\n    let incompleteCount = 0;\r\n    let completeCount = 0;\r\n    let lastPath = \"\";\r\n    let wildcardCount = 0;\r\n    let wildcardType: WildcardType = \"none\";\r\n    let wildcardIndexes: (number | null)[] = [];\r\n    for(let i = 0; i < elements.length; i++) {\r\n      const element = elements[i];\r\n      if (element === \"*\") {\r\n        tmpPatternElements[i] = \"*\";\r\n        wildcardIndexes.push(null);\r\n        incompleteCount++;\r\n        wildcardCount++;\r\n      } else {\r\n        const number = Number(element);\r\n        if (!Number.isNaN(number)) {\r\n          tmpPatternElements[i] = \"*\";\r\n          wildcardIndexes.push(number);\r\n          completeCount++;\r\n          wildcardCount++;\r\n        }\r\n      }\r\n      lastPath += element;\r\n      paths.push(lastPath);\r\n      lastPath += (i < elements.length - 1 ? \".\" : \"\");\r\n    }\r\n    const pattern = tmpPatternElements.join(\".\");\r\n    const info = getStructuredPathInfo(pattern);\r\n    if (incompleteCount > 0 || completeCount > 0) {\r\n      if (incompleteCount === wildcardCount) {\r\n        wildcardType = \"context\";\r\n      } else if (completeCount === wildcardCount) {\r\n        wildcardType = \"all\";\r\n      } else {\r\n        wildcardType = \"partial\";\r\n      }\r\n    }\r\n    this.name = name;\r\n    this.elements = elements;\r\n    this.paths = paths;\r\n    this.wildcardCount = wildcardCount;\r\n    this.wildcardType = wildcardType;\r\n    this.wildcardIndexes = wildcardIndexes;\r\n    this.info = info;\r\n  }\r\n}\r\n\r\nexport function getResolvedPathInfo(name:string):IResolvedPathInfo {\r\n  let nameInfo: IResolvedPathInfo | undefined;\r\n  return _cache.get(name) ?? (_cache.set(name, nameInfo = new ResolvedPathInfo(name)), nameInfo);\r\n}","/**\r\n * StatePropertyRef\r\n *\r\n * 目的:\r\n * - State の構造化パス情報(IStructuredPathInfo)と、任意のリストインデックス(IListIndex)から\r\n *   一意な参照オブジェクト(IStatePropertyRef)を生成・キャッシュする。\r\n * - 同一(info,listIndex)組み合わせに対しては同一インスタンスを返し、比較やMapキーとして安定運用できるようにする。\r\n *\r\n * 実装メモ:\r\n * - key は info.sid と listIndex.sid から合成（listIndex が null の場合は info.sid のみ）\r\n * - listIndex は WeakRef で保持し、GC で消えた場合は LIST-201 を送出\r\n * - キャッシュは listIndex 非 null の場合は WeakMap(listIndex) 配下に、null の場合は Map(info) に保持\r\n */\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IStatePropertyRef } from \"./types\";\r\n\r\nfunction createRefKey(\r\n  info: IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n) {\r\n  return (listIndex == null) ? info.sid : (info.sid + \"#\" + listIndex.sid);\r\n}\r\n\r\nclass StatePropertyRef implements IStatePropertyRef {\r\n  info: IStructuredPathInfo;\r\n  #listIndexRef: WeakRef<IListIndex> | null;\r\n  get listIndex(): IListIndex | null {\r\n    if (this.#listIndexRef === null) return null;\r\n    return this.#listIndexRef.deref() ?? raiseError({\r\n      code: \"LIST-201\",\r\n      message: \"listIndex is null\",\r\n      context: { sid: this.info.sid, key: this.key },\r\n      docsUrl: \"./docs/error-codes.md#list\",\r\n    });\r\n  }\r\n  key: string;\r\n  constructor(\r\n    info: IStructuredPathInfo,\r\n    listIndex: IListIndex | null,\r\n  ) {\r\n    this.info = info;\r\n    this.#listIndexRef = listIndex !== null ? new WeakRef(listIndex) : null;\r\n    this.key = createRefKey(info, listIndex);\r\n  }\r\n}\r\n\r\nconst refByInfoByListIndex = new WeakMap<IListIndex, Record<string, IStatePropertyRef>>();\r\nconst refByInfoByNull: Record<string, IStatePropertyRef> = {};\r\n\r\nexport function getStatePropertyRef(\r\n  info: IStructuredPathInfo,\r\n  listIndex: IListIndex | null,\r\n): IStatePropertyRef {\r\n  let ref = null;\r\n  if (listIndex !== null) {\r\n    let refByInfo = refByInfoByListIndex.get(listIndex);\r\n    if (typeof refByInfo === \"undefined\") {\r\n      refByInfo = {};\r\n      refByInfoByListIndex.set(listIndex, refByInfo);\r\n    }\r\n    ref = refByInfo[info.pattern];\r\n    if (typeof ref === \"undefined\") {\r\n      ref = new StatePropertyRef(info, listIndex);\r\n      refByInfo[info.pattern] = ref;\r\n    }\r\n    return ref;\r\n  } else {\r\n    ref = refByInfoByNull[info.pattern];\r\n    if (typeof ref === \"undefined\") {\r\n      ref = new StatePropertyRef(info, null);\r\n      refByInfoByNull[info.pattern] = ref;\r\n    }\r\n    return ref;\r\n  }\r\n}\r\n","/**\r\n * getContextListIndex.ts\r\n *\r\n * StateClassの内部APIとして、現在のプロパティ参照スコープにおける\r\n * 指定したstructuredPath（ワイルドカード付きプロパティパス）に対応する\r\n * リストインデックス（IListIndex）を取得する関数です。\r\n *\r\n * 主な役割:\r\n * - handlerの最後にアクセスされたStatePropertyRefから、指定パスに対応するリストインデックスを取得\r\n * - ワイルドカード階層に対応し、多重ループやネストした配列バインディングにも利用可能\r\n *\r\n * 設計ポイント:\r\n * - 直近のプロパティ参照情報を取得\r\n * - info.wildcardPathsからstructuredPathのインデックスを特定\r\n * - listIndex.at(index)で該当階層のリストインデックスを取得\r\n * - パスが一致しない場合や参照が存在しない場合はnullを返す\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\nexport function getContextListIndex(\r\n  handler: IStateHandler,\r\n  structuredPath: string\r\n): IListIndex | null {\r\n  const ref = handler.lastRefStack;\r\n  if (ref == null) {\r\n    return null;\r\n  }\r\n  if (ref.info == null) {\r\n    return null;\r\n  }\r\n  if (ref.listIndex == null) {\r\n    return null;\r\n  }\r\n  const index = ref.info.indexByWildcardPath[structuredPath];\r\n  if (typeof index !== \"undefined\") {\r\n    return ref.listIndex.at(index);\r\n  }\r\n  return null;\r\n}\r\n","/**\r\n * getListIndex.ts\r\n *\r\n * StateClassの内部APIとして、パス情報（IResolvedPathInfo）から\r\n * 対応するリストインデックス（IListIndex）を取得する関数です。\r\n *\r\n * 主な役割:\r\n * - パスのワイルドカード種別（context/all/partial/none）に応じてリストインデックスを解決\r\n * - context型は現在のループコンテキストからリストインデックスを取得\r\n * - all型は各階層のリストインデックス集合からインデックスを辿って取得\r\n * - partial型やnone型は未実装またはnullを返す\r\n *\r\n * 設計ポイント:\r\n * - ワイルドカードや多重ループ、ネストした配列バインディングに柔軟に対応\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n * - エラー時はraiseErrorで詳細な例外を投げる\r\n */\r\nimport { IListIndex } from \"../../ListIndex/types\";\r\nimport { IResolvedPathInfo } from \"../../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IStateHandler, IReadonlyStateProxy, IStateProxy } from \"../types\";\r\nimport { getContextListIndex } from \"./getContextListIndex\";\r\n\r\nexport function getListIndex(\r\n  resolvedPath: IResolvedPathInfo, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): IListIndex | null {\r\n  switch (resolvedPath.wildcardType) {\r\n    case \"none\":\r\n      return null;\r\n    case \"context\":\r\n      const lastWildcardPath = resolvedPath.info.lastWildcardPath ?? \r\n        raiseError({\r\n          code: 'STATE-202',\r\n          message: 'lastWildcardPath is null',\r\n          context: { where: 'getListIndex', pattern: resolvedPath.info.pattern },\r\n          docsUrl: '/docs/error-codes.md#state',\r\n        });\r\n      return getContextListIndex(handler, lastWildcardPath) ?? \r\n        raiseError({\r\n          code: 'LIST-201',\r\n          message: `ListIndex not found: ${resolvedPath.info.pattern}`,\r\n          context: { where: 'getListIndex', pattern: resolvedPath.info.pattern },\r\n          docsUrl: '/docs/error-codes.md#list',\r\n        });\r\n    case \"all\":\r\n      let parentListIndex: IListIndex | null = null;\r\n      for(let i = 0; i < resolvedPath.info.wildcardCount; i++) {\r\n        const wildcardParentPattern = resolvedPath.info.wildcardParentInfos[i] ?? \r\n          raiseError({\r\n            code: 'STATE-202',\r\n            message: 'wildcardParentPattern is null',\r\n            context: { where: 'getListIndex', pattern: resolvedPath.info.pattern, index: i },\r\n            docsUrl: '/docs/error-codes.md#state',\r\n          });\r\n        const wildcardRef = getStatePropertyRef(wildcardParentPattern, parentListIndex);\r\n        const listIndexes: IListIndex[] = handler.engine.getListIndexes(wildcardRef) ?? \r\n          raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n            context: { where: 'getListIndex', wildcardParent: wildcardParentPattern.pattern },\r\n            docsUrl: '/docs/error-codes.md#list',\r\n          });\r\n        const wildcardIndex = resolvedPath.wildcardIndexes[i] ?? \r\n          raiseError({\r\n            code: 'STATE-202',\r\n            message: 'wildcardIndex is null',\r\n            context: { where: 'getListIndex', pattern: resolvedPath.info.pattern, index: i },\r\n            docsUrl: '/docs/error-codes.md#state',\r\n          });\r\n        parentListIndex = listIndexes[wildcardIndex] ?? \r\n          raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n            context: { where: 'getListIndex', wildcardParent: wildcardParentPattern.pattern, wildcardIndex },\r\n            docsUrl: '/docs/error-codes.md#list',\r\n          });\r\n      }\r\n      return parentListIndex;\r\n    case \"partial\":\r\n      raiseError({\r\n        code: 'STATE-202',\r\n        message: `Partial wildcard type is not supported yet: ${resolvedPath.info.pattern}`,\r\n        context: { where: 'getListIndex', pattern: resolvedPath.info.pattern },\r\n        docsUrl: '/docs/error-codes.md#state',\r\n      });\r\n  }\r\n}\r\n","\r\nconst symbolName = \"state\";\r\n\r\nexport const GetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.GetByRef`);\r\nexport const SetByRefSymbol            : unique symbol = Symbol.for(`${symbolName}.SetByRef`);\r\nexport const SetCacheableSymbol        : unique symbol = Symbol.for(`${symbolName}.SetCacheable`);\r\nexport const ConnectedCallbackSymbol   : unique symbol = Symbol.for(`${symbolName}.ConnectedCallback`);\r\nexport const DisconnectedCallbackSymbol: unique symbol = Symbol.for(`${symbolName}.DisconnectedCallback`);\r\n","import { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\nexport function checkDependency(\r\n  handler: IStateHandler,\r\n  ref: IStatePropertyRef,\r\n): void {\r\n  // 動的依存関係の登録\r\n  if (handler.refIndex >= 0) {\r\n    const lastInfo = handler.lastRefStack?.info ?? null;\r\n    if (lastInfo !== null) {\r\n      if (handler.engine.pathManager.onlyGetters.has(lastInfo.pattern) &&\r\n        lastInfo.pattern !== ref.info.pattern) {\r\n        handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, ref.info.pattern);\r\n      }\r\n    }\r\n  }\r\n}","/**\r\n * getByRef.ts\r\n *\r\n * StateClassの内部APIとして、構造化パス情報（IStructuredPathInfo）とリストインデックス（IListIndex）を指定して\r\n * 状態オブジェクト（target）から値を取得するための関数（getByRef）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定されたパス・インデックスに対応するState値を取得（多重ループやワイルドカードにも対応）\r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyで値をキャッシュ）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * - 存在しない場合は親infoやlistIndexを辿って再帰的に値を取得\r\n *\r\n * 設計ポイント:\r\n * - handler.engine.trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n * - キャッシュ有効時はrefKeyで値をキャッシュし、取得・再利用を最適化\r\n * - ワイルドカードや多重ループにも柔軟に対応し、再帰的な値取得を実現\r\n * - finallyでキャッシュへの格納を保証\r\n */\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IWritableStateHandler, IWritableStateProxy } from \"../types\";\r\nimport { checkDependency } from \"./checkDependency\";\r\nimport { setStatePropertyRef } from \"./setStatePropertyRef\";\r\n\r\n/**\r\n * 構造化パス情報(info, listIndex)をもとに、状態オブジェクト(target)から値を取得する。\r\n * \r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyでキャッシュ）\r\n * - ネスト・ワイルドカード対応（親infoやlistIndexを辿って再帰的に値を取得）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * \r\n * @param target    状態オブジェクト\r\n * @param info      構造化パス情報\r\n * @param listIndex リストインデックス（多重ループ対応）\r\n * @param receiver  プロキシ\r\n * @param handler   状態ハンドラ\r\n * @returns         対象プロパティの値\r\n */\r\nexport function getByRefWritable(\r\n  target   : Object, \r\n  ref      : IStatePropertyRef,\r\n  receiver : IWritableStateProxy,\r\n  handler  : IWritableStateHandler\r\n): any {\r\n  let value: any;\r\n  const cacheable = handler.engine.pathManager.getters.has(ref.info.pattern);\r\n  if (cacheable) {\r\n    const cacheEntry = handler.engine.cache.get(ref);\r\n    const revision = handler.updater.revisionByUpdatedPath.get(ref.info.pattern);\r\n    if (typeof cacheEntry !== \"undefined\") {\r\n      if (typeof revision === \"undefined\") {\r\n        // 更新なし\r\n        return cacheEntry.value;\r\n      } else {\r\n        if (cacheEntry.version > handler.updater.version) {\r\n          // これは非同期更新が発生した場合にありえる\r\n          return cacheEntry.value;\r\n        }\r\n        if (cacheEntry.version < handler.updater.version || cacheEntry.revision < revision) {\r\n          // 更新あり\r\n        } else {\r\n          return cacheEntry.value;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  checkDependency(handler, ref);\r\n\r\n  // 親子関係のあるgetterが存在する場合は、外部依存から取得\r\n  // ToDo: stateにgetterが存在する（パスの先頭が一致する）場合はgetter経由で取得\r\n  if (handler.engine.stateOutput.startsWith(ref.info) && handler.engine.pathManager.getters.intersection(ref.info.cumulativePathSet).size === 0) {\r\n    return handler.engine.stateOutput.get(ref);\r\n  }\r\n\r\n  // パターンがtargetに存在する場合はgetter経由で取得\r\n  if (ref.info.pattern in target) {\r\n    handler.refIndex++;\r\n    if (handler.refIndex >= handler.refStack.length) {\r\n      handler.refStack.push(null);\r\n    }\r\n    handler.refStack[handler.refIndex] = handler.lastRefStack = ref;\r\n    try {\r\n      return value = Reflect.get(target, ref.info.pattern, receiver);\r\n    } finally {\r\n      handler.refStack[handler.refIndex] = null;\r\n      handler.refIndex--;\r\n      handler.lastRefStack = handler.refIndex >= 0 ? handler.refStack[handler.refIndex] : null;\r\n      handler.engine.cache.set(ref, { value, version: handler.updater.version, revision: handler.updater.revision });\r\n    }\r\n  } else {\r\n    // 存在しない場合は親infoを辿って再帰的に取得\r\n    const parentInfo = ref.info.parentInfo ?? raiseError({\r\n      code: 'STATE-202',\r\n      message: 'propRef.stateProp.parentInfo is undefined',\r\n      context: { where: 'getByRefWritable', refPath: ref.info.pattern },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n    const parentListIndex = parentInfo.wildcardCount < ref.info.wildcardCount ? (ref.listIndex?.parentListIndex ?? null) : ref.listIndex;\r\n    const parentRef = getStatePropertyRef(parentInfo, parentListIndex);\r\n    const parentValue = getByRefWritable(target, parentRef, receiver, handler);\r\n    const lastSegment = ref.info.lastSegment;\r\n    if (lastSegment === \"*\") {\r\n      // ワイルドカードの場合はlistIndexのindexでアクセス\r\n      const index = ref.listIndex?.index ?? raiseError({\r\n        code: 'STATE-202',\r\n        message: 'propRef.listIndex?.index is undefined',\r\n        context: { where: 'getByRefWritable', refPath: ref.info.pattern },\r\n        docsUrl: '/docs/error-codes.md#state',\r\n      });\r\n      return Reflect.get(parentValue, index);\r\n    } else {\r\n      // 通常のプロパティアクセス\r\n      return Reflect.get(parentValue, lastSegment);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * setByRef.ts\r\n *\r\n * StateClassの内部APIとして、構造化パス情報（IStructuredPathInfo）とリストインデックス（IListIndex）を指定して\r\n * 状態オブジェクト（target）に値を設定するための関数（setByRef）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定されたパス・インデックスに対応するState値を設定（多重ループやワイルドカードにも対応）\r\n * - getter/setter経由で値設定時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * - 存在しない場合は親infoやlistIndexを辿って再帰的に値を設定\r\n * - 設定後はengine.updater.addUpdatedStatePropertyRefValueで更新情報を登録\r\n *\r\n * 設計ポイント:\r\n * - ワイルドカードや多重ループにも柔軟に対応し、再帰的な値設定を実現\r\n * - finallyで必ず更新情報を登録し、再描画や依存解決に利用\r\n * - getter/setter経由のスコープ切り替えも考慮した設計\r\n */\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\nimport { getByRefWritable } from \"./getByRefWritable\";\r\nimport { setStatePropertyRef } from \"./setStatePropertyRef\";\r\n\r\nexport function setByRef(\r\n    target   : Object, \r\n    ref      : IStatePropertyRef,\r\n    value    : any, \r\n    receiver : IWritableStateProxy,\r\n    handler  : IWritableStateHandler\r\n): any {\r\n  try {\r\n    // 親子関係のあるgetterが存在する場合は、外部依存を通じて値を設定\r\n    // ToDo: stateにgetterが存在する（パスの先頭が一致する）場合はgetter経由で取得\r\n    if (handler.engine.stateOutput.startsWith(ref.info) && handler.engine.pathManager.setters.intersection(ref.info.cumulativePathSet).size === 0) {\r\n      return handler.engine.stateOutput.set(ref, value);\r\n    }\r\n    if (ref.info.pattern in target) {\r\n      handler.refIndex++;\r\n      if (handler.refIndex >= handler.refStack.length) {\r\n        handler.refStack.push(null);\r\n      }\r\n      handler.refStack[handler.refIndex] = handler.lastRefStack = ref;\r\n      try {\r\n        return Reflect.set(target, ref.info.pattern, value, receiver);\r\n      } finally {\r\n        handler.refStack[handler.refIndex] = null;\r\n        handler.refIndex--;\r\n        handler.lastRefStack = handler.refIndex >= 0 ? handler.refStack[handler.refIndex] : null;\r\n      }\r\n/*\r\n      return setStatePropertyRef(handler, ref, () => {\r\n        return Reflect.set(target, ref.info.pattern, value, receiver);\r\n      });\r\n*/\r\n    } else {\r\n      const parentInfo = ref.info.parentInfo ?? raiseError({\r\n        code: 'STATE-202',\r\n        message: 'propRef.stateProp.parentInfo is undefined',\r\n        context: { where: 'setByRef', refPath: ref.info.pattern },\r\n        docsUrl: '/docs/error-codes.md#state',\r\n      });\r\n      const parentListIndex = parentInfo.wildcardCount < ref.info.wildcardCount ? (ref.listIndex?.parentListIndex ?? null) : ref.listIndex;\r\n      const parentRef = getStatePropertyRef(parentInfo, parentListIndex);\r\n      const parentValue = getByRefWritable(target, parentRef, receiver, handler);\r\n      const lastSegment = ref.info.lastSegment;\r\n      if (lastSegment === \"*\") {\r\n        const index = ref.listIndex?.index ?? raiseError({\r\n          code: 'STATE-202',\r\n          message: 'propRef.listIndex?.index is undefined',\r\n          context: { where: 'setByRef', refPath: ref.info.pattern },\r\n          docsUrl: '/docs/error-codes.md#state',\r\n        });\r\n        return Reflect.set(parentValue, index, value);\r\n      } else {\r\n        return Reflect.set(parentValue, lastSegment, value);\r\n      }\r\n    }\r\n  } finally {\r\n    handler.updater.enqueueRef(ref);\r\n  }\r\n}\r\n","/**\r\n * getByRef.ts\r\n *\r\n * StateClassの内部APIとして、構造化パス情報（IStructuredPathInfo）とリストインデックス（IListIndex）を指定して\r\n * 状態オブジェクト（target）から値を取得するための関数（getByRef）の実装です。\r\n *\r\n * 主な役割:\r\n * - 指定されたパス・インデックスに対応するState値を取得（多重ループやワイルドカードにも対応）\r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyで値をキャッシュ）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * - 存在しない場合は親infoやlistIndexを辿って再帰的に値を取得\r\n *\r\n * 設計ポイント:\r\n * - handler.engine.trackedGettersに含まれる場合はsetTrackingで依存追跡を有効化\r\n * - キャッシュ有効時はrefKeyで値をキャッシュし、取得・再利用を最適化\r\n * - ワイルドカードや多重ループにも柔軟に対応し、再帰的な値取得を実現\r\n * - finallyでキャッシュへの格納を保証\r\n */\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IReadonlyStateProxy, IReadonlyStateHandler } from \"../types\";\r\nimport { checkDependency } from \"./checkDependency\";\r\nimport { setStatePropertyRef } from \"./setStatePropertyRef\";\r\n\r\n/**\r\n * 構造化パス情報(info, listIndex)をもとに、状態オブジェクト(target)から値を取得する。\r\n * \r\n * - 依存関係の自動登録（trackedGetters対応時はsetTrackingでラップ）\r\n * - キャッシュ機構（handler.cacheable時はrefKeyでキャッシュ）\r\n * - ネスト・ワイルドカード対応（親infoやlistIndexを辿って再帰的に値を取得）\r\n * - getter経由で値取得時はSetStatePropertyRefSymbolでスコープを一時設定\r\n * \r\n * @param target    状態オブジェクト\r\n * @param info      構造化パス情報\r\n * @param listIndex リストインデックス（多重ループ対応）\r\n * @param receiver  プロキシ\r\n * @param handler   状態ハンドラ\r\n * @returns         対象プロパティの値\r\n */\r\nexport function getByRefReadonly(\r\n  target   : Object, \r\n  ref      : IStatePropertyRef,\r\n  receiver : IReadonlyStateProxy,\r\n  handler  : IReadonlyStateHandler\r\n): any {\r\n  checkDependency(handler, ref);\r\n\r\n  let value;\r\n  try {\r\n    // キャッシュが有効な場合はrefKeyで値をキャッシュ\r\n    if (handler.cache !== null) {\r\n      value = handler.cache.get(ref);\r\n      if (typeof value !== \"undefined\") {\r\n        return value;\r\n      }\r\n      if (handler.cache.has(ref)) {\r\n        return undefined;\r\n      }\r\n    }\r\n    try {\r\n      // 親子関係のあるgetterが存在する場合は、外部依存から取得\r\n      // ToDo: stateにgetterが存在する（パスの先頭が一致する）場合はgetter経由で取得\r\n      if (handler.engine.stateOutput.startsWith(ref.info) && handler.engine.pathManager.getters.intersection(ref.info.cumulativePathSet).size === 0) {\r\n        return (value = handler.engine.stateOutput.get(ref));\r\n      }\r\n      // パターンがtargetに存在する場合はgetter経由で取得\r\n      if (ref.info.pattern in target) {\r\n        handler.refIndex++;\r\n        if (handler.refIndex >= handler.refStack.length) {\r\n          handler.refStack.push(null);\r\n        }\r\n        handler.refStack[handler.refIndex] = handler.lastRefStack = ref;\r\n        try {\r\n          return (value = Reflect.get(target, ref.info.pattern, receiver));\r\n        } finally {\r\n          handler.refStack[handler.refIndex] = null;\r\n          handler.refIndex--;\r\n          handler.lastRefStack = handler.refIndex >= 0 ? handler.refStack[handler.refIndex] : null;\r\n        }\r\n/*\r\n        return (value = setStatePropertyRef(handler, ref, () => {\r\n          return Reflect.get(target, ref.info.pattern, receiver);\r\n        }));\r\n*/\r\n      } else {\r\n        // 存在しない場合は親infoを辿って再帰的に取得\r\n        const parentInfo = ref.info.parentInfo ?? raiseError({\r\n          code: 'STATE-202',\r\n          message: 'propRef.stateProp.parentInfo is undefined',\r\n          context: { where: 'getByRefReadonly', refPath: ref.info.pattern },\r\n          docsUrl: '/docs/error-codes.md#state',\r\n        });\r\n        const parentListIndex = parentInfo.wildcardCount < ref.info.wildcardCount ? (ref.listIndex?.parentListIndex ?? null) : ref.listIndex;\r\n        const parentRef = getStatePropertyRef(parentInfo, parentListIndex);\r\n        const parentValue = getByRefReadonly(target, parentRef, receiver, handler);\r\n        const lastSegment = ref.info.lastSegment;\r\n        if (lastSegment === \"*\") {\r\n          // ワイルドカードの場合はlistIndexのindexでアクセス\r\n          const index = ref.listIndex?.index ?? raiseError({\r\n            code: 'STATE-202',\r\n            message: 'propRef.listIndex?.index is undefined',\r\n            context: { where: 'getByRefReadonly', refPath: ref.info.pattern },\r\n            docsUrl: '/docs/error-codes.md#state',\r\n          });\r\n          return (value = Reflect.get(parentValue, index));\r\n        } else {\r\n          // 通常のプロパティアクセス\r\n          return (value = Reflect.get(parentValue, lastSegment));\r\n        }\r\n      }\r\n    } finally {\r\n      // キャッシュが有効な場合は取得値をキャッシュ\r\n      if (handler.cache !== null) {\r\n        handler.cache.set(ref, value);\r\n      }\r\n    }\r\n  } finally {\r\n    // リストの場合、リスト差分計算\r\n/*\r\n    if (handler.renderer != null) {\r\n      if (handler.engine.pathManager.lists.has(ref.info.pattern)) {\r\n        handler.renderer.calcListDiff(ref, value as any[] | undefined | null, true);\r\n      }\r\n    }\r\n*/\r\n  }\r\n}\r\n","/**\r\n * resolve.ts\r\n *\r\n * StateClassのAPIとして、パス（path）とインデックス（indexes）を指定して\r\n * Stateの値を取得・設定するための関数（resolve）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列パス（path）とインデックス配列（indexes）から、該当するState値の取得・設定を行う\r\n * - ワイルドカードや多重ループを含むパスにも対応\r\n * - value未指定時は取得（getByRef）、指定時は設定（setByRef）を実行\r\n *\r\n * 設計ポイント:\r\n * - getStructuredPathInfoでパスを解析し、ワイルドカード階層ごとにリストインデックスを解決\r\n * - handler.engine.getListIndexesSetで各階層のリストインデックス集合を取得\r\n * - getByRef/setByRefで値の取得・設定を一元的に処理\r\n * - 柔軟なバインディングやAPI経由での利用が可能\r\n */\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\nimport { getByRefReadonly } from \"../methods/getByRefReadonly\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { getByRefWritable } from \"../methods/getByRefWritable.js\";\r\nimport { SetCacheableSymbol } from \"../symbols.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\n\r\nexport function resolve(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): Function {\r\n  return (path: string, indexes: number[], value?: any): any => {\r\n    const info = getStructuredPathInfo(path);\r\n    const lastInfo = handler.lastRefStack?.info ?? null;\r\n    if (lastInfo !== null && lastInfo.pattern !== info.pattern) {\r\n      // gettersに含まれる場合は依存関係を登録\r\n      if (handler.engine.pathManager.onlyGetters.has(lastInfo.pattern)) {\r\n        handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, info.pattern);\r\n      }\r\n    }\r\n\r\n    if (info.wildcardParentInfos.length > indexes.length) {\r\n      raiseError({\r\n        code: 'STATE-202',\r\n        message: `indexes length is insufficient: ${path}`,\r\n        context: { path, expected: info.wildcardParentInfos.length, received: indexes.length },\r\n        docsUrl: '/docs/error-codes.md#state',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    // ワイルドカード階層ごとにListIndexを解決していく\r\n    let listIndex: IListIndex | null = null;\r\n    for(let i = 0; i < info.wildcardParentInfos.length; i++) {\r\n      const wildcardParentPattern = info.wildcardParentInfos[i];\r\n      const wildcardRef = getStatePropertyRef(wildcardParentPattern, listIndex);\r\n      const listIndexes: IListIndex[] = handler.engine.getListIndexes(wildcardRef) ?? raiseError({\r\n        code: 'LIST-201',\r\n        message: `ListIndexes not found: ${wildcardParentPattern.pattern}`,\r\n        context: { pattern: wildcardParentPattern.pattern },\r\n        docsUrl: '/docs/error-codes.md#list',\r\n        severity: 'error',\r\n      });\r\n      const index = indexes[i];\r\n      listIndex = listIndexes[index] ?? raiseError({\r\n        code: 'LIST-201',\r\n        message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n        context: { pattern: wildcardParentPattern.pattern, index },\r\n        docsUrl: '/docs/error-codes.md#list',\r\n        severity: 'error',\r\n      });\r\n    }\r\n\r\n    // WritableかReadonlyかを判定して適切なメソッドを呼び出す\r\n    const ref = getStatePropertyRef(info, listIndex);\r\n    const hasSetValue = typeof value !== \"undefined\";\r\n    if (SetCacheableSymbol in receiver && \"cache\" in handler) {\r\n      if (!hasSetValue) {\r\n        return getByRefReadonly(target, ref, receiver, handler);\r\n      } else {\r\n        // readonlyなので、setはできない\r\n        raiseError({\r\n          code: 'STATE-202',\r\n          message: `Cannot set value on a readonly proxy: ${path}`,\r\n          context: { path },\r\n          docsUrl: '/docs/error-codes.md#state',\r\n          severity: 'error',\r\n        });\r\n      }\r\n    } else if (!(SetCacheableSymbol in receiver) && !(\"cache\" in handler)) {\r\n      if (!hasSetValue) {\r\n        return getByRefWritable(target, ref, receiver, handler);\r\n      } else {\r\n        setByRef(target, ref, value, receiver, handler);\r\n      }\r\n    } else {\r\n      raiseError({\r\n        code: 'STATE-202',\r\n          message: 'Inconsistent proxy and handler types',\r\n        context: {\r\n          receiverHasSetCacheable: (SetCacheableSymbol in receiver),\r\n          handlerHasCache: (\"cache\" in handler),\r\n        },\r\n        docsUrl: '/docs/error-codes.md#state',\r\n        severity: 'error',\r\n      });\r\n    }\r\n  };\r\n} ","/**\r\n * trackDependency.ts\r\n *\r\n * StateClassのAPIとして、getterチェーン中に参照されたパス間の\r\n * 依存関係を動的に登録するための関数（trackDependency）の実装です。\r\n *\r\n * 主な役割:\r\n * - 現在解決中のStatePropertyRef（lastRefStack）を取得\r\n * - pathManager.gettersに登録されているgetterの場合のみ依存を追跡\r\n * - 自身と同一パターンでない参照に対してaddDynamicDependencyを呼び出す\r\n *\r\n * 設計ポイント:\r\n * - lastRefStackが存在しない場合はSTATE-202エラーを発生させる\r\n * - getter同士の再帰（自己依存）は登録しない\r\n * - 動的依存はpathManagerに集約し、キャッシュの無効化に利用する\r\n */\r\nimport { raiseError } from \"../../utils\";\r\nimport { IStateHandler, IStateProxy } from \"../types\";\r\n\r\n/**\r\n * 現在解決中のgetterから、指定されたパスへの動的依存を登録する関数を返します。\r\n *\r\n * - pathManager.gettersに登録されているgetterのみ依存追跡を行う\r\n * - 自己参照は除外し、異なるパターン間の依存だけを記録\r\n * - 動的依存はpathManager.addDynamicDependencyで集中管理される\r\n *\r\n * @param target   プロキシ対象オブジェクト\r\n * @param prop     アクセスされたプロパティキー\r\n * @param receiver プロキシレシーバ\r\n * @param handler  StateClassハンドラ\r\n * @returns        引数pathで指定されたパターンへの依存を登録する無名関数\r\n */\r\nexport function trackDependency(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IStateProxy,\r\n  handler: IStateHandler\r\n): Function {\r\n  return (path: string): void => {\r\n    const lastInfo = handler.lastRefStack?.info ?? raiseError({\r\n      code: 'STATE-202',\r\n      message: 'Internal error: lastRefStack is null',\r\n      context: { where: 'trackDependency', path },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n    if (handler.engine.pathManager.getters.has(lastInfo.pattern) &&\r\n      lastInfo.pattern !== path) {\r\n      handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, path);\r\n    }\r\n  };\r\n}\r\n","import { MAX_WILDCARD_DEPTH } from \"../../constants\";\r\n\r\n/**\r\n * stackIndexByIndexName\r\n * インデックス名からスタックインデックスへのマッピング\r\n * $1 => 0\r\n * $2 => 1\r\n * :\r\n * ${i + 1} => i\r\n * i < MAX_WILDCARD_DEPTH\r\n */\r\nexport const indexByIndexName: { [key: PropertyKey]: number } = {};\r\nfor (let i = 0; i < MAX_WILDCARD_DEPTH; i++) {\r\n  indexByIndexName[`$${i+1}`] = i;\r\n}\r\n","/**\r\n * get.ts\r\n *\r\n * StateClassのProxyトラップとして、プロパティアクセス時の値取得処理を担う関数（get）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列プロパティの場合、特殊プロパティ（$1〜$9, $resolve, $getAll, $navigate）に応じた値やAPIを返却\r\n * - 通常のプロパティはgetResolvedPathInfoでパス情報を解決し、getListIndexでリストインデックスを取得\r\n * - getByRefで構造化パス・リストインデックスに対応した値を取得\r\n * - シンボルプロパティの場合はhandler.callableApi経由でAPIを呼び出し\r\n * - それ以外はReflect.getで通常のプロパティアクセスを実行\r\n *\r\n * 設計ポイント:\r\n * - $1〜$9は直近のStatePropertyRefのリストインデックス値を返す特殊プロパティ\r\n * - $resolve, $getAll, $navigateはAPI関数やルーターインスタンスを返す\r\n * - 通常のプロパティアクセスもバインディングや多重ループに対応\r\n * - シンボルAPIやReflect.getで拡張性・互換性も確保\r\n */\r\nimport { getRouter } from \"../../Router/Router.js\";\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { IWritableStateHandler, IWritableStateProxy } from \"../types.js\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, SetByRefSymbol } from \"../symbols.js\";\r\nimport { getByRefWritable } from \"../methods/getByRefWritable.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { getAllWritable } from \"../apis/getAllWritable.js\";\r\nimport { connectedCallback } from \"../apis/connectedCallback.js\";\r\nimport { disconnectedCallback } from \"../apis/disconnectedCallback.js\";\r\nimport { trackDependency } from \"../apis/trackDependency.js\";\r\nimport { indexByIndexName } from \"./indexByIndexName.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { resolve } from \"../apis/resolve.js\";\r\n\r\nexport function getWritable(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler : IWritableStateHandler\r\n): any {\r\n  const index = indexByIndexName[prop];\r\n  if (typeof index !== \"undefined\") {\r\n    const listIndex = handler.lastRefStack?.listIndex;\r\n    return listIndex?.indexes[index] ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: `ListIndex not found: ${prop.toString()}`,\r\n      context: { prop: String(prop), indexes: listIndex?.indexes ?? null, index },\r\n      docsUrl: '/docs/error-codes.md#list',\r\n      severity: 'error',\r\n    });\r\n  }\r\n  if (typeof prop === \"string\") {\r\n    if (prop[0] === \"$\") {\r\n      switch (prop) {\r\n        case \"$resolve\":\r\n          return resolve(target, prop, receiver, handler);\r\n        case \"$getAll\":\r\n          return getAllWritable(target, prop, receiver, handler);\r\n        case \"$trackDependency\":\r\n          return trackDependency(target, prop, receiver, handler);\r\n        case \"$navigate\":\r\n          return (to:string) => getRouter()?.navigate(to);\r\n        case \"$component\":\r\n          return handler.engine.owner;\r\n      }\r\n    }\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    const ref = getStatePropertyRef(resolvedInfo.info, listIndex);\r\n    return getByRefWritable(\r\n      target, \r\n      ref,\r\n      receiver,\r\n      handler\r\n    );\r\n\r\n  } else if (typeof prop === \"symbol\") {\r\n    switch (prop) {\r\n      case GetByRefSymbol: \r\n        return (ref: IStatePropertyRef) => \r\n          getByRefWritable(target, ref, receiver, handler);\r\n      case SetByRefSymbol: \r\n        return (ref: IStatePropertyRef, value: any) => \r\n          setByRef(target, ref, value, receiver, handler);\r\n      case ConnectedCallbackSymbol:\r\n        return () => connectedCallback(target, prop, receiver, handler);\r\n      case DisconnectedCallbackSymbol: \r\n        return () => disconnectedCallback(target, prop, receiver, handler);\r\n      default:\r\n        return Reflect.get(\r\n          target, \r\n          prop, \r\n          receiver\r\n        );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * getAllWritable\r\n *\r\n * ワイルドカードを含む State パスから、対象となる全要素を配列で取得する（Writable版）。\r\n * Throws: LIST-201（インデックス未解決）、BIND-201（ワイルドカード情報不整合）\r\n */\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IWritableStateHandler, IWritableStateProxy } from \"../types\";\r\nimport { getContextListIndex } from \"../methods/getContextListIndex\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { resolve } from \"./resolve.js\";\r\n\r\nexport function getAllWritable(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler: IWritableStateHandler\r\n):Function {\r\n    const resolveFn = resolve(target, prop, receiver, handler);\r\n    return (path: string, indexes?: number[]): any[] => {\r\n      const info = getStructuredPathInfo(path);\r\n      const lastInfo = handler.lastRefStack?.info ?? null;\r\n      if (lastInfo !== null && lastInfo.pattern !== info.pattern) {\r\n        // gettersに含まれる場合は依存関係を登録\r\n        if (handler.engine.pathManager.onlyGetters.has(lastInfo.pattern)) {\r\n          handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, info.pattern);\r\n        }\r\n      }\r\n  \r\n      if (typeof indexes === \"undefined\") {\r\n        for(let i = 0; i < info.wildcardInfos.length; i++) {\r\n          const wildcardPattern = info.wildcardInfos[i] ?? raiseError({\r\n            code: 'BIND-201',\r\n            message: 'wildcardPattern is null',\r\n            context: { index: i, infoPattern: info.pattern },\r\n            docsUrl: '/docs/error-codes.md#bind',\r\n            severity: 'error',\r\n          });\r\n          const listIndex = getContextListIndex(handler, wildcardPattern.pattern);\r\n          if (listIndex) {\r\n            indexes = listIndex.indexes;\r\n            break;\r\n          }\r\n        }\r\n        if (typeof indexes === \"undefined\") {\r\n          indexes = [];\r\n        }\r\n      }\r\n      const walkWildcardPattern = (\r\n        wildcardParentInfos: IStructuredPathInfo[],\r\n        wildardIndexPos: number,\r\n        listIndex: IListIndex | null,\r\n        indexes: number[],\r\n        indexPos: number,\r\n        parentIndexes: number[],\r\n        results: number[][]\r\n      ) => {\r\n        const wildcardParentPattern = wildcardParentInfos[wildardIndexPos] ?? null;\r\n        if (wildcardParentPattern === null) {\r\n          results.push(parentIndexes);\r\n          return;\r\n        }\r\n        const wildcardRef = getStatePropertyRef(wildcardParentPattern, listIndex);\r\n        const listIndexes = handler.engine.getListIndexes(wildcardRef) ?? raiseError({\r\n          code: 'LIST-201',\r\n          message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n          context: { pattern: wildcardParentPattern.pattern },\r\n          docsUrl: '/docs/error-codes.md#list',\r\n          severity: 'error',\r\n        });\r\n        const index = indexes[indexPos] ?? null;\r\n        if (index === null) {\r\n          for(let i = 0; i < listIndexes.length; i++) {\r\n            const listIndex = listIndexes[i];\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results);\r\n          }\r\n        } else {\r\n          const listIndex = listIndexes[index] ?? raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n            context: { pattern: wildcardParentPattern.pattern, index },\r\n            docsUrl: '/docs/error-codes.md#list',\r\n            severity: 'error',\r\n          });\r\n          if ((wildardIndexPos + 1) < wildcardParentInfos.length) {\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results\r\n            );\r\n          } else {\r\n            // 最終ワイルドカード層まで到達しているので、結果を確定\r\n            results.push(parentIndexes.concat(listIndex.index));\r\n          }\r\n        }\r\n      }\r\n      const resultIndexes: number[][] = [];\r\n      walkWildcardPattern(\r\n        info.wildcardParentInfos, \r\n        0, \r\n        null, \r\n        indexes, \r\n        0, \r\n        [], \r\n        resultIndexes\r\n      );\r\n      const resultValues: any[] = [];\r\n      for(let i = 0; i < resultIndexes.length; i++) {\r\n        resultValues.push(resolveFn(\r\n          info.pattern,\r\n          resultIndexes[i]\r\n        ));\r\n      }\r\n      return resultValues;\r\n    }\r\n  }","/**\r\n * connectedCallback.ts\r\n *\r\n * StateClassのライフサイクルフック「$connectedCallback」を呼び出すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - オブジェクト（target）に$connectedCallbackメソッドが定義されていれば呼び出す\r\n * - コールバックはtargetのthisコンテキストで呼び出し、IReadonlyStateProxy（receiver）を引数として渡す\r\n * - 非同期関数として実行可能（await対応）\r\n *\r\n * 設計ポイント:\r\n * - Reflect.getで$connectedCallbackプロパティを安全に取得\r\n * - 存在しない場合は何もしない\r\n * - ライフサイクル管理やカスタム初期化処理に利用\r\n */\r\nimport { IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\n\r\nconst CONNECTED_CALLBACK = \"$connectedCallback\";\r\n\r\nexport async function connectedCallback(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler: IWritableStateHandler\r\n):Promise<void> {\r\n  const callback = Reflect.get(target, CONNECTED_CALLBACK);\r\n  if (typeof callback === \"function\") {\r\n    await callback.call(receiver);\r\n  }\r\n}","/**\r\n * disconnectedCallback.ts\r\n *\r\n * StateClassのライフサイクルフック「$disconnectedCallback」を呼び出すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - オブジェクト（target）に$disconnectedCallbackメソッドが定義されていれば呼び出す\r\n * - コールバックはtargetのthisコンテキストで呼び出し、IReadonlyStateProxy（receiver）を引数として渡す\r\n * - 非同期関数として実行可能（await対応）\r\n *\r\n * 設計ポイント:\r\n * - Reflect.getで$disconnectedCallbackプロパティを安全に取得\r\n * - 存在しない場合は何もしない\r\n * - ライフサイクル管理やクリーンアップ処理に利用\r\n */\r\nimport { IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\n\r\nconst DISCONNECTED_CALLBACK = \"$disconnectedCallback\";\r\n\r\nexport async function disconnectedCallback(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IWritableStateProxy,\r\n  handler: IWritableStateHandler\r\n):Promise<void> {\r\n  const callback = Reflect.get(target, DISCONNECTED_CALLBACK);\r\n  if (typeof callback === \"function\") {\r\n    await callback.call(receiver);\r\n  }\r\n}","/**\r\n * createWritableStateProxy.ts\r\n *\r\n * StateClassの「書き込み可能」プロキシを生成するための実装ファイルです。\r\n *\r\n * 主な役割:\r\n * - Stateオブジェクトに対して、書き込み可能なProxyを作成\r\n * - StateHandlerクラスで各種APIやトラップ（get/set）を実装\r\n * - getトラップでバインディングやAPI呼び出し、依存解決などに対応\r\n * - setトラップで値の書き込みや副作用（依存解決・再描画）を一元管理\r\n *\r\n * 設計ポイント:\r\n * - StateHandlerはIWritableStateHandlerを実装し、状態管理やAPI呼び出しの基盤となる\r\n * - callableApiに各種APIシンボルと関数をマッピングし、柔軟なAPI拡張が可能\r\n * - createWritableStateProxyで一貫した生成・利用が可能\r\n * - 依存解決やキャッシュ、ループ・プロパティ参照スコープ管理など多機能な設計\r\n */\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IState, IWritableStateHandler, IWritableStateProxy } from \"./types\";\r\nimport { getWritable as trapGet } from \"./traps/getWritable.js\";\r\nimport { set as trapSet } from \"./traps/set.js\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { setLoopContext } from \"./methods/setLoopContext\";\r\nimport { IUpdater } from \"../Updater/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, SetByRefSymbol } from \"./symbols\";\r\n\r\nconst STACK_DEPTH = 32;\r\n\r\nclass StateHandler implements IWritableStateHandler {\r\n  engine: IComponentEngine;\r\n  refStack: (IStatePropertyRef | null)[] = Array(STACK_DEPTH).fill(null);\r\n  refIndex: number = -1;\r\n  lastRefStack: IStatePropertyRef | null = null;\r\n  loopContext: ILoopContext | null = null;\r\n  updater: IUpdater;\r\n  #setMethods = new Set<PropertyKey>([ GetByRefSymbol, SetByRefSymbol, ConnectedCallbackSymbol, DisconnectedCallbackSymbol ]);\r\n  #setApis = new Set<PropertyKey>([ \"$resolve\", \"$getAll\", \"$trackDependency\", \"$navigate\", \"$component\" ]);\r\n  \r\n  constructor(engine: IComponentEngine, updater: IUpdater) {\r\n    this.engine = engine;\r\n    this.updater = updater;\r\n  }\r\n\r\n  get(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    receiver: IWritableStateProxy\r\n  ): any {\r\n    return trapGet(target, prop, receiver, this);\r\n  }\r\n\r\n  set(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    value   : any, \r\n    receiver: IWritableStateProxy\r\n  ): boolean {\r\n    return trapSet(target, prop, value, receiver, this);\r\n  }\r\n\r\n  has(\r\n    target: Object, \r\n    prop  : PropertyKey\r\n  ): boolean {\r\n    return Reflect.has(target, prop) || this.#setMethods.has(prop) || this.#setApis.has(prop);\r\n  }\r\n}\r\n\r\nexport async function useWritableStateProxy(\r\n  engine: IComponentEngine, \r\n  updater: IUpdater,\r\n  state: Object,\r\n  loopContext: ILoopContext | null,\r\n  callback: (stateProxy: IWritableStateProxy, handler: IWritableStateHandler) => Promise<void>\r\n): Promise<void> {\r\n  const handler = new StateHandler(engine, updater);\r\n  const stateProxy = new Proxy<IState>(state, handler) as IWritableStateProxy;\r\n  return setLoopContext(handler, loopContext, async () => {\r\n    await callback(stateProxy, handler);\r\n  });\r\n}\r\n\r\n","/**\r\n * set.ts\r\n *\r\n * StateClassのProxyトラップとして、プロパティ設定時の値セット処理を担う関数（set）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列プロパティの場合、getResolvedPathInfoでパス情報を解決し、getListIndexでリストインデックスを取得\r\n * - setByRefで構造化パス・リストインデックスに対応した値設定を実行\r\n * - それ以外（シンボル等）の場合はReflect.setで通常のプロパティ設定を実行\r\n *\r\n * 設計ポイント:\r\n * - バインディングや多重ループ、ワイルドカードを含むパスにも柔軟に対応\r\n * - setByRefを利用することで、依存解決や再描画などの副作用も一元管理\r\n * - Reflect.setで標準的なプロパティ設定の互換性も確保\r\n */\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { setByRef } from \"../methods/setByRef.js\";\r\nimport { IStateHandler, IReadonlyStateProxy, IWritableStateProxy, IWritableStateHandler } from \"../types\";\r\n\r\nexport function set(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  value   : any, \r\n  receiver: IWritableStateProxy,\r\n  handler : IWritableStateHandler\r\n): boolean {\r\n  if (typeof prop === \"string\") {\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    const ref = getStatePropertyRef(resolvedInfo.info, listIndex);\r\n    return setByRef(\r\n      target, \r\n      ref,\r\n      value, \r\n      receiver,\r\n      handler\r\n    );\r\n  } else {\r\n    return Reflect.set(\r\n      target, \r\n      prop, \r\n      value, \r\n      receiver\r\n    );\r\n  }\r\n}\r\n","/**\r\n * setLoopContext.ts\r\n *\r\n * StateClassの内部APIとして、ループコンテキスト（ILoopContext）を一時的に設定し、\r\n * 指定した非同期コールバックをそのスコープ内で実行するための関数です。\r\n *\r\n * 主な役割:\r\n * - handler.loopContextにループコンテキストを一時的に設定\r\n * - 既にループコンテキストが設定されている場合はエラーを投げる\r\n * - loopContextが存在する場合はasyncSetStatePropertyRefでスコープを設定しコールバックを実行\r\n * - loopContextがnullの場合はそのままコールバックを実行\r\n * - finallyで必ずloopContextをnullに戻し、スコープ外への影響を防止\r\n *\r\n * 設計ポイント:\r\n * - ループバインディングや多重ループ時のスコープ管理を安全に行う\r\n * - finallyで状態復元を保証し、例外発生時も安全\r\n * - 非同期処理にも対応\r\n */\r\nimport { ILoopContext } from \"../../LoopContext/types\";\r\nimport { raiseError } from \"../../utils\";\r\nimport { IWritableStateHandler } from \"../types\";\r\nimport { asyncSetStatePropertyRef } from \"./asyncSetStatePropertyRef\";\r\n\r\nexport async function setLoopContext(\r\n  handler: IWritableStateHandler,\r\n  loopContext: ILoopContext | null,\r\n  callback: () => Promise<void>\r\n): Promise<void> {\r\n  if (handler.loopContext) {\r\n    raiseError({\r\n      code: 'STATE-301',\r\n      message: 'already in loop context',\r\n      context: { where: 'setLoopContext' },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n  }\r\n  handler.loopContext = loopContext;\r\n  try {\r\n    if (loopContext) {\r\n      await asyncSetStatePropertyRef(handler, loopContext.ref, callback);\r\n    } else {\r\n      await callback();\r\n    }\r\n  } finally {\r\n    handler.loopContext = null;\r\n  }\r\n}\r\n","/**\r\n * asyncSetStatePropertyRef.ts\r\n *\r\n * 状態プロパティ参照のスコープを一時的に設定し、非同期コールバックを実行するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - handlerのstructuredPathInfoStackとlistIndexStackに、infoとlistIndexをpushしてスコープを設定\r\n * - 指定した非同期コールバック（callback）をそのスコープ内で実行\r\n * - callback実行後は必ずpopしてスコープを元に戻す（finallyで保証）\r\n *\r\n * 設計ポイント:\r\n * - 非同期処理中も正しいスコープ情報（パス・リストインデックス）が維持される\r\n * - ネストした非同期処理にも対応可能\r\n * - スコープのpush/popは例外発生時も確実に実行される\r\n */\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IStateHandler } from \"../types\";\r\n\r\n/**\r\n * 状態プロパティ参照のスコープを一時的に設定し、非同期コールバックを実行します。\r\n * \r\n * @param handler   スコープ管理用のハンドラ\r\n * @param info      現在の構造化パス情報\r\n * @param listIndex 現在のリストインデックス（ネスト対応用）\r\n * @param callback  スコープ内で実行する非同期処理\r\n * \r\n * スタックに info と listIndex をpushし、callback実行後に必ずpopします。\r\n * これにより、非同期処理中も正しいスコープ情報が維持されます。\r\n */\r\nexport async function asyncSetStatePropertyRef(\r\n  handler: IStateHandler,\r\n  ref: IStatePropertyRef,\r\n  callback: () => Promise<void>\r\n): Promise<void> {\r\n  handler.refIndex++;\r\n  if (handler.refIndex >= handler.refStack.length) {\r\n    handler.refStack.push(null);\r\n  }\r\n  handler.refStack[handler.refIndex] = handler.lastRefStack = ref;\r\n  try {\r\n    await callback();\r\n  } finally {\r\n    handler.refStack[handler.refIndex] = null;\r\n    handler.refIndex--;\r\n    handler.lastRefStack = handler.refIndex >= 0 ? handler.refStack[handler.refIndex] : null;\r\n  }\r\n}\r\n","import { IListIndex } from \"./types\";\r\n\r\n\r\nlet version = 0;\r\nlet id = 0;\r\nclass ListIndex implements IListIndex {\r\n  #parentListIndex: IListIndex | null = null;\r\n  #pos: number = 0;\r\n  #index: number = 0;\r\n  #version: number;\r\n  #id = ++id;\r\n  #sid = this.#id.toString();\r\n  constructor(parentListIndex: IListIndex | null, index: number) {\r\n    this.#parentListIndex = parentListIndex;\r\n    this.#pos = parentListIndex ? parentListIndex.position + 1 : 0;\r\n    this.#index = index;\r\n    this.#version = version;\r\n  }\r\n\r\n  get parentListIndex() {\r\n    return this.#parentListIndex;\r\n  }\r\n\r\n  get id() {\r\n    return this.#id;\r\n  }\r\n\r\n  get sid() {\r\n    return this.#sid;\r\n  }\r\n\r\n  get position() {\r\n    return this.#pos;\r\n  }\r\n\r\n  get length() {\r\n    return this.#pos + 1;\r\n  }\r\n\r\n  get index() {\r\n    return this.#index;\r\n  }\r\n  set index(value: number) {\r\n    this.#index = value;\r\n    this.#version = ++version;\r\n    this.indexes[this.#pos] = value;\r\n  }\r\n\r\n  get version(): number {\r\n    return this.#version;\r\n  }\r\n\r\n  get dirty(): boolean {\r\n    if (this.#parentListIndex === null) {\r\n      return false;\r\n    } else {\r\n      return this.#parentListIndex.dirty || this.#parentListIndex.version > this.#version;\r\n    }\r\n  }\r\n\r\n  #indexes: number[] | undefined;\r\n  get indexes(): number[] {\r\n    if (this.#parentListIndex === null) {\r\n      if (typeof this.#indexes === \"undefined\") {\r\n        this.#indexes = [this.#index];\r\n      }\r\n    } else {\r\n      if (typeof this.#indexes === \"undefined\" || this.dirty) {\r\n        this.#indexes = [...this.#parentListIndex.indexes, this.#index];\r\n        this.#version = version;\r\n      }\r\n    }\r\n    return this.#indexes;\r\n  }\r\n\r\n  #listIndexes: WeakRef<IListIndex>[] | undefined;\r\n  get listIndexes(): WeakRef<IListIndex>[] {\r\n    if (this.#parentListIndex === null) {\r\n      if (typeof this.#listIndexes === \"undefined\") {\r\n        this.#listIndexes = [new WeakRef(this)];\r\n      }\r\n    } else {\r\n      if (typeof this.#listIndexes === \"undefined\") {\r\n        this.#listIndexes = [...this.#parentListIndex.listIndexes, new WeakRef(this)];\r\n      }\r\n    }\r\n    return this.#listIndexes;\r\n  }\r\n\r\n  get varName(): string {\r\n    return `${this.position + 1}`;\r\n  }\r\n\r\n  at(pos: number): IListIndex | null {\r\n    if (pos >= 0) {\r\n      return this.listIndexes[pos]?.deref() || null;\r\n    } else {\r\n      return this.listIndexes[this.listIndexes.length + pos]?.deref() || null;\r\n    }\r\n  }\r\n}\r\n\r\nexport function createListIndex(parentListIndex: IListIndex | null, index: number): IListIndex {\r\n  return new ListIndex(parentListIndex, index);\r\n}\r\n","/**\r\n * get.ts\r\n *\r\n * StateClassのProxyトラップとして、プロパティアクセス時の値取得処理を担う関数（get）の実装です。\r\n *\r\n * 主な役割:\r\n * - 文字列プロパティの場合、特殊プロパティ（$1〜$9, $resolve, $getAll, $navigate）に応じた値やAPIを返却\r\n * - 通常のプロパティはgetResolvedPathInfoでパス情報を解決し、getListIndexでリストインデックスを取得\r\n * - getByRefで構造化パス・リストインデックスに対応した値を取得\r\n * - シンボルプロパティの場合はhandler.callableApi経由でAPIを呼び出し\r\n * - それ以外はReflect.getで通常のプロパティアクセスを実行\r\n *\r\n * 設計ポイント:\r\n * - $1〜$9は直近のStatePropertyRefのリストインデックス値を返す特殊プロパティ\r\n * - $resolve, $getAll, $navigateはAPI関数やルーターインスタンスを返す\r\n * - 通常のプロパティアクセスもバインディングや多重ループに対応\r\n * - シンボルAPIやReflect.getで拡張性・互換性も確保\r\n */\r\nimport { getRouter } from \"../../Router/Router.js\";\r\nimport { getResolvedPathInfo } from \"../../StateProperty/getResolvedPathInfo.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { getListIndex } from \"../methods/getListIndex.js\";\r\nimport { IReadonlyStateHandler, IReadonlyStateProxy } from \"../types.js\";\r\nimport { GetByRefSymbol, SetCacheableSymbol } from \"../symbols.js\";\r\nimport { getByRefReadonly } from \"../methods/getByRefReadonly.js\";\r\nimport { setCacheable } from \"../methods/setCacheable.js\";\r\nimport { getAllReadonly } from \"../apis/getAllReadonly.js\";\r\nimport { trackDependency } from \"../apis/trackDependency.js\";\r\nimport { indexByIndexName } from \"./indexByIndexName.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { resolve } from \"../apis/resolve.js\";\r\n\r\n\r\nexport function getReadonly(\r\n  target  : Object, \r\n  prop    : PropertyKey, \r\n  receiver: IReadonlyStateProxy,\r\n  handler : IReadonlyStateHandler\r\n): any {\r\n  const index = indexByIndexName[prop];\r\n  if (typeof index !== \"undefined\") {\r\n    const listIndex = handler.lastRefStack?.listIndex;\r\n    return listIndex?.indexes[index] ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: `ListIndex not found: ${prop.toString()}`,\r\n      context: { prop: String(prop), indexes: listIndex?.indexes ?? null, index },\r\n      docsUrl: '/docs/error-codes.md#list',\r\n      severity: 'error',\r\n    });\r\n  }\r\n  if (typeof prop === \"string\") {\r\n    if (prop[0] === \"$\") {\r\n      switch (prop) {\r\n        case \"$resolve\":\r\n          return resolve(target, prop, receiver, handler);\r\n        case \"$getAll\":\r\n          return getAllReadonly(target, prop, receiver, handler);\r\n        case \"$trackDependency\":\r\n          return trackDependency(target, prop, receiver, handler);\r\n        case \"$navigate\":\r\n          return (to:string) => getRouter()?.navigate(to);\r\n        case \"$component\":\r\n          return handler.engine.owner;\r\n      }\r\n    }\r\n    const resolvedInfo = getResolvedPathInfo(prop);\r\n    const listIndex = getListIndex(resolvedInfo, receiver, handler);\r\n    const ref = getStatePropertyRef(resolvedInfo.info, listIndex);\r\n    return getByRefReadonly(\r\n      target, \r\n      ref,\r\n      receiver,\r\n      handler\r\n    );\r\n\r\n  } else if (typeof prop === \"symbol\") {\r\n    switch (prop) {\r\n      case GetByRefSymbol: \r\n        return (ref: IStatePropertyRef) => \r\n          getByRefReadonly(target, ref, receiver, handler);\r\n      case SetCacheableSymbol:\r\n        return (callback: () => void) => setCacheable(handler, callback)\r\n      default:\r\n        return Reflect.get(\r\n          target, \r\n          prop, \r\n          receiver\r\n        );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * getAllReadonly\r\n *\r\n * ワイルドカードを含む State パスから、対象となる全要素を配列で取得する。\r\n * Throws: LIST-201（インデックス未解決）、BIND-201（ワイルドカード情報不整合）\r\n */\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IReadonlyStateProxy, IReadonlyStateHandler } from \"../types\";\r\nimport { getContextListIndex } from \"../methods/getContextListIndex\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { GetByRefSymbol } from \"../symbols.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { resolve } from \"./resolve.js\";\r\n\r\nexport function getAllReadonly(\r\n  target: Object, \r\n  prop: PropertyKey, \r\n  receiver: IReadonlyStateProxy,\r\n  handler: IReadonlyStateHandler\r\n):Function {\r\n    const resolveFn = resolve(target, prop, receiver, handler);\r\n    return (path: string, indexes?: number[]): any[] => {\r\n      const info = getStructuredPathInfo(path);\r\n      const lastInfo = handler.lastRefStack?.info ?? null;\r\n      if (lastInfo !== null && lastInfo.pattern !== info.pattern) {\r\n        // gettersに含まれる場合は依存関係を登録\r\n        if (handler.engine.pathManager.onlyGetters.has(lastInfo.pattern)) {\r\n          handler.engine.pathManager.addDynamicDependency(lastInfo.pattern, info.pattern);\r\n        }\r\n      }\r\n  \r\n      if (typeof indexes === \"undefined\") {\r\n        for(let i = 0; i < info.wildcardInfos.length; i++) {\r\n          const wildcardPattern = info.wildcardInfos[i] ?? raiseError({\r\n            code: 'BIND-201',\r\n            message: 'wildcardPattern is null',\r\n            context: { index: i, infoPattern: info.pattern },\r\n            docsUrl: '/docs/error-codes.md#bind',\r\n            severity: 'error',\r\n          });\r\n          const listIndex = getContextListIndex(handler, wildcardPattern.pattern);\r\n          if (listIndex) {\r\n            indexes = listIndex.indexes;\r\n            break;\r\n          }\r\n        }\r\n        if (typeof indexes === \"undefined\") {\r\n          indexes = [];\r\n        }\r\n      }\r\n      const walkWildcardPattern = (\r\n        wildcardParentInfos: IStructuredPathInfo[],\r\n        wildardIndexPos: number,\r\n        listIndex: IListIndex | null,\r\n        indexes: number[],\r\n        indexPos: number,\r\n        parentIndexes: number[],\r\n        results: number[][]\r\n      ) => {\r\n        const wildcardParentPattern = wildcardParentInfos[wildardIndexPos] ?? null;\r\n        if (wildcardParentPattern === null) {\r\n          results.push(parentIndexes);\r\n          return;\r\n        }\r\n        const wildcardRef = getStatePropertyRef(wildcardParentPattern, listIndex);\r\n        let listIndexes = handler.engine.getListIndexes(wildcardRef);\r\n        if (listIndexes === null) {\r\n          receiver[GetByRefSymbol](wildcardRef);// 依存関係登録のために一度取得\r\n          listIndexes = handler.engine.getListIndexes(wildcardRef);\r\n          if (listIndexes === null) {\r\n            raiseError({\r\n              code: 'LIST-201',\r\n              message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n              context: { pattern: wildcardParentPattern.pattern },\r\n              docsUrl: '/docs/error-codes.md#list',\r\n              severity: 'error',\r\n            });\r\n          }\r\n        }\r\n        const index = indexes[indexPos] ?? null;\r\n        if (index === null) {\r\n          for(let i = 0; i < listIndexes.length; i++) {\r\n            const listIndex = listIndexes[i];\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results);\r\n          }\r\n        } else {\r\n          const listIndex = listIndexes[index] ?? raiseError({\r\n            code: 'LIST-201',\r\n            message: `ListIndex not found: ${wildcardParentPattern.pattern}`,\r\n            context: { pattern: wildcardParentPattern.pattern, index },\r\n            docsUrl: '/docs/error-codes.md#list',\r\n            severity: 'error',\r\n          });\r\n          if ((wildardIndexPos + 1) < wildcardParentInfos.length) {\r\n            walkWildcardPattern(\r\n              wildcardParentInfos, \r\n              wildardIndexPos + 1, \r\n              listIndex, \r\n              indexes, \r\n              indexPos + 1, \r\n              parentIndexes.concat(listIndex.index),\r\n              results\r\n            );\r\n          } else {\r\n            // 最終ワイルドカード層まで到達しているので、結果を確定\r\n            results.push(parentIndexes.concat(listIndex.index));\r\n          }\r\n        }\r\n      }\r\n      const resultIndexes: number[][] = [];\r\n      walkWildcardPattern(\r\n        info.wildcardParentInfos, \r\n        0, \r\n        null, \r\n        indexes, \r\n        0, \r\n        [], \r\n        resultIndexes\r\n      );\r\n      const resultValues: any[] = [];\r\n      for(let i = 0; i < resultIndexes.length; i++) {\r\n        resultValues.push(resolveFn(\r\n          info.pattern,\r\n          resultIndexes[i]\r\n        ));\r\n      }\r\n      return resultValues;\r\n    }\r\n  }","/**\r\n * setCacheable.ts\r\n *\r\n * StateClassの内部APIとして、キャッシュ可能なスコープを一時的に有効化し、\r\n * 指定したコールバック処理をキャッシュ付きで実行するための関数です。\r\n *\r\n * 主な役割:\r\n * - handler.cacheableをtrueに設定し、キャッシュ用オブジェクトを初期化\r\n * - 指定したcallbackをキャッシュ有効状態で実行\r\n * - finallyで必ずcacheableをfalseに戻し、スコープ外ではキャッシュを無効化\r\n *\r\n * 設計ポイント:\r\n * - コールバック実行中のみキャッシュを有効化し、スコープ外への影響を防止\r\n * - finallyで状態復元を保証し、例外発生時も安全\r\n */\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types\";\r\nimport { IReadonlyStateHandler } from \"../types\";\r\n\r\nexport function setCacheable(handler: IReadonlyStateHandler, callback: () => void): void {\r\n  handler.cache = new Map<IStatePropertyRef, any>();\r\n  try {\r\n    callback();\r\n  } finally {\r\n    handler.cache = null;\r\n  }\r\n}\r\n","/**\r\n * createReadonlyStateProxy.ts\r\n *\r\n * StateClass の「読み取り専用」プロキシを生成します。\r\n *\r\n * 主な役割:\r\n * - State オブジェクトに対する読み取り専用の Proxy を作成\r\n * - get トラップでバインディング/API呼び出し/依存解決/レンダラー連携に対応\r\n * - set トラップは常に例外を投げて書き込みを禁止\r\n * - has トラップで内部APIシンボル（GetByRefSymbol, SetCacheableSymbol 等）を公開\r\n *\r\n * Throws:\r\n * - STATE-202 Cannot set property ... of readonly state（set トラップ）\r\n */\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IReadonlyStateHandler, IState, IReadonlyStateProxy } from \"./types\";\r\nimport { getReadonly as trapGet } from \"./traps/getReadonly.js\";\r\nimport { raiseError } from \"../utils\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IRenderer, IUpdater } from \"../Updater/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { GetByRefSymbol, SetCacheableSymbol } from \"./symbols\";\r\n\r\nconst STACK_DEPTH = 32;\r\n\r\nclass StateHandler implements IReadonlyStateHandler {\r\n  engine: IComponentEngine;\r\n  updater: IUpdater;\r\n  cache: Map<IStatePropertyRef, any> | null = null;\r\n  refStack: (IStatePropertyRef | null)[] = Array(STACK_DEPTH).fill(null);\r\n  refIndex: number = -1;\r\n  lastRefStack: IStatePropertyRef | null = null;\r\n  loopContext: ILoopContext | null = null;\r\n  #setMethods = new Set<PropertyKey>([ GetByRefSymbol, SetCacheableSymbol ]);\r\n  #setApis = new Set<PropertyKey>([ \"$resolve\", \"$getAll\", \"$trackDependency\", \"$navigate\", \"$component\" ]);\r\n\r\n  constructor(engine: IComponentEngine, updater: IUpdater) {\r\n    this.engine = engine;\r\n    this.updater = updater;\r\n  }\r\n\r\n  get(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    receiver: IReadonlyStateProxy\r\n  ): any {\r\n    return trapGet(target, prop, receiver, this);\r\n  }\r\n\r\n  set(\r\n    target  : Object, \r\n    prop    : PropertyKey, \r\n    value   : any, \r\n    receiver: IReadonlyStateProxy\r\n  ): boolean {\r\n    raiseError({\r\n      code: 'STATE-202',\r\n      message: `Cannot set property ${String(prop)} of readonly state`,\r\n      context: { where: 'createReadonlyStateProxy.set', prop: String(prop) },\r\n  docsUrl: './docs/error-codes.md#state',\r\n    });\r\n  }\r\n\r\n  has(\r\n    target: Object, \r\n    prop  : PropertyKey\r\n  ): boolean {\r\n    return Reflect.has(target, prop) || this.#setMethods.has(prop) || this.#setApis.has(prop);\r\n  }\r\n}\r\n\r\nexport function createReadonlyStateHandler(engine: IComponentEngine, updater: IUpdater): IReadonlyStateHandler {\r\n  return new StateHandler(engine, updater);\r\n}\r\n\r\nexport function createReadonlyStateProxy(\r\n  state: Object,\r\n  handler: IReadonlyStateHandler,\r\n): IReadonlyStateProxy {\r\n  return new Proxy<IState>(state, handler) as IReadonlyStateProxy;\r\n}\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { WILDCARD } from \"../constants\";\r\nimport { IBinding } from \"../DataBinding/types\";\r\nimport { calcListDiff } from \"../ListDiff/ListDiff\";\r\nimport { IListDiff } from \"../ListDiff/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { findPathNodeByPath } from \"../PathTree/PathNode\";\r\nimport { IPathNode } from \"../PathTree/types\";\r\nimport { createReadonlyStateHandler, createReadonlyStateProxy } from \"../StateClass/createReadonlyStateProxy\";\r\nimport { GetByRefSymbol, SetCacheableSymbol } from \"../StateClass/symbols\";\r\nimport { IReadonlyStateHandler, IReadonlyStateProxy } from \"../StateClass/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IRenderer, IUpdater } from \"./types\";\r\n\r\n/**\r\n * Renderer は、State の変更（参照 IStatePropertyRef の集合）に対応して、\r\n * PathTree を辿りつつ各 Binding（IBinding）へ applyChange を委譲するコーディネータです。\r\n *\r\n * 主な役割\r\n * - reorderList: 要素単位の並べ替え要求を収集し、親リスト単位の差分（IListDiff）へ変換して適用\r\n * - render: エントリポイント。ReadonlyState を生成し、reorder → 各 ref の描画（renderItem）の順で実行\r\n * - renderItem: 指定 ref に紐づく Binding を更新し、静的依存（子 PathNode）と動的依存を再帰的に辿る\r\n * - calcListDiff: リスト参照に対し旧値/新値/旧インデックスから差分を計算し、必要であれば保存\r\n *\r\n * コントラクト\r\n * - Binding#applyChange(renderer): 変更があった場合は renderer.updatedBindings に自分自身を追加すること\r\n * - engine.saveListAndListIndexes(ref, newValue, newIndexes): リストの論理的状態を最新に保持すること\r\n * - readonlyState[GetByRefSymbol](ref): ref の新しい値（読み取り専用ビュー）を返すこと\r\n *\r\n * スレッド/再入\r\n * - 同期実行前提。calcListDiff 呼び出し中の再帰などに備えて、#listDiffByRef には一時的に null を格納\r\n *\r\n * 代表的な例外\r\n * - UPD-001/002: Engine/ReadonlyState の未初期化\r\n * - UPD-003/004/005/006: ListIndex/ParentInfo/OldList* の不整合や ListDiff 未生成\r\n * - PATH-101: PathNode が見つからない\r\n */\r\nclass Renderer implements IRenderer {\r\n  /**\r\n   * このレンダリングサイクルで「変更あり」となった Binding の集合。\r\n   * 注意: 実際に追加するのは各 binding.applyChange 実装側の責務。\r\n   */\r\n  #updatedBindings: Set<IBinding> = new Set();\r\n  /**\r\n   * 二重適用を避けるために処理済みとした参照。\r\n   * renderItem の再帰や依存関係の横断時に循環/重複を防ぐ。\r\n   */\r\n  #processedRefs: Set<IStatePropertyRef> = new Set();\r\n  /**\r\n   * レンダリング対象のエンジン。state, pathManager, bindings などのファサード。\r\n   */\r\n  #engine: IComponentEngine;\r\n  /**\r\n   * createReadonlyStateProxy により生成される読み取り専用ビュー。render 実行中のみ非 null。\r\n   */\r\n  #readonlyState: IReadonlyStateProxy | null = null;\r\n\r\n  #readonlyHandler : IReadonlyStateHandler | null = null;\r\n  /**\r\n   * リスト参照ごとの差分キャッシュ。\r\n   * 値の意味:\r\n   * - undefined: まだ未計算\r\n   * - null: 計算中（再入保護）\r\n   * - IListDiff: 計算済み\r\n   */\r\n  #listDiffByRef: Map<IStatePropertyRef, IListDiff | null> = new Map();\r\n  /**\r\n   * 親リスト参照ごとに「要素の新しい並び位置」を記録するためのインデックス配列。\r\n   * reorderList で収集し、後段で仮の IListDiff を生成するために用いる。\r\n   */\r\n  #reorderIndexesByRef: Map<IStatePropertyRef, number[]> = new Map();\r\n\r\n  #updater: IUpdater;\r\n\r\n  constructor(engine: IComponentEngine, updater: IUpdater) {\r\n    this.#engine = engine;\r\n    this.#updater = updater;\r\n  }\r\n\r\n  /**\r\n   * このサイクル中に更新された Binding の集合を返す（読み取り専用的に使用）。\r\n   */\r\n  get updatedBindings(): Set<IBinding> {\r\n    return this.#updatedBindings;\r\n  }\r\n\r\n  /**\r\n   * 既に処理済みの参照集合を返す。二重適用の防止に利用する。\r\n   */\r\n  get processedRefs(): Set<IStatePropertyRef> {\r\n    return this.#processedRefs;\r\n  }\r\n\r\n  /**\r\n   * 読み取り専用 State ビューを取得する。render 実行中でなければ例外。\r\n   * Throws: UPD-002\r\n   */\r\n  get readonlyState(): IReadonlyStateProxy {\r\n    if (!this.#readonlyState) {\r\n      raiseError({\r\n        code: \"UPD-002\",\r\n        message: \"ReadonlyState not initialized\",\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n    }\r\n    return this.#readonlyState;\r\n  }\r\n\r\n  get readonlyHandler(): IReadonlyStateHandler {\r\n    if (!this.#readonlyHandler) {\r\n      raiseError({\r\n        code: \"UPD-002\",\r\n        message: \"ReadonlyHandler not initialized\",\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n    }\r\n    return this.#readonlyHandler;\r\n  }\r\n\r\n  /**\r\n   * バッキングエンジンを取得する。未初期化の場合は例外。\r\n   * Throws: UPD-001\r\n   */\r\n  get engine(): IComponentEngine {\r\n    if (!this.#engine) {\r\n      raiseError({\r\n        code: \"UPD-001\",\r\n        message: \"Engine not initialized\",\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n    }\r\n    return this.#engine;\r\n  }\r\n\r\n  /**\r\n   * リスト要素の並び替え要求（要素単位）を収集し、対応するリスト（親Ref）に対して\r\n   * 位置変更（changeIndexes）や上書き（overwrites）を含む仮の ListDiff を生成して描画します。\r\n   *\r\n   * ポリシー\r\n   * - 受け取った items は「リスト要素の ref」。親リストの ref を導出して集約する。\r\n   * - 仮の IListDiff を構築し engine.saveListAndListIndexes に保存した後、親リストの PathNode から描画を再入する。\r\n   * - 既に lists に登録されているパターンは親リストとして扱い、要素→親の導出は行わない。\r\n   *\r\n   * Throws:\r\n   * - UPD-003: listIndex の不足\r\n   * - UPD-004: parentInfo 不整合 / 値に対応する旧インデックスが見つからない\r\n   * - UPD-005: oldListValue / oldListIndexes 欠落\r\n   * - PATH-101: 親リストの PathNode 未検出\r\n   */\r\n  reorderList(items: IStatePropertyRef[]): void {\r\n    const listRefs = new Set<IStatePropertyRef>();\r\n    for(let i = 0; i < items.length; i++) {\r\n      const ref = items[i];\r\n      if( this.engine.pathManager.lists.has(ref.info.pattern) ) {\r\n        listRefs.add(ref);\r\n        continue;\r\n      }\r\n      if (!this.engine.pathManager.elements.has(ref.info.pattern)) {\r\n        continue; // elements に登録されていないパスはスキップ\r\n      }\r\n      // リスト要素を処理済みに追加\r\n      this.#processedRefs.add(ref);\r\n      if (ref.info.parentInfo === null) {\r\n        raiseError({\r\n          code: \"UPD-004\",\r\n          message: `ParentInfo is null for ref: ${ref.key}`,\r\n          context: { refKey: ref.key, pattern: ref.info.pattern },\r\n          docsUrl: \"./docs/error-codes.md#upd\",\r\n        });\r\n      }\r\n      const listRef = getStatePropertyRef(ref.info.parentInfo, ref.listIndex?.at(-2) || null);\r\n      if (listRefs.has(listRef)) {\r\n        // リストの差分計算は後続のcalcListDiffで行うので、リオーダーのための計算はスキップ\r\n        continue;\r\n      }\r\n      let indexes = this.#reorderIndexesByRef.get(listRef);\r\n      if (typeof indexes === \"undefined\") {\r\n        indexes = [];\r\n        this.#reorderIndexesByRef.set(listRef, indexes);\r\n      }\r\n      const listIndex = ref.listIndex ?? raiseError({\r\n        code: \"UPD-003\",\r\n        message: `ListIndex is null for ref: ${ref.key}`,\r\n        context: { refKey: ref.key, pattern: ref.info.pattern },\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n      indexes.push(listIndex.index);\r\n    }\r\n    for(const [ listRef, indexes ] of this.#reorderIndexesByRef) {\r\n      this.#listDiffByRef.set(listRef, null); // calcListDiff中に再帰的に呼ばれた場合に備えてnullをセットしておく\r\n      // listRefのリスト要素をindexesの順に並び替える\r\n      try {\r\n        const newListValue = this.readonlyState[GetByRefSymbol](listRef);\r\n        const { listClone: oldListValue, listIndexes: oldListIndexes } = this.engine.getListAndListIndexes(listRef);\r\n        if (oldListValue == null || oldListIndexes == null) {\r\n          raiseError({\r\n            code: \"UPD-005\",\r\n            message: `OldListValue or OldListIndexes is null for ref: ${listRef.key}`,\r\n            context: { refKey: listRef.key, pattern: listRef.info.pattern },\r\n            docsUrl: \"./docs/error-codes.md#upd\",\r\n          });\r\n        }\r\n        const listDiff: IListDiff = {\r\n          oldListValue: oldListValue,\r\n          newListValue: newListValue,\r\n          oldIndexes: oldListIndexes,\r\n          newIndexes: Array.from(oldListIndexes),\r\n          changeIndexes: new Set(),\r\n          overwrites: new Set(),\r\n        };\r\n        for(let i = 0; i < indexes.length; i++) {\r\n          const index = indexes[i];\r\n          const elementValue = listDiff.newListValue?.[index];\r\n          const oldIndex = listDiff.oldListValue?.indexOf(elementValue) ?? -1;\r\n          if (oldIndex === -1) {\r\n            listDiff.overwrites?.add(listDiff.newIndexes[index]);\r\n          } else {\r\n            const listIndex = listDiff.oldIndexes?.[oldIndex] ?? raiseError({\r\n              code: \"UPD-004\",\r\n              message: `ListIndex not found for value: ${elementValue}`,\r\n              context: { refKey: listRef.key, pattern: listRef.info.pattern },\r\n              docsUrl: \"./docs/error-codes.md#upd\",\r\n            });\r\n            listIndex.index = index;\r\n            listDiff.newIndexes[index] = listIndex;\r\n            listDiff.changeIndexes?.add(listIndex);\r\n          }\r\n        }\r\n        this.#listDiffByRef.set(listRef, listDiff);\r\n        // 並べ替え（および上書き）が発生したので親リストの新状態とインデックスを保存\r\n        this.engine.saveListAndListIndexes(listRef, newListValue ?? null, listDiff.newIndexes);\r\n\r\n        const node = findPathNodeByPath(this.#engine.pathManager.rootNode, listRef.info.pattern);\r\n        if (node === null) {\r\n          raiseError({\r\n            code: \"PATH-101\",\r\n            message: `PathNode not found: ${listRef.info.pattern}`,\r\n            context: { pattern: listRef.info.pattern },\r\n            docsUrl: \"./docs/error-codes.md#path\",\r\n          });\r\n        }\r\n        // 親リスト単位で描画を再開する\r\n        this.renderItem(listRef, node);\r\n      } finally {\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * レンダリングのエントリポイント。ReadonlyState を生成し、\r\n   * 並べ替え処理→各参照の描画の順に処理します。\r\n   *\r\n   * 注意\r\n   * - readonlyState はこのメソッドのスコープ内でのみ有効。\r\n   * - SetCacheableSymbol により参照解決のキャッシュをまとめて有効化できる。\r\n   */\r\n  render(items: IStatePropertyRef[]): void {\r\n    this.#listDiffByRef.clear();\r\n    this.#reorderIndexesByRef.clear();\r\n    this.#processedRefs.clear();\r\n    this.#updatedBindings.clear();\r\n\r\n    // 実際のレンダリングロジックを実装\r\n    this.#readonlyHandler = createReadonlyStateHandler(this.#engine, this.#updater);\r\n    const readonlyState = this.#readonlyState = createReadonlyStateProxy(this.#engine.state, this.#readonlyHandler);\r\n    try {\r\n      readonlyState[SetCacheableSymbol](() => {\r\n        // まずはリストの並び替えを処理\r\n        this.reorderList(items);\r\n\r\n        for(let i = 0; i < items.length; i++) {\r\n          const ref = items[i];\r\n          const node = findPathNodeByPath(this.#engine.pathManager.rootNode, ref.info.pattern);\r\n          if (node === null) {\r\n            raiseError({\r\n              code: \"PATH-101\",\r\n              message: `PathNode not found: ${ref.info.pattern}`,\r\n              context: { pattern: ref.info.pattern },\r\n              docsUrl: \"./docs/error-codes.md#path\",\r\n            });\r\n          }\r\n          this.renderItem(ref, node);\r\n        }\r\n      });\r\n\r\n    } finally {\r\n      this.#readonlyState = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 参照 ref の旧値/新値と保存済みインデックスから ListDiff を計算し、\r\n   * 変更があれば engine.saveListAndListIndexes に保存します。\r\n  *\r\n  * 引数\r\n  * - ref: 対象のリスト参照\r\n  * - _newListValue: isNewValue=true のときのみ使用する、呼び出し側で提供された新リスト値\r\n  * - isNewValue: true の場合、_newListValue を新値とみなす。false の場合は readonlyState から取得\r\n  *\r\n  * メモ\r\n  * - #listDiffByRef[ref] が undefined の場合にのみ計算を行い、差分をキャッシュする\r\n  * - old/new 値の参照比較で異なる場合に限り saveListAndListIndexes を呼び出す\r\n   */\r\n  calcListDiff(ref: IStatePropertyRef, _newListValue: any[] | undefined | null = undefined, isNewValue: boolean = false): IListDiff | null {\r\n    let listDiff = this.#listDiffByRef.get(ref);\r\n    if (typeof listDiff === \"undefined\") {\r\n      this.#listDiffByRef.set(ref, null); // calcListDiff中に再帰的に呼ばれた場合に備えてnullをセットしておく\r\n      const { list: oldListValue, listIndexes: oldListIndexes } = this.engine.getListAndListIndexes(ref);\r\n      let newListValue = isNewValue ? _newListValue : this.readonlyState[GetByRefSymbol](ref);\r\n      listDiff = calcListDiff(ref.listIndex, oldListValue, newListValue, oldListIndexes);\r\n      this.#listDiffByRef.set(ref, listDiff);\r\n      if (oldListValue !== newListValue) {\r\n        this.engine.saveListAndListIndexes(ref, newListValue, listDiff.newIndexes);\r\n      }\r\n    }\r\n    return listDiff;\r\n  }\r\n\r\n  /**\r\n   * 単一の参照 ref と対応する PathNode を描画します。\r\n   *\r\n   * - まず自身のバインディング適用\r\n   * - 次に静的依存（ワイルドカード含む）\r\n   * - 最後に動的依存（ワイルドカードは階層的に展開）\r\n   *\r\n   * 静的依存（子ノード）\r\n   * - 子名が WILDCARD の場合: calcListDiff の adds を利用して各リスト要素に対し再帰描画\r\n   * - それ以外: 親の listIndex を引き継いで子参照を生成して再帰描画\r\n   *\r\n   * 動的依存\r\n   * - pathManager.dynamicDependencies に登録されたパスを基に、ワイルドカードを展開しつつ描画を再帰\r\n   *\r\n   * Throws\r\n   * - UPD-006: WILDCARD 分岐で ListDiff が未計算（null）の場合\r\n   * - PATH-101: 動的依存の PathNode 未検出\r\n   */\r\n  renderItem(\r\n    ref: IStatePropertyRef,\r\n    node: IPathNode,\r\n  ): void {\r\n    if (this.processedRefs.has(ref)) {\r\n      return; // すでに処理済みのRef情報はスキップ\r\n    }\r\n    this.processedRefs.add(ref);\r\n\r\n    // バインディングに変更を適用する\r\n    // 変更があったバインディングは updatedBindings に追加する（applyChange 実装の責務）\r\n    const bindings = this.#engine.getBindings(ref);\r\n    for(let i = 0; i < bindings.length; i++) {\r\n      const binding = bindings[i];\r\n      if (this.updatedBindings.has(binding)) {\r\n        continue; // すでに更新済みのバインディングはスキップ\r\n      }\r\n      binding.applyChange(this);\r\n    }\r\n\r\n    // 静的な依存関係を辿る\r\n    for(const [ name, childNode ] of node.childNodeByName) {\r\n      const childInfo = getStructuredPathInfo(childNode.currentPath);\r\n      if (name === WILDCARD) {\r\n        const diff = this.calcListDiff(ref);\r\n        if (diff === null) {\r\n          raiseError({\r\n            code: \"UPD-006\",\r\n            message: \"ListDiff is null during renderItem\",\r\n            context: { refKey: ref.key, pattern: ref.info.pattern },\r\n            docsUrl: \"./docs/error-codes.md#upd\",\r\n          });\r\n        }\r\n        for(const listIndex of diff.adds ?? []) {\r\n          const childRef = getStatePropertyRef(childInfo, listIndex);\r\n          this.renderItem(childRef, childNode);\r\n        }\r\n      } else {\r\n        const childRef = getStatePropertyRef(childInfo, ref.listIndex);\r\n        this.renderItem(childRef, childNode);\r\n      }\r\n    }\r\n\r\n    // 動的な依存関係を辿る\r\n    const deps = this.#engine.pathManager.dynamicDependencies.get(ref.info.pattern);\r\n    if (deps) {\r\n      for(const depPath of deps) {\r\n        const depInfo = getStructuredPathInfo(depPath);\r\n        const depNode = findPathNodeByPath(this.#engine.pathManager.rootNode, depInfo.pattern);\r\n        if (depNode === null) {\r\n          raiseError({\r\n            code: \"PATH-101\",\r\n            message: `PathNode not found: ${depInfo.pattern}`,\r\n            context: { pattern: depInfo.pattern },\r\n            docsUrl: \"./docs/error-codes.md#path\",\r\n          });\r\n        }\r\n        if (depInfo.wildcardCount > 0) {\r\n          const infos = depInfo.wildcardParentInfos;\r\n          const walk = (depRef: IStatePropertyRef, index: number, nextInfo: IStructuredPathInfo) => {\r\n            const listIndexes = this.#engine.getListIndexes(depRef) || [];\r\n            if ((index + 1) < infos.length) {\r\n              for(let i = 0; i < listIndexes.length; i++) {\r\n                const nextRef = getStatePropertyRef(nextInfo, listIndexes[i]);\r\n                walk(nextRef, index + 1, infos[index + 1]);\r\n              }\r\n            } else {\r\n              for(let i = 0; i < listIndexes.length; i++) {\r\n                const subDepRef = getStatePropertyRef(depInfo, listIndexes[i]);\r\n                this.renderItem(subDepRef, depNode);\r\n              }\r\n            }\r\n          }\r\n          const startRef = getStatePropertyRef(depInfo.wildcardParentInfos[0], null);\r\n          walk(startRef, 0, depInfo.wildcardParentInfos[1] || null);\r\n        } else {\r\n          const depRef = getStatePropertyRef(depInfo, null);\r\n          this.renderItem(depRef, depNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  \r\n}\r\n\r\n/**\r\n * 便宜関数。Renderer のインスタンス化と render 呼び出しをまとめて行う。\r\n */\r\nexport function render(refs: IStatePropertyRef[], engine: IComponentEngine, updater: IUpdater): void {\r\n  const renderer = new Renderer(engine, updater);\r\n  renderer.render(refs);\r\n}","import { createListIndex } from \"../ListIndex/ListIndex\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IListDiff } from \"./types\";\r\n\r\n/**\r\n * 旧配列/新配列と旧インデックス配列から、追加・削除・位置変更・上書きの差分を計算します。\r\n *\r\n * 仕様ノート:\r\n * - adds: 新規に現れた要素のインデックス（新規 ListIndex を割り当て）\r\n * - removes: 旧配列で使用され、新配列で使われなくなったインデックス\r\n * - changeIndexes: 値を再利用しつつ位置が変わったインデックス（DOMの並べ替え対象）\r\n * - overwrites: 同じ位置に別の値が入った場合（再描画対象）\r\n *\r\n * 最適化ノート:\r\n * - 双方空や参照同一は早期return\r\n * - 片側空は全追加/全削除として扱う\r\n */\r\nexport function calcListDiff(\r\n  parentListIndex: IListIndex | null,\r\n  oldListValue: any[] | undefined | null,\r\n  newListValue: any[] | undefined | null,\r\n  oldIndexes: IListIndex[] | undefined | null,\r\n): IListDiff {\r\n  const _newListValue = newListValue || [];\r\n  const _oldListValue = oldListValue || [];\r\n  const _oldIndexes = oldIndexes || [];\r\n  \r\n  // 参照の同一性、または両方とも空の場合の早期リターン\r\n  if (_newListValue === _oldListValue || (_newListValue.length === 0 && _oldListValue.length === 0)) {\r\n    return {\r\n      oldListValue,\r\n      newListValue,\r\n      oldIndexes: _oldIndexes,\r\n      newIndexes: _oldIndexes,\r\n    };\r\n  }\r\n  if (_newListValue.length === 0) {\r\n    return {\r\n      oldListValue,\r\n      newListValue,\r\n      oldIndexes: _oldIndexes,\r\n      newIndexes: [],\r\n      removes: new Set(_oldIndexes),\r\n    };\r\n  } else if (_oldListValue.length === 0) {\r\n    const newIndexes = [];\r\n    for(let i = 0; i< _newListValue.length; i++) {\r\n      newIndexes.push(createListIndex(parentListIndex, i));\r\n    }\r\n    return {\r\n      oldListValue,\r\n      newListValue,\r\n      oldIndexes: _oldIndexes,\r\n      newIndexes,\r\n      adds: new Set(newIndexes),\r\n    };\r\n  } else {\r\n    // インデックスベースのマップを使用して効率化\r\n    const indexByValue = new Map<any, number>();\r\n    for(let i = 0; i < _oldListValue.length; i++) {\r\n      // 重複値の場合は最後のインデックスが優先される（既存動作を維持）\r\n      indexByValue.set(_oldListValue[i], i);\r\n    }\r\n    \r\n    const adds = new Set<IListIndex>();\r\n    const removes = new Set<IListIndex>();\r\n    const changeIndexes = new Set<IListIndex>();\r\n    let newIndexes: IListIndex[] = [];\r\n    let usedOldIndexes = new Set<IListIndex>();\r\n    let maybeSame = _oldListValue.length === _newListValue.length;\r\n    \r\n    // 新しい配列を走査し、追加・再利用・位置変更を判定\r\n   \r\n    for(let i = 0; i < _newListValue.length; i++) {\r\n      const newValue = _newListValue[i];\r\n      if (maybeSame) {\r\n        if (newValue === _oldListValue[i]) {\r\n          continue;\r\n        }\r\n        newIndexes = _oldIndexes.slice(0, i);\r\n        usedOldIndexes = new Set(newIndexes);\r\n        maybeSame = false;\r\n      }\r\n      const oldIndex = indexByValue.get(newValue);\r\n      \r\n      if (oldIndex === undefined) {\r\n        // 新しい要素\r\n        const newListIndex = createListIndex(parentListIndex, i);\r\n        adds.add(newListIndex);\r\n        newIndexes.push(newListIndex);\r\n      } else {\r\n        // 既存要素の再利用\r\n        const existingListIndex = _oldIndexes[oldIndex];\r\n        if (existingListIndex.index !== i) {\r\n          existingListIndex.index = i;\r\n          changeIndexes.add(existingListIndex);\r\n        }\r\n        usedOldIndexes.add(existingListIndex);\r\n        newIndexes.push(existingListIndex);\r\n      }\r\n    }\r\n    if (maybeSame) {\r\n      // 参照同一だった場合\r\n      return {\r\n        oldListValue,\r\n        newListValue,\r\n        oldIndexes: _oldIndexes,\r\n        newIndexes: _oldIndexes,\r\n      };\r\n    }\r\n    \r\n    // 使用されなかった古いインデックスを削除対象に追加\r\n    for(let i = 0; i < _oldIndexes.length; i++) {\r\n      const oldIndex = _oldIndexes[i];\r\n      if (!usedOldIndexes.has(oldIndex)) {\r\n        removes.add(oldIndex);\r\n      }\r\n    }\r\n    return {\r\n      oldListValue,\r\n      newListValue,\r\n      oldIndexes: _oldIndexes,\r\n      newIndexes,\r\n      adds,\r\n      removes,\r\n      changeIndexes,\r\n    };\r\n  }\r\n}\r\n","import { IComponentEngine, ISaveInfoByResolvedPathInfo } from \"../ComponentEngine/types\";\r\nimport { WILDCARD } from \"../constants\";\r\nimport { calcListDiff } from \"../ListDiff/ListDiff\";\r\nimport { IListDiff } from \"../ListDiff/types\";\r\nimport { createListIndex } from \"../ListIndex/ListIndex\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { findPathNodeByPath } from \"../PathTree/PathNode\";\r\nimport { IPathNode } from \"../PathTree/types\";\r\nimport { getByRefWritable } from \"../StateClass/methods/getByRefWritable\";\r\nimport { GetByRefSymbol } from \"../StateClass/symbols\";\r\nimport { IStateProxy, IWritableStateHandler, IWritableStateProxy } from \"../StateClass/types\";\r\nimport { useWritableStateProxy } from \"../StateClass/useWritableStateProxy\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { render } from \"./Renderer\";\r\nimport { IUpdateInfo, IUpdater } from \"./types\";\r\n\r\n\r\n/**\r\n * Updater2クラスは、状態管理と更新の中心的な役割を果たします。\r\n * 状態更新が必要な場合に、都度インスタンスを作成して使用します。\r\n * 主な機能は以下の通りです:\r\n */\r\nclass Updater implements IUpdater {\r\n  queue: IStatePropertyRef[] = [];\r\n  #updating: boolean = false;\r\n  #rendering: boolean = false;\r\n  #engine: IComponentEngine;\r\n  #state: IStateProxy | undefined = undefined;\r\n  #updateInfo: IUpdateInfo;\r\n\r\n  #version: number;\r\n  #revision: number = 0;\r\n  #cacheValueByRef: WeakMap<IStatePropertyRef, any> = new WeakMap();\r\n  #listDiffByRef: WeakMap<IStatePropertyRef, IListDiff> = new WeakMap();\r\n  #oldValueAndIndexesByRef: WeakMap<IStatePropertyRef, ISaveInfoByResolvedPathInfo> = new WeakMap();\r\n  #revisionByUpdatedPath: Map<string, number> = new Map();\r\n\r\n  get revisionByUpdatedPath(): Map<string, number> {\r\n    return this.#revisionByUpdatedPath;\r\n  }\r\n\r\n  get version(): number {\r\n    return this.#version;\r\n  }\r\n\r\n  get revision(): number {\r\n    return this.#revision;\r\n  }\r\n\r\n  constructor(engine: IComponentEngine) {\r\n    this.#engine = engine;\r\n    this.#version = engine.versionUp();\r\n    this.#updateInfo = {\r\n      updatedRefs: new Set<IStatePropertyRef>(),\r\n      cacheValueByRef: new Map<IStatePropertyRef, any>(),\r\n      oldValueAndIndexesByRef: new Map<IStatePropertyRef, ISaveInfoByResolvedPathInfo>(),\r\n      listDiffByRef: new Map<IStatePropertyRef, IListDiff>(),\r\n    };\r\n  }\r\n\r\n  get state(): IStateProxy {  \r\n    if (!this.#state) throw new Error(\"State not initialized\");\r\n    return this.#state;\r\n  }\r\n\r\n  // Ref情報をキューに追加\r\n  enqueueRef(ref: IStatePropertyRef): void {\r\n    this.#revision++;\r\n    this.queue.push(ref);\r\n    this.collectMaybeUpdates(this.#engine, ref.info.pattern, this.#revisionByUpdatedPath, this.#revision);\r\n    if (this.#rendering) return;\r\n    this.#rendering = true;\r\n    queueMicrotask(() => {\r\n      this.rendering();\r\n    });\r\n  }\r\n\r\n  // 状態更新開始\r\n  async beginUpdate(loopContext: ILoopContext | null, callback: (state: IWritableStateProxy, handler: IWritableStateHandler) => Promise<void>): Promise<void> {\r\n    try {\r\n      this.#updating = true;\r\n      await useWritableStateProxy(this.#engine, this, this.#engine.state, loopContext, async (state:IWritableStateProxy, handler:IWritableStateHandler) => {\r\n        // 状態更新処理\r\n        this.#state = state;\r\n        await callback(state, handler);\r\n      });\r\n    } finally {\r\n      this.#updating = false;\r\n    }\r\n  }\r\n\r\n  // レンダリング\r\n  rendering(): void {\r\n    try {\r\n      while( this.queue.length > 0 ) {\r\n        // キュー取得\r\n        const queue = this.queue;\r\n        this.queue = [];\r\n        if (!this.#engine) raiseError({\r\n          code: \"UPD-001\",\r\n          message: \"Engine not initialized\",\r\n          docsUrl: \"./docs/error-codes.md#upd\",\r\n        });\r\n        // レンダリング実行\r\n        render(queue, this.#engine, this);\r\n      }\r\n    } finally {\r\n      this.#rendering = false;\r\n    }\r\n  }\r\n\r\n  getOldListAndListIndexes(\r\n    engine: IComponentEngine,\r\n    updateInfo: IUpdateInfo, \r\n    ref: IStatePropertyRef\r\n  ): ISaveInfoByResolvedPathInfo {\r\n    let saveInfo = updateInfo.oldValueAndIndexesByRef.get(ref);\r\n    if (typeof saveInfo === \"undefined\") {\r\n      saveInfo = engine.getListAndListIndexes(ref);\r\n      updateInfo.oldValueAndIndexesByRef.set(ref, saveInfo);\r\n    }\r\n    return saveInfo;\r\n  }\r\n\r\n  recursiveCollectMaybeUpdates(\r\n    engine: IComponentEngine,\r\n    path: string,\r\n    node: IPathNode,\r\n    revisionByUpdatedPath: Map<string, number>,\r\n    revision: number,\r\n    visitedInfo: Set<string>,\r\n  ): void {\r\n    if (visitedInfo.has(path)) return;\r\n    visitedInfo.add(path);\r\n    revisionByUpdatedPath.set(path, revision);\r\n\r\n    for(const [name, childNode] of node.childNodeByName.entries()) {\r\n      const childPath = childNode.currentPath;\r\n      this.recursiveCollectMaybeUpdates(engine, childPath, childNode, revisionByUpdatedPath, revision, visitedInfo);\r\n    }\r\n\r\n    const deps = engine.pathManager.dynamicDependencies.get(path) ?? [];\r\n    for(const depPath of deps) {\r\n      const depNode = findPathNodeByPath(engine.pathManager.rootNode, depPath);\r\n      if (depNode === null) {\r\n        raiseError({\r\n          code: \"UPD-004\",\r\n          message: `Path node not found for pattern: ${depPath}`,\r\n          docsUrl: \"./docs/error-codes.md#upd\",\r\n        });\r\n      }\r\n      this.recursiveCollectMaybeUpdates(engine, depPath\r\n        , depNode, revisionByUpdatedPath, revision, visitedInfo);\r\n    }\r\n  }\r\n\r\n  collectMaybeUpdates(engine: IComponentEngine, path: string, revisionByUpdatePath: Map<string, number>, revision: number): void {\r\n    const node = findPathNodeByPath(engine.pathManager.rootNode, path);\r\n    if (node === null) {\r\n      raiseError({\r\n        code: \"UPD-003\",\r\n        message: `Path node not found for pattern: ${path}`,\r\n        docsUrl: \"./docs/error-codes.md#upd\",\r\n      });\r\n    }\r\n    this.recursiveCollectMaybeUpdates(engine, path, node, revisionByUpdatePath, revision, new Set<string>());\r\n  }\r\n}\r\n\r\n\r\nexport async function update(engine: IComponentEngine, loopContext: ILoopContext | null, callback: (updater: IUpdater, state: IWritableStateProxy, handler: IWritableStateHandler) => Promise<void>): Promise<void> {\r\n  const updater = new Updater(engine);\r\n  await updater.beginUpdate(loopContext, async (state, handler) => {\r\n    await callback(updater, state, handler);\r\n  });\r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { update } from \"../../Updater/Updater.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeEventクラスは、イベントバインディング（onClick, onInputなど）を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - 指定イベント（on～）に対して、バインディングされた関数をイベントリスナーとして登録\r\n * - デコレータ（preventDefault, stopPropagation）によるイベント制御に対応\r\n * - ループコンテキストやリストインデックスも引数としてイベントハンドラに渡す\r\n * - ハンドラ実行時はstateProxyを生成し、Updater経由で非同期的に状態を更新\r\n *\r\n * 設計ポイント:\r\n * - nameからイベント名（subName）を抽出し、addEventListenerで登録\r\n * - バインディング値が関数でない場合はエラー\r\n * - デコレータでpreventDefault/stopPropagationを柔軟に制御\r\n * - ループ内イベントにも対応し、リストインデックスを引数展開\r\n */\r\nclass BindingNodeEvent extends BindingNode {\r\n  #subName    : string;\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    this.#subName = this.name.slice(2); // on～\r\n    const element = node as HTMLElement;\r\n    element.addEventListener(this.subName, (e:Event) => this.handler(e));\r\n  }\r\n  get subName(): string {\r\n    return this.#subName;\r\n  }\r\n  update() {\r\n    // 何もしない（イベントバインディングは初期化時のみ）\r\n  }\r\n\r\n  async handler(e: Event) {\r\n    const engine = this.binding.engine;\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n    const indexes = loopContext?.serialize().map((context) => context.listIndex.index) ?? [];\r\n    const options = this.decorates;\r\n    if (options.includes(\"preventDefault\")) {\r\n      e.preventDefault();\r\n    }\r\n    if (options.includes(\"stopPropagation\")) {\r\n      e.stopPropagation();\r\n    }\r\n    await update(engine, loopContext, async (updater, state, handler) => {\r\n      // stateProxyを生成し、バインディング値を実行\r\n      const func = this.binding.bindingState.getValue(state, handler);\r\n      if (typeof func !== \"function\") {\r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: `${this.name} is not a function`,\r\n          context: { where: 'BindingNodeEvent.handler', name: this.name, receivedType: typeof func },\r\n          docsUrl: '/docs/error-codes.md#bind',\r\n          severity: 'error',\r\n        });\r\n      }\r\n      await Reflect.apply(func, state, [e, ...indexes]);\r\n    });\r\n  }\r\n  applyChange(renderer: IRenderer): void {\r\n    // イベントバインディングは初期化時のみで、状態変更時に何もしない\r\n  }\r\n}\r\n\r\n/**\r\n * イベントバインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeEventインスタンスを生成\r\n */\r\nexport const createBindingNodeEvent: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeEvent(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { COMMENT_TEMPLATE_MARK } from \"../../constants.js\";\r\nimport { Filters } from \"../../Filter/types\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\n\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\n/**\r\n * BindingNodeBlock は、テンプレートブロック（コメントノードで示すテンプレート挿入部）を\r\n * バインディング対象とする基底クラス。\r\n *\r\n * 役割:\r\n * - コメントのテキストからテンプレートIDを抽出し id として保持\r\n * - Block 系バインディングの共通処理を提供\r\n *\r\n * Throws:\r\n * - BIND-201 Invalid node: コメントノードから ID を抽出できない場合\r\n */\r\nexport class BindingNodeBlock extends BindingNode {\r\n  #id: number;\r\n  get id(): number {\r\n    return this.#id;\r\n  }\r\n\r\n  get isBlock(): boolean {\r\n    return true;\r\n  }\r\n  \r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const id = this.node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN) ?? raiseError({\r\n      code: 'BIND-201',\r\n      message: 'Invalid node',\r\n      context: { where: 'BindingNodeBlock.id', textContent: this.node.textContent ?? null },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n      severity: 'error',\r\n    });\r\n    this.#id = Number(id);\r\n  }\r\n    \r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindContent } from \"../BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeIf は、if バインディング（条件付き描画）を担当するノード実装。\r\n *\r\n * 役割:\r\n * - boolean 値に応じて BindContent（描画内容）の mount/unmount を制御\r\n * - 現在表示中の BindContent 集合を bindContents で参照可能\r\n *\r\n * 例外（代表）:\r\n * - BIND-201 Not implemented: assignValue は未実装\r\n * - BIND-201 Value is not boolean: applyChange で値が boolean ではない\r\n * - BIND-201 ParentNode is null: マウント先の親ノードが存在しない\r\n * - TMP-001 Template not found: 内部で参照するテンプレート未登録\r\n */\r\nclass BindingNodeIf extends BindingNodeBlock {\r\n  #bindContent: IBindContent;\r\n  #trueBindContents: IBindContent[];\r\n  #falseBindContents: IBindContent[] = [];\r\n  #bindContents: IBindContent[];\r\n\r\n  get bindContents(): IBindContent[] {\r\n    return this.#bindContents;\r\n  }\r\n\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const blankInfo = getStructuredPathInfo(\"\");\r\n    const blankRef = getStatePropertyRef(blankInfo, null);\r\n    this.#bindContent = createBindContent(\r\n      this.binding, \r\n      this.id, \r\n      this.binding.engine,\r\n      blankRef, \r\n    );\r\n    this.#trueBindContents = this.#bindContents = [this.#bindContent];\r\n  }\r\n\r\n  /**\r\n   * 値の直接代入は未実装。\r\n   * Throws: BIND-201 Not implemented\r\n   */\r\n  assignValue(value: any): void {\r\n    raiseError({\r\n      code: 'BIND-201',\r\n      message: 'Not implemented',\r\n      context: { where: 'BindingNodeIf.assignValue', name: this.name },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n      severity: 'error',\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * 値を評価して true なら mount+applyChange、false なら unmount。\r\n   * 既に更新済みの binding はスキップ。\r\n   *\r\n   * Throws:\r\n   * - BIND-201 Value is not boolean\r\n   * - BIND-201 ParentNode is null\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    if (renderer.updatedBindings.has(this.binding)) return;\r\n    const filteredValue = this.binding.bindingState.getFilteredValue(renderer.readonlyState, renderer.readonlyHandler);\r\n    if (typeof filteredValue !== \"boolean\") {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Value is not boolean',\r\n        context: { where: 'BindingNodeIf.update', valueType: typeof filteredValue },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    const parentNode = this.node.parentNode;\r\n    if (parentNode == null) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'ParentNode is null',\r\n        context: { where: 'BindingNodeIf.update', nodeType: this.node.nodeType },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n    if (filteredValue) {\r\n      this.#bindContent.mountAfter(parentNode, this.node);\r\n      this.#bindContent.applyChange(renderer);\r\n      this.#bindContents = this.#trueBindContents;\r\n    } else {\r\n      this.#bindContent.unmount();\r\n      this.#bindContents = this.#falseBindContents;\r\n    }\r\n    renderer.updatedBindings.add(this.binding);\r\n  }\r\n}\r\n\r\n/**\r\n * if バインディングノード生成用ファクトリ関数。\r\n * name / フィルタ / デコレータ設定に従い BindingNodeIf を生成する。\r\n */\r\nexport const createBindingNodeIf: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeIf(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types.js\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IRenderer } from \"../../Updater/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { createBindContent } from \"../BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../types\";\r\nimport { BindingNodeBlock } from \"./BindingNodeBlock.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nconst EMPTY_SET = new Set<any>();\r\n\r\n/**\r\n * フラグメントに追加し、一括でノードで追加するかのフラグ\r\n * ベンチマークの結果で判断する\r\n */\r\nconst USE_ALL_APPEND = false;\r\n\r\n/**\r\n * BindingNodeForクラスは、forバインディング（配列やリストの繰り返し描画）を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - リストデータの各要素ごとにBindContent（バインディングコンテキスト）を生成・管理\r\n * - 配列の差分検出により、必要なBindContentの生成・再利用・削除・再描画を最適化\r\n * - DOM上での要素の並び替えや再利用、アンマウント・マウント処理を効率的に行う\r\n * - プール機構によりBindContentの再利用を促進し、パフォーマンスを向上\r\n *\r\n * 設計ポイント:\r\n * - applyChangeでリストの差分を検出し、BindContentの生成・削除・再利用を管理\r\n * - 追加・削除が無い場合はリオーダー（並べ替え）のみをDOM移動で処理し、再描画を抑制\r\n * - 上書き（overwrites）は同位置の内容変化のため、applyChangeを再実行\r\n * - BindContentのプール・インデックス管理でGCやDOM操作の最小化を図る\r\n * - バインディング状態やリストインデックス情報をエンジンに保存し、再描画や依存解決を容易にする\r\n *\r\n * Throws（代表例）:\r\n * - BIND-201 ParentNode is null / BindContent not found など applyChange 実行時の不整合\r\n * - BIND-202 Length is negative: プール長の不正設定\r\n * - BIND-301 Not implemented. Use update or applyChange: assignValue は未実装\r\n *\r\n * ファクトリ関数 createBindingNodeFor でフィルタ・デコレータ適用済みインスタンスを生成\r\n */\r\nclass BindingNodeFor extends BindingNodeBlock {\r\n  #bindContents          : IBindContent[] = [];\r\n  #bindContentByListIndex: WeakMap<IListIndex, IBindContent> = new WeakMap();\r\n  #bindContentPool       : IBindContent[] = [];\r\n  #bindContentLastIndex  : number = 0;\r\n  #loopInfo: IStructuredPathInfo | undefined = undefined;\r\n\r\n  get bindContents(): IBindContent[] {\r\n    return this.#bindContents;\r\n  }\r\n\r\n  get isFor(): boolean {\r\n    return true;\r\n  }\r\n\r\n  init() {\r\n  }\r\n\r\n  createBindContent(listIndex: IListIndex): IBindContent {\r\n    let bindContent: IBindContent;\r\n    if (this.#bindContentLastIndex >= 0) {\r\n      // プールの最後の要素を取得して、プールの長さをあとで縮減する\r\n      // 作るたびにプールを縮減すると、パフォーマンスが悪化するため\r\n      // プールの長さを縮減するのは、全ての要素を作った後に行う\r\n      bindContent = this.#bindContentPool[this.#bindContentLastIndex];\r\n      this.#bindContentLastIndex--;\r\n      bindContent.assignListIndex(listIndex);\r\n    } else {\r\n      const loopRef = getStatePropertyRef(this.loopInfo, listIndex);\r\n      bindContent = createBindContent(\r\n        this.binding,\r\n        this.id,\r\n        this.binding.engine,\r\n        loopRef\r\n      );\r\n    }\r\n    // 登録\r\n    this.#bindContentByListIndex.set(listIndex, bindContent);\r\n    return bindContent;\r\n  }\r\n\r\n  /**\r\n   * BindContent を削除（アンマウント）し、ループ文脈のインデックスもクリアする。\r\n   */\r\n  deleteBindContent(bindContent: IBindContent): void {\r\n    bindContent.unmount();\r\n    bindContent.loopContext?.clearListIndex();\r\n  }\r\n\r\n  get bindContentLastIndex():number {\r\n    return this.#bindContentLastIndex;\r\n  }\r\n  set bindContentLastIndex(value:number) {\r\n    this.#bindContentLastIndex = value;\r\n  }\r\n\r\n  get poolLength():number {\r\n    return this.#bindContentPool.length;\r\n  }\r\n  set poolLength(length: number) {\r\n    if (length < 0) {\r\n      raiseError({\r\n        code: 'BIND-202',\r\n        message: 'Length is negative',\r\n        context: { where: 'BindingNodeFor.setPoolLength', length },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    this.#bindContentPool.length = length;\r\n  }\r\n\r\n  get loopInfo(): IStructuredPathInfo {\r\n    if (typeof this.#loopInfo === \"undefined\") {\r\n      const loopPath = this.binding.bindingState.pattern + \".*\";\r\n      this.#loopInfo = getStructuredPathInfo(loopPath);\r\n    }\r\n    return this.#loopInfo;\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Not implemented. Use update or applyChange',\r\n      context: { where: 'BindingNodeFor.assignValue' },\r\n      docsUrl: './docs/error-codes.md#bind',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * リストの差分を適用して DOM とバインディングを更新する中核メソッド。\r\n   *\r\n   * - 追加/削除がある場合: add は生成+mount+applyChange、reuse は位置調整のみ\r\n   * - 追加/削除が無い場合: changeIndexes はDOM移動のみ（再描画なし）、overwrites は applyChange を呼ぶ\r\n   * - 全削除/全追加はフラグメント最適化を適用\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    if (renderer.updatedBindings.has(this.binding)) return;\r\n    let newBindContents: IBindContent[] = [];\r\n    // 削除を先にする\r\n    const removeBindContentsSet = new Set<IBindContent>();\r\n    const listDiff = renderer.calcListDiff(this.binding.bindingState.ref);\r\n    if (listDiff === null) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'ListDiff is null',\r\n        context: { where: 'BindingNodeFor.applyChange' },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    const parentNode = this.node.parentNode ?? raiseError({\r\n      code: 'BIND-201',\r\n      message: 'ParentNode is null',\r\n      context: { where: 'BindingNodeFor.applyChange' },\r\n      docsUrl: './docs/error-codes.md#bind',\r\n    });\r\n    // 全削除最適化のフラグ\r\n    const isAllRemove = (listDiff.oldListValue?.length === listDiff.removes?.size && (listDiff.oldListValue?.length ?? 0) > 0);\r\n    // 親ノードこのノードだけ持つかのチェック\r\n    let isParentNodeHasOnlyThisNode = false;\r\n    if (isAllRemove) {\r\n      const parentChildNodes = Array.from(parentNode.childNodes);\r\n      const lastContent = this.#bindContents.at(-1) ?? raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Last content is null',\r\n        context: { where: 'BindingNodeFor.applyChange' },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n      });\r\n      // ブランクノードを飛ばす\r\n      let firstNode: Node | null = parentChildNodes[0];\r\n      while(firstNode && firstNode.nodeType === Node.TEXT_NODE && firstNode.textContent?.trim() === \"\") {\r\n        firstNode = firstNode.nextSibling;\r\n      }\r\n      let lastNode: Node | null = parentChildNodes.at(-1) ?? null;\r\n      while(lastNode && lastNode.nodeType === Node.TEXT_NODE && lastNode.textContent?.trim() === \"\") {\r\n        lastNode = lastNode.previousSibling;\r\n      }\r\n      if (firstNode === this.node && lastNode === lastContent.getLastNode(parentNode)) {\r\n        isParentNodeHasOnlyThisNode = true;\r\n      }\r\n    }\r\n    if (isAllRemove && isParentNodeHasOnlyThisNode) {\r\n      // 全削除最適化\r\n      parentNode.textContent = \"\";\r\n      parentNode.append(this.node);\r\n      for(let i = 0; i < this.#bindContents.length; i++) {\r\n        const bindContent = this.#bindContents[i];\r\n        bindContent.loopContext?.clearListIndex();\r\n      }\r\n      this.#bindContentPool.push(...this.#bindContents);\r\n    } else {\r\n      if (listDiff.removes) {\r\n        for(const listIndex of listDiff.removes) {\r\n          const bindContent = this.#bindContentByListIndex.get(listIndex);\r\n          if (typeof bindContent === \"undefined\") {\r\n            raiseError({\r\n              code: 'BIND-201',\r\n              message: 'BindContent not found',\r\n              context: { where: 'BindingNodeFor.applyChange', when: 'removes' },\r\n              docsUrl: './docs/error-codes.md#bind',\r\n            });\r\n          }\r\n          this.deleteBindContent(bindContent);\r\n          removeBindContentsSet.add(bindContent);\r\n        }\r\n      }\r\n      this.#bindContentPool.push(...removeBindContentsSet);\r\n    }\r\n\r\n    let lastBindContent = null;\r\n    const firstNode = this.node;\r\n    this.bindContentLastIndex = this.poolLength - 1;\r\n    const isAllAppend = USE_ALL_APPEND && (listDiff.newListValue?.length === listDiff.adds?.size && (listDiff.newListValue?.length ?? 0) > 0);\r\n    // リオーダー判定: 追加・削除がなく、並び替え（changeIndexes）または上書き（overwrites）のみの場合\r\n    const isReorder = (listDiff.adds?.size ?? 0) === 0 && (listDiff.removes?.size ?? 0) === 0 &&\r\n      ((listDiff.changeIndexes?.size ?? 0) > 0 || (listDiff.overwrites?.size ?? 0) > 0 );\r\n    if (!isReorder) {\r\n      // 全追加の場合、バッファリングしてから一括追加する\r\n      const fragmentParentNode = isAllAppend ? document.createDocumentFragment() : parentNode;\r\n      const fragmentFirstNode = isAllAppend ? null : firstNode;\r\n      const adds = listDiff.adds ?? EMPTY_SET;\r\n      for(const listIndex of listDiff.newIndexes) {\r\n        const lastNode = lastBindContent?.getLastNode(fragmentParentNode) ?? fragmentFirstNode;\r\n        let bindContent;\r\n        if (adds.has(listIndex)) {\r\n          bindContent = this.createBindContent(listIndex);\r\n          bindContent.mountAfter(fragmentParentNode, lastNode);\r\n          //for(let i = 0; i < bindContent.blockBindings.length; i++) {\r\n          //  const blockBinding = bindContent.blockBindings[i];\r\n          //  blockBinding.applyChange(renderer);\r\n          //}\r\n          bindContent.applyChange(renderer);\r\n        } else {\r\n          bindContent = this.#bindContentByListIndex.get(listIndex);\r\n          if (typeof bindContent === \"undefined\") {\r\n            raiseError({\r\n              code: 'BIND-201',\r\n              message: 'BindContent not found',\r\n              context: { where: 'BindingNodeFor.applyChange', when: 'reuse' },\r\n              docsUrl: './docs/error-codes.md#bind',\r\n            });\r\n          }\r\n          if (lastNode?.nextSibling !== bindContent.firstChildNode) {\r\n            bindContent.mountAfter(fragmentParentNode, lastNode);\r\n          }\r\n        }\r\n        newBindContents.push(bindContent);\r\n        lastBindContent = bindContent;\r\n      }\r\n      // 全追加最適化\r\n      if (isAllAppend) {\r\n        const beforeNode = firstNode.nextSibling;\r\n        parentNode.insertBefore(fragmentParentNode, beforeNode);\r\n      }\r\n    } else {\r\n      // リオーダー処理: 要素の追加・削除がない場合の最適化処理\r\n      // 並び替え処理: インデックスの変更のみなので、要素の再描画は不要\r\n      // DOM位置の調整のみ行い、BindContentの内容は再利用する\r\n      if ((listDiff.changeIndexes?.size ?? 0) > 0) {\r\n        const bindContents = Array.from(this.#bindContents);\r\n        const changeIndexes = Array.from(listDiff.changeIndexes ?? []);\r\n        changeIndexes.sort((a, b) => a.index - b.index);\r\n        for(const listIndex of changeIndexes) {\r\n          const bindContent = this.#bindContentByListIndex.get(listIndex);\r\n          if (typeof bindContent === \"undefined\") {\r\n            raiseError({\r\n              code: 'BIND-201',\r\n              message: 'BindContent not found',\r\n              context: { where: 'BindingNodeFor.applyChange', when: 'reorder' },\r\n              docsUrl: '/docs/error-codes.md#bind',\r\n            });\r\n          }\r\n          bindContents[listIndex.index] = bindContent;\r\n          const lastNode = bindContents[listIndex.index - 1]?.getLastNode(parentNode) ?? firstNode;\r\n          bindContent.mountAfter(parentNode, lastNode);\r\n        }\r\n        newBindContents = bindContents;\r\n      }\r\n      // 上書き処理: 同じ位置の要素が異なる値に変更された場合の再描画\r\n      if ((listDiff.overwrites?.size ?? 0) > 0) {\r\n        for (const listIndex of listDiff.overwrites ?? []) {\r\n          const bindContent = this.#bindContentByListIndex.get(listIndex);\r\n          if (typeof bindContent === \"undefined\") {\r\n            raiseError({\r\n              code: 'BIND-201',\r\n              message: 'BindContent not found',\r\n              context: { where: 'BindingNodeFor.applyChange', when: 'overwrites' },\r\n              docsUrl: './docs/error-codes.md#bind',\r\n            });\r\n          }\r\n          bindContent.applyChange(renderer);\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    // プールの長さを更新する\r\n    // プールの長さは、プールの最後の要素のインデックス+1であるため、\r\n    this.poolLength = this.bindContentLastIndex + 1;\r\n    this.#bindContents = newBindContents;\r\n  }\r\n}\r\n\r\nexport const createBindingNodeFor: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeFor(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { NodeType } from \"./types\";\r\n\r\nconst DEFAULT_PROPERTY = \"textContent\";\r\n\r\ntype DefaultPropertyByElementType = {\r\n  [key:string]: string;\r\n}\r\n\r\nconst defaultPropertyByElementType:DefaultPropertyByElementType = {\r\n  \"radio\"   : \"checked\",\r\n  \"checkbox\": \"checked\",\r\n  \"button\"  : \"onclick\",\r\n}\r\n\r\n/**\r\n * HTML要素のデフォルトプロパティを取得\r\n */\r\nconst getDefaultPropertyHTMLElement = (node:Node):string => \r\n  node instanceof HTMLSelectElement || node instanceof HTMLTextAreaElement || node instanceof HTMLOptionElement ? \"value\" : \r\n  node instanceof HTMLButtonElement ? \"onclick\" : \r\n  node instanceof HTMLAnchorElement ? \"onclick\" : \r\n  node instanceof HTMLFormElement ? \"onsubmit\" : \r\n  node instanceof HTMLInputElement ? (defaultPropertyByElementType[node.type] ?? \"value\") :\r\n  DEFAULT_PROPERTY;\r\n\r\ntype DefaultPropertyByKey = {\r\n  [key:string]: string | undefined;\r\n}\r\n\r\nconst _cache: DefaultPropertyByKey = {};\r\n\r\nconst textContentProperty = (node:Node):string => DEFAULT_PROPERTY;\r\n\r\ntype GetDefaultPropertyByNodeType = {\r\n  [key in NodeType]: ((node:Node)=>string) | undefined;\r\n}\r\n\r\nconst getDefaultPropertyByNodeType: GetDefaultPropertyByNodeType = {\r\n  HTMLElement: getDefaultPropertyHTMLElement,\r\n  SVGElement : undefined,\r\n  Text       : textContentProperty,\r\n  Template   : undefined,\r\n}\r\n\r\n/**\r\n * バインド情報でノードプロパティが省略された場合に、ノード種別・要素タイプごとに\r\n * 適切なデフォルトプロパティ名（例: textContent, value, checked, onclick など）を返すユーティリティ関数。\r\n *\r\n * - HTMLInputElementやHTMLSelectElementなど、要素ごとに最適なプロパティを判定\r\n * - input要素はtype属性（radio, checkboxなど）も考慮\r\n * - 一度判定した組み合わせはキャッシュし、パフォーマンス向上\r\n *\r\n * @param node     対象ノード\r\n * @param nodeType ノードタイプ（\"HTMLElement\" | \"SVGElement\" | \"Text\" | \"Template\"）\r\n * @returns        デフォルトのプロパティ名（例: \"value\", \"checked\", \"textContent\" など）\r\n */\r\nexport function getDefaultName(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n): string | undefined {\r\n  const key = node.constructor.name + \"\\t\" + ((node as HTMLInputElement).type ?? \"\"); // type attribute\r\n  return _cache[key] ?? (_cache[key] = getDefaultPropertyByNodeType[nodeType]?.(node));\r\n}\r\n  ","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { getDefaultName } from \"../../BindingBuilder/getDefaultName.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { update } from \"../../Updater/Updater.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\nfunction isTwoWayBindable(element: HTMLElement): boolean {\r\n  return element instanceof HTMLInputElement || \r\n    element instanceof HTMLTextAreaElement || \r\n    element instanceof HTMLSelectElement;\r\n}\r\n\r\nconst defaultEventByName: {[key:string]: string} = {\r\n  \"value\"   : \"input\",\r\n  \"checked\" : \"change\",\r\n  \"selected\": \"change\",\r\n};\r\n\r\n/**\r\n * BindingNodePropertyクラスは、ノードのプロパティ（value, checked, selected など）への\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - ノードプロパティへの値の割り当て・取得\r\n * - 双方向バインディング（input, changeイベント等）に対応\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - デフォルトプロパティ名と一致し、かつ双方向バインディング可能な要素の場合のみイベントリスナーを登録\r\n * - デコレータでイベント名を指定可能（onInput, onChangeなど）\r\n * - イベント発火時はUpdater経由でstateを非同期的に更新\r\n * - assignValueでnull/undefined/NaNは空文字列に変換してセット\r\n */\r\nclass BindingNodeProperty extends BindingNode {\r\n  get value(): any {\r\n    // @ts-ignore\r\n    return this.node[this.name];\r\n  }\r\n  get filteredValue(): any {\r\n    let value = this.value;\r\n    for(let i = 0; i < this.filters.length; i++) {\r\n      value = this.filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n\r\n    const isElement = this.node instanceof HTMLElement;\r\n    if (!isElement) return;\r\n    if (!isTwoWayBindable(this.node)) return;\r\n    const defaultName = getDefaultName(this.node, \"HTMLElement\");\r\n    if (defaultName !== this.name) return;\r\n    if (decorates.length > 1) raiseError({\r\n      code: 'BIND-201',\r\n      message: 'Has multiple decorators',\r\n      context: { where: 'BindingNodeProperty.constructor', name: this.name, decoratesCount: decorates.length },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n      severity: 'error',\r\n    });\r\n    const event = (decorates[0]?.startsWith(\"on\") ? decorates[0]?.slice(2) : decorates[0]) ?? null;\r\n    const eventName = event ?? defaultEventByName[this.name] ?? \"readonly\";\r\n    if (eventName === \"readonly\" || eventName === \"ro\") return;\r\n\r\n    // 双方向バインディング: イベント発火時にstateを更新\r\n    const engine = this.binding.engine;\r\n    this.node.addEventListener(eventName, async () => {\r\n      const loopContext = this.binding.parentBindContent.currentLoopContext;\r\n      const value = this.filteredValue;\r\n      await update(engine, loopContext, async (updater, state, handler) => {\r\n        binding.updateStateValue(state, handler, value);\r\n      });\r\n    });\r\n  }\r\n\r\n  init() {\r\n    // サブクラスで初期化処理を実装可能\r\n  }\r\n\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    // @ts-ignore\r\n    this.node[this.name] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * プロパティバインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodePropertyインスタンスを生成\r\n */\r\nexport const createBindingNodeProperty: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeProperty(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeRadioクラスは、ラジオボタン（input[type=\"radio\"]）の\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値とinput要素のvalueが一致していればchecked=trueにする\r\n * - null/undefined/NaNの場合は空文字列に変換して比較\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - assignValueで値を文字列化し、input要素のvalueと比較してcheckedを制御\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeRadio extends BindingNode {\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as HTMLInputElement;\r\n    element.checked = value.toString() === element.value.toString();\r\n  }\r\n}\r\n\r\n/**\r\n * ラジオボタン用バインディングノード生成ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeRadioインスタンスを生成\r\n */\r\nexport const createBindingNodeRadio: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeRadio(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeStyleクラスは、style属性（インラインスタイル）のバインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング値を指定のCSSプロパティ（subName）としてHTMLElementにセット\r\n * - null/undefined/NaNの場合は空文字列に変換してセット\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - nameからCSSプロパティ名（subName）を抽出（例: \"style.color\" → \"color\"）\r\n * - assignValueで値を文字列化し、style.setPropertyで反映\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeStyle extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n  assignValue(value:any) {\r\n    if (value === null || value === undefined || Number.isNaN(value)) {\r\n      value = \"\";\r\n    }\r\n    const element = this.node as HTMLElement;\r\n    element.style.setProperty(this.subName, value.toString());\r\n  }\r\n}\r\n\r\n/**\r\n * style属性バインディングノード生成用ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeStyleインスタンスを生成\r\n */\r\nexport const createBindingNodeStyle: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeStyle(binding, node, name, filterFns, decorates);\r\n  }\r\n","const symbolName = \"component-state-input\";\r\n\r\nexport const AssignStateSymbol: unique symbol = Symbol.for(`${symbolName}.AssignState`);\r\nexport const NotifyRedrawSymbol: unique symbol = Symbol.for(`${symbolName}.NotifyRedraw`);","import { StructiveComponent } from \"./types\";\r\n\r\nconst parentStructiveComponentByStructiveComponent = new WeakMap<StructiveComponent, StructiveComponent>();\r\n\r\nexport function findStructiveParent(el:StructiveComponent): StructiveComponent | null {\r\n  return parentStructiveComponentByStructiveComponent.get(el) ?? null;\r\n}\r\n\r\nexport function registerStructiveComponent(parentComponent: StructiveComponent, component: StructiveComponent): void {\r\n  parentStructiveComponentByStructiveComponent.set(component, parentComponent);\r\n}","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { NotifyRedrawSymbol } from \"../../ComponentStateInput/symbols.js\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { registerStructiveComponent } from \"../../WebComponents/findStructiveParent.js\";\r\nimport { StructiveComponent } from \"../../WebComponents/types\";\r\nimport { IBinding } from \"../types\";\r\nimport { BindingNode } from \"./BindingNode.js\";\r\nimport { CreateBindingNodeFn } from \"./types\";\r\n\r\n/**\r\n * BindingNodeComponentクラスは、StructiveComponent（カスタムコンポーネント）への\r\n * バインディング処理を担当するバインディングノードの実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング対象のコンポーネントのstateプロパティ（subName）に値を反映\r\n * - バインディング情報をコンポーネント単位で管理（bindingsByComponentに登録）\r\n * - フィルタやデコレータにも対応\r\n *\r\n * 設計ポイント:\r\n * - nameからstateプロパティ名（subName）を抽出（例: \"state.foo\" → \"foo\"）\r\n * - assignValueでコンポーネントのstateに値をセット（RenderSymbol経由で反映）\r\n * - 初期化時にbindingsByComponentへバインディング情報を登録\r\n * - 柔軟なバインディング記法・フィルタ適用に対応\r\n */\r\nclass BindingNodeComponent extends BindingNode {\r\n  #subName: string;\r\n  get subName():string {\r\n    return this.#subName;\r\n  }\r\n  constructor(\r\n    binding   : IBinding, \r\n    node      : Node, \r\n    name      : string,\r\n    filters   : Filters,\r\n    decorates : string[]\r\n  ) {\r\n    super(binding, node, name, filters, decorates);\r\n    const [, subName] = this.name.split(\".\");\r\n    this.#subName = subName;\r\n  }\r\n\r\n  init(): void {\r\n    const engine = this.binding.engine;\r\n    registerStructiveComponent(engine.owner, this.node as StructiveComponent);\r\n    let bindings = engine.bindingsByComponent.get(this.node as StructiveComponent);\r\n    if (typeof bindings === \"undefined\") {\r\n      engine.bindingsByComponent.set(this.node as StructiveComponent, bindings = new Set<IBinding>());\r\n    }\r\n    bindings.add(this.binding);\r\n  }\r\n\r\n  assignValue(value: any): void {\r\n  }\r\n\r\n  notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    const notifyRefs = [];\r\n    const info = this.binding.bindingState.info;\r\n    const listIndex = this.binding.bindingState.listIndex?.at(info.wildcardCount - 1) ?? null;\r\n    const at = (listIndex?.length ?? 0) - 1;\r\n    for(const ref of refs) {\r\n      if (info.pathSegments.length > ref.info.pathSegments.length) {\r\n        // 親パスが更新された\r\n        // ex values, values.* valuesが更新された場合\r\n        if (info.cumulativePathSet.has(ref.info.pattern)) {\r\n          const thisAt = (ref.listIndex?.length ?? 0) - 1;\r\n          if (thisAt >= 0) {\r\n            if (listIndex === null) continue;\r\n            if (ref.listIndex !== listIndex?.at(thisAt)) continue;\r\n          }\r\n          const newRef = getStatePropertyRef(info, listIndex);\r\n          notifyRefs.push(newRef);\r\n        }\r\n      } else {\r\n        // 子パスが更新された\r\n        // ex values.*.foo values.* values.*.fooが更新された\r\n        if (!ref.info.cumulativePathSet.has(info.pattern)) {\r\n          // リストインデックスが一致しない場合はスキップ\r\n          if (at >= 0) {\r\n            if (ref.listIndex?.at(at) !== listIndex) continue;\r\n          }\r\n          notifyRefs.push(ref);\r\n        }\r\n\r\n      }\r\n    }\r\n    if (notifyRefs.length === 0) {\r\n      return;\r\n    }\r\n    const component = this.node as StructiveComponent;\r\n    component.state[NotifyRedrawSymbol](notifyRefs);\r\n  }\r\n}\r\n\r\n/**\r\n * コンポーネント用バインディングノード生成ファクトリ関数\r\n * - name, フィルタ、デコレータ情報からBindingNodeComponentインスタンスを生成\r\n */\r\nexport const createBindingNodeComponent: CreateBindingNodeFn = \r\n(name: string, filterTexts: IFilterText[], decorates: string[]) => \r\n  (binding:IBinding, node: Node, filters: FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts);\r\n    return new BindingNodeComponent(binding, node, name, filterFns, decorates);\r\n  }\r\n","import { createBindingNodeAttribute } from \"../DataBinding/BindingNode/BindingNodeAttribute.js\";\r\nimport { createBindingNodeCheckbox } from \"../DataBinding/BindingNode/BindingNodeCheckbox.js\";\r\nimport { createBindingNodeClassList } from \"../DataBinding/BindingNode/BindingNodeClassList.js\";\r\nimport { createBindingNodeClassName } from \"../DataBinding/BindingNode/BindingNodeClassName.js\";\r\nimport { createBindingNodeEvent } from \"../DataBinding/BindingNode/BindingNodeEvent.js\";\r\nimport { createBindingNodeIf } from \"../DataBinding/BindingNode/BindingNodeIf.js\";\r\nimport { createBindingNodeFor } from \"../DataBinding/BindingNode/BindingNodeFor.js\";\r\nimport { createBindingNodeProperty } from \"../DataBinding/BindingNode/BindingNodeProperty.js\";\r\nimport { createBindingNodeRadio } from \"../DataBinding/BindingNode/BindingNodeRadio.js\";\r\nimport { createBindingNodeStyle } from \"../DataBinding/BindingNode/BindingNodeStyle.js\";\r\nimport { CreateBindingNodeByNodeFn, CreateBindingNodeFn } from \"../DataBinding/BindingNode/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IFilterText } from \"./types\";\r\nimport { createBindingNodeComponent } from \"../DataBinding/BindingNode/BindingNodeComponent.js\";\r\n\r\ntype NodePropertyConstructorByName = {[key:string]:CreateBindingNodeFn};\r\ntype NodePropertyConstructorByNameByIsComment = {[key:number]:NodePropertyConstructorByName};\r\n\r\nconst nodePropertyConstructorByNameByIsComment:NodePropertyConstructorByNameByIsComment = {\r\n  0: {\r\n    \"class\"   : createBindingNodeClassList,\r\n    \"checkbox\": createBindingNodeCheckbox,\r\n    \"radio\"   : createBindingNodeRadio,\r\n  },\r\n  1: {\r\n    \"if\" : createBindingNodeIf,\r\n  },\r\n};\r\n\r\ntype NodePropertyConstructorByFirstName = {[key:string]:CreateBindingNodeFn};\r\n\r\nconst nodePropertyConstructorByFirstName:NodePropertyConstructorByFirstName = {\r\n  \"class\": createBindingNodeClassName,\r\n  \"attr\" : createBindingNodeAttribute,\r\n  \"style\": createBindingNodeStyle,\r\n  \"state\": createBindingNodeComponent,\r\n//  \"popover\": PopoverTarget,\r\n//  \"commandfor\": CommandForTarget,\r\n};\r\n\r\n/**\r\n * バインディング対象ノードのプロパティ名やノード種別（Element/Comment）に応じて、\r\n * 適切なバインディングノード生成関数（CreateBindingNodeFn）を返すユーティリティ。\r\n *\r\n * - ノード種別やプロパティ名ごとに専用の生成関数をマッピング\r\n * - コメントノードや特殊プロパティ（for/if等）にも対応\r\n * - プロパティ名の先頭や\"on\"でイベントバインディングも判別\r\n * - 一度判定した組み合わせはキャッシュし、パフォーマンス向上\r\n *\r\n * これにより、テンプレートのdata-bindやコメントバインディングの各種ケースに柔軟に対応できる。\r\n */\r\nfunction _getBindingNodeCreator(isComment:boolean, isElement: boolean, propertyName: string): CreateBindingNodeFn {\r\n  // コメント/エレメント種別とプロパティ名で専用の生成関数を優先的に取得\r\n  const bindingNodeCreatorByName = nodePropertyConstructorByNameByIsComment[isComment ? 1 : 0][propertyName];\r\n  if (typeof bindingNodeCreatorByName !== \"undefined\") {\r\n    return bindingNodeCreatorByName;\r\n  }\r\n  // コメントノードでforの場合は専用関数\r\n  if (isComment && propertyName === \"for\") {\r\n    return createBindingNodeFor;\r\n  }\r\n  // コメントノードで未対応プロパティはエラー\r\n  if (isComment) {\r\n    raiseError(`getBindingNodeCreator: unknown node property ${propertyName}`);\r\n  }\r\n  // プロパティ名の先頭で判別（class.attr.style.state等）\r\n  const nameElements = propertyName.split(\".\");\r\n  const bindingNodeCreatorByFirstName = nodePropertyConstructorByFirstName[nameElements[0]];\r\n  if (typeof bindingNodeCreatorByFirstName !== \"undefined\") {\r\n    return bindingNodeCreatorByFirstName;\r\n  }\r\n  // エレメントノードでonから始まる場合はイベントバインディング\r\n  if (isElement) {\r\n    if (propertyName.startsWith(\"on\")) {\r\n      return createBindingNodeEvent;\r\n    } else {\r\n      return createBindingNodeProperty;\r\n    }\r\n  } else {\r\n    // それ以外は汎用プロパティバインディング\r\n    return createBindingNodeProperty;\r\n  }\r\n}\r\n\r\nconst _cache: {[key:string]:CreateBindingNodeFn} = {};\r\n\r\n/**\r\n * ノード・プロパティ名・フィルタ・デコレータ情報から\r\n * 適切なバインディングノード生成関数を取得し、呼び出すファクトリ関数。\r\n * \r\n * @param node         バインディング対象ノード\r\n * @param propertyName バインディングプロパティ名\r\n * @param filterTexts  フィルタ情報\r\n * @param decorates    デコレータ情報\r\n * @returns            バインディングノード生成関数の実行結果\r\n */\r\nexport function getBindingNodeCreator(\r\n  node        : Node, \r\n  propertyName: string,\r\n  filterTexts : IFilterText[],\r\n  decorates   : string[]\r\n): CreateBindingNodeByNodeFn {\r\n  const isComment = node instanceof Comment;\r\n  const isElement = node instanceof Element;\r\n  const key = isComment + \"\\t\" + isElement + \"\\t\" + propertyName;\r\n  // キャッシュを利用して生成関数を取得\r\n  const fn = _cache[key] ?? (_cache[key] = _getBindingNodeCreator(isComment, isElement, propertyName));\r\n  return fn(propertyName, filterTexts, decorates);\r\n}\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { IListIndex } from \"../../ListIndex/types.js\";\r\nimport { ILoopContext } from \"../../LoopContext/types.js\";\r\nimport { getByRefReadonly } from \"../../StateClass/methods/getByRefReadonly.js\";\r\nimport { getByRefWritable } from \"../../StateClass/methods/getByRefWritable.js\";\r\nimport { setByRef } from \"../../StateClass/methods/setByRef.js\";\r\nimport { GetByRefSymbol, SetByRefSymbol } from \"../../StateClass/symbols.js\";\r\nimport { IReadonlyStateHandler, IReadonlyStateProxy, IWritableStateHandler, IWritableStateProxy } from \"../../StateClass/types\";\r\nimport { getStructuredPathInfo } from \"../../StateProperty/getStructuredPathInfo.js\";\r\nimport { IStructuredPathInfo } from \"../../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../../StatePropertyRef/StatepropertyRef.js\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\n/**\r\n * BindingStateクラスは、バインディング対象の状態（State）プロパティへのアクセス・更新・フィルタ適用を担当する実装です。\r\n *\r\n * 主な役割:\r\n * - バインディング対象の状態プロパティ（pattern, info）やリストインデックス（listIndex）を管理\r\n * - get valueで現在の値を取得し、get filteredValueでフィルタ適用後の値を取得\r\n * - initでリストバインディング時のループコンテキストやインデックス参照を初期化\r\n * - assignValueで状態プロキシに値を書き込む（双方向バインディング対応）\r\n * - バインディング情報をエンジンに登録し、依存解決や再描画を効率化\r\n *\r\n * 設計ポイント:\r\n * - ワイルドカードパス（配列バインディング等）にも対応し、ループごとのインデックス管理が可能\r\n * - フィルタ適用は配列で柔軟に対応\r\n * - createBindingStateファクトリでフィルタ適用済みインスタンスを生成\r\n */\r\nclass BindingState implements IBindingState {\r\n  #binding     : IBinding;\r\n  #pattern     : string;\r\n  #info        : IStructuredPathInfo;\r\n  #filters     : Filters;\r\n  #loopContext : ILoopContext | null = null;\r\n  #nullRef     : IStatePropertyRef | null = null;\r\n  #ref         : IStatePropertyRef | null = null;\r\n  get pattern(): string {\r\n    return this.#pattern;\r\n  }\r\n  get info() {\r\n    return this.#info;\r\n  }\r\n  get listIndex() {\r\n    return this.ref.listIndex;\r\n  }\r\n  get ref() {\r\n    if (this.#loopContext !== null) {\r\n      if (this.#ref === null) {\r\n        this.#ref = getStatePropertyRef(this.#info, this.#loopContext.listIndex);\r\n      }\r\n      return this.#ref;\r\n    } else {\r\n      return this.#nullRef ?? raiseError({\r\n        code: 'BIND-201',\r\n        message: 'ref is null',\r\n        context: { pattern: this.#pattern },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n        severity: 'error',\r\n      });\r\n    }\r\n  }\r\n  get filters() {\r\n    return this.#filters;\r\n  }\r\n  get binding() {\r\n    return this.#binding;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this.#binding = binding;\r\n    this.#pattern = pattern;\r\n    this.#info = getStructuredPathInfo(pattern);\r\n    this.#nullRef = (this.#info.wildcardCount === 0) ? getStatePropertyRef(this.#info, null) : null;\r\n    this.#filters = filters;\r\n  }\r\n  getValue(state:IReadonlyStateProxy | IWritableStateProxy, handler:IReadonlyStateHandler | IWritableStateHandler): any {\r\n    let value;\r\n    if (SetByRefSymbol in state) {\r\n      // WritableStateProxy\r\n      value = getByRefWritable(this.binding.engine.state, this.ref, state as IWritableStateProxy, handler as IWritableStateHandler);\r\n    } else {\r\n      // ReadonlyStateProxy\r\n      value = getByRefReadonly(this.binding.engine.state, this.ref, state as IReadonlyStateProxy, handler as IReadonlyStateHandler);\r\n    }\r\n    return value;\r\n  }\r\n  getFilteredValue(state:IReadonlyStateProxy | IWritableStateProxy, handler:IReadonlyStateHandler | IWritableStateHandler): any {\r\n    let value;\r\n    if (SetByRefSymbol in state) {\r\n      // WritableStateProxy\r\n      value = getByRefWritable(this.binding.engine.state, this.ref, state as IWritableStateProxy, handler as IWritableStateHandler);\r\n    } else {\r\n      // ReadonlyStateProxy\r\n      value = getByRefReadonly(this.binding.engine.state, this.ref, state as IReadonlyStateProxy, handler as IReadonlyStateHandler);\r\n    }\r\n//    let value = state[GetByRefSymbol](this.ref);\r\n    for(let i = 0; i < this.#filters.length; i++) {\r\n      value = this.#filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  init(): void {\r\n    if (this.info.wildcardCount > 0) {\r\n      const lastWildcardPath = this.info.lastWildcardPath ?? \r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: 'Wildcard last parentPath is null',\r\n          context: { where: 'BindingState.init', pattern: this.#pattern },\r\n          docsUrl: '/docs/error-codes.md#bind',\r\n          severity: 'error',\r\n        });\r\n      this.#loopContext = this.binding.parentBindContent.currentLoopContext?.find(lastWildcardPath) ?? \r\n        raiseError({\r\n          code: 'BIND-201',\r\n          message: 'LoopContext is null',\r\n          context: { where: 'BindingState.init', lastWildcardPath },\r\n          docsUrl: '/docs/error-codes.md#bind',\r\n          severity: 'error',\r\n        });\r\n      this.#ref = null;\r\n    }\r\n    this.binding.engine.saveBinding(this.ref, this.binding);\r\n  }\r\n  assignValue(writeState: IWritableStateProxy, handler: IWritableStateHandler, value: any) {\r\n    setByRef(this.binding.engine.state, this.ref, value, writeState, handler);\r\n//    writeState[SetByRefSymbol](this.ref, value);\r\n  }\r\n}\r\n\r\nexport const createBindingState: CreateBindingStateFn = \r\n(name: string, filterTexts: IFilterText[]) => \r\n  (binding:IBinding, filters:FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts); // ToDo:ここは、メモ化できる\r\n    return new BindingState(binding, name, filterFns);\r\n  }\r\n","import { createFilters } from \"../../BindingBuilder/createFilters.js\";\r\nimport { IFilterText } from \"../../BindingBuilder/types\";\r\nimport { Filters, FilterWithOptions } from \"../../Filter/types\";\r\nimport { ILoopContext } from \"../../LoopContext/types.js\";\r\nimport { IReadonlyStateHandler, IReadonlyStateProxy, IWritableStateHandler, IWritableStateProxy } from \"../../StateClass/types\";\r\nimport { IStatePropertyRef } from \"../../StatePropertyRef/types.js\";\r\nimport { raiseError } from \"../../utils.js\";\r\nimport { IBinding } from \"../types\";\r\nimport { CreateBindingStateFn, IBindingState } from \"./types\";\r\n\r\n/**\r\n * BindingStateIndexクラスは、forバインディング等のループ内で利用される\r\n * インデックス値（$1, $2, ...）のバインディング状態を管理する実装です。\r\n *\r\n * 主な役割:\r\n * - ループコンテキストからインデックス値を取得し、value/filteredValueで参照可能にする\r\n * - バインディング時にbindingsByListIndexへ自身を登録し、依存解決や再描画を効率化\r\n * - フィルタ適用にも対応\r\n *\r\n * 設計ポイント:\r\n * - pattern（例: \"$1\"）からインデックス番号を抽出し、ループコンテキストから該当インデックスを取得\r\n * - initでループコンテキストやlistIndexRefを初期化し、バインディング情報をエンジンに登録\r\n * - assignValueは未実装（インデックスは書き換え不可のため）\r\n * - createBindingStateIndexファクトリでフィルタ適用済みインスタンスを生成\r\n */\r\nclass BindingStateIndex implements IBindingState {\r\n  #binding     : IBinding;\r\n  #indexNumber : number;\r\n  #filters     : Filters;\r\n  #loopContext : ILoopContext | null = null;\r\n  get pattern(): string {\r\n    return raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Not implemented',\r\n      context: { where: 'BindingStateIndex.pattern' },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n    });\r\n  }\r\n  get info() {\r\n    return raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Not implemented',\r\n      context: { where: 'BindingStateIndex.info' },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n    });\r\n  }\r\n  get listIndex() {\r\n    return this.#loopContext?.listIndex ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: 'listIndex is null',\r\n      context: { where: 'BindingStateIndex.listIndex' },\r\n      docsUrl: '/docs/error-codes.md#list',\r\n    });\r\n  }\r\n  get ref() {\r\n    return this.#loopContext?.ref ?? raiseError({\r\n      code: 'STATE-202',\r\n      message: 'ref is null',\r\n      context: { where: 'BindingStateIndex.ref' },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n  }\r\n  get filters() {\r\n    return this.#filters;\r\n  }\r\n  get binding() {\r\n    return this.#binding;\r\n  }\r\n  constructor(\r\n    binding: IBinding, \r\n    pattern: string, \r\n    filters: Filters\r\n  ) {\r\n    this.#binding = binding;\r\n    const indexNumber = Number(pattern.slice(1));\r\n    if (isNaN(indexNumber)) {\r\n      raiseError({\r\n        code: 'BIND-202',\r\n        message: 'Pattern is not a number',\r\n        context: { where: 'BindingStateIndex.constructor', pattern },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    this.#indexNumber = indexNumber;\r\n    this.#filters = filters;\r\n  }\r\n  getValue(state: IReadonlyStateProxy | IWritableStateProxy, handler:IReadonlyStateHandler | IWritableStateHandler) {\r\n    return this.listIndex?.index ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: 'listIndex is null',\r\n      context: { where: 'BindingStateIndex.getValue' },\r\n      docsUrl: '/docs/error-codes.md#list',\r\n    });\r\n  }\r\n  getFilteredValue(state: IReadonlyStateProxy | IWritableStateProxy, handler:IReadonlyStateHandler | IWritableStateHandler) {\r\n    let value = this.listIndex?.index ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: 'listIndex is null',\r\n      context: { where: 'BindingStateIndex.getFilteredValue' },\r\n      docsUrl: '/docs/error-codes.md#list',\r\n    });\r\n    for(let i = 0; i < this.#filters.length; i++) {\r\n      value = this.#filters[i](value);\r\n    }\r\n    return value;\r\n  }\r\n  init(): void {\r\n    const loopContext = this.binding.parentBindContent.currentLoopContext ??\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'LoopContext is null',\r\n        context: { where: 'BindingStateIndex.init' },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n      });\r\n    const loopContexts = loopContext.serialize();\r\n    this.#loopContext = loopContexts[this.#indexNumber - 1] ??\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Current loopContext is null',\r\n        context: { where: 'BindingStateIndex.init', indexNumber: this.#indexNumber },\r\n        docsUrl: '/docs/error-codes.md#bind',\r\n      });\r\n    const bindings = this.binding.engine.bindingsByListIndex.get(this.listIndex);\r\n    if (bindings === undefined) {\r\n      this.binding.engine.bindingsByListIndex.set(this.listIndex, new Set([this.binding]));\r\n    } else {\r\n      bindings.add(this.binding);\r\n    }\r\n  }\r\n  assignValue(writeState:IWritableStateProxy, handler:IWritableStateHandler, value:any): void {\r\n    raiseError({\r\n      code: 'BIND-301',\r\n      message: 'Not implemented',\r\n      context: { where: 'BindingStateIndex.assignValue' },\r\n      docsUrl: '/docs/error-codes.md#bind',\r\n    });\r\n  }\r\n}\r\n\r\nexport const createBindingStateIndex: CreateBindingStateFn = \r\n(name: string, filterTexts: IFilterText[]) => \r\n  (binding:IBinding, filters:FilterWithOptions) => {\r\n    const filterFns = createFilters(filters, filterTexts); // ToDo:ここは、メモ化できる\r\n\r\n    return new BindingStateIndex(binding, name, filterFns);\r\n  }\r\n","import { createBindingState } from \"../DataBinding/BindingState/BindingState.js\";\r\nimport { createBindingStateIndex } from \"../DataBinding/BindingState/BindingStateIndex.js\";\r\nimport { CreateBindingStateByStateFn } from \"../DataBinding/BindingState/types\";\r\nimport { IFilterText } from \"./types\";\r\n\r\nconst ereg = new RegExp(/^\\$\\d+$/);\r\n\r\n/**\r\n * バインディング対象の状態プロパティ名とフィルタ情報から、\r\n * 適切なバインディング状態生成関数（CreateBindingStateByStateFn）を返すユーティリティ。\r\n *\r\n * - プロパティ名が \"$数字\"（例: \"$1\"）の場合は createBindingStateIndex を使用（インデックスバインディング用）\r\n * - それ以外は通常の createBindingState を使用\r\n *\r\n * @param name        バインディング対象の状態プロパティ名\r\n * @param filterTexts フィルタ情報\r\n * @returns           バインディング状態生成関数\r\n */\r\nexport function getBindingStateCreator(\r\n  name       : string, \r\n  filterTexts: IFilterText[]\r\n): CreateBindingStateByStateFn {\r\n  if (ereg.test(name)) {\r\n    // \"$数字\"形式の場合はインデックスバインディング用の生成関数を返す\r\n    return createBindingStateIndex(name, filterTexts);\r\n  } else {\r\n    // 通常のプロパティ名の場合は標準の生成関数を返す\r\n    return createBindingState(name, filterTexts);\r\n  }\r\n}","import { raiseError } from \"../utils.js\";\r\nimport { NodeType } from \"./types\";\r\n\r\nconst createNodeKey = (node:Node):string => node.constructor.name + \"\\t\" + ((node instanceof Comment) ? (node.textContent?.[2] ?? \"\") : \"\");\r\n\r\ntype NodeTypeByNodeKey = {\r\n  [nodeKey:string]:NodeType;\r\n};\r\n\r\nconst nodeTypeByNodeKey:NodeTypeByNodeKey = {};\r\n\r\nconst getNodeTypeByNode = (node:Node):NodeType =>\r\n  (node instanceof Comment && node.textContent?.[2] === \":\") ? \"Text\" : \r\n  (node instanceof HTMLElement) ? \"HTMLElement\" :\r\n  (node instanceof Comment && node.textContent?.[2] === \"|\") ? \"Template\" : \r\n  (node instanceof SVGElement) ? \"SVGElement\" : raiseError(`Unknown NodeType: ${node.nodeType}`);\r\n\r\n/**\r\n * ノードのタイプ（\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\"）を判定・キャッシュするユーティリティ関数。\r\n *\r\n * - コメントノードの場合、3文字目が \":\" なら \"Text\"、\"|\" なら \"Template\" と判定\r\n * - HTMLElement, SVGElement もそれぞれ判定\r\n * - 未知のノード型はエラー\r\n * - ノードごとに一意なキー（constructor名＋コメント種別）でキャッシュし、再判定を省略\r\n *\r\n * @param node    判定対象のノード\r\n * @param nodeKey キャッシュ用のノードキー（省略時は自動生成）\r\n * @returns       ノードタイプ（NodeType）\r\n */\r\nexport function getNodeType(\r\n  node   : Node, \r\n  nodeKey: string = createNodeKey(node)\r\n): NodeType {\r\n  return nodeTypeByNodeKey[nodeKey] ?? (nodeTypeByNodeKey[nodeKey] = getNodeTypeByNode(node));\r\n}\r\n","import { IFilterText, IBindText } from \"./types\";\r\n\r\nconst trim = (s:string):string => s.trim();\r\n\r\nconst has = (s:string):boolean => s.length > 0; // check length\r\n\r\nconst re = new RegExp(/^#(.*)#$/);\r\nconst decode = (s:string):string => {\r\n  const m = re.exec(s);\r\n  return m ? decodeURIComponent(m[1]) : s;\r\n};\r\n\r\n/**\r\n * parse filter part\r\n * \"eq,100|falsey\" ---> [Filter(eq, [100]), Filter(falsey)]\r\n */\r\nconst parseFilter = (text:string): IFilterText => {\r\n  const [name, ...options] = text.split(\",\").map(trim);\r\n  return {name, options:options.map(decode)};\r\n};\r\n\r\ntype ReturnParseStateProperty = {property:string,filters:IFilterText[]};\r\n/**\r\n * parse expression\r\n * \"value|eq,100|falsey\" ---> [\"value\", Filter[]]\r\n */\r\nconst parseProperty = (text:string): ReturnParseStateProperty => {\r\n  const [property, ...filterTexts] = text.split(\"|\").map(trim);\r\n  return {property, filters:filterTexts.map(parseFilter)};\r\n};\r\n\r\n/**\r\n * parse expressions\r\n * \"textContent:value|eq,100|falsey\" ---> [\"textContent\", \"value\", Filter[eq, falsey]]\r\n */\r\nconst parseExpression = (expression:string): IBindText => {\r\n  const [ bindExpression, decoratesExpression = null ] = expression.split(\"@\").map(trim);\r\n  const decorates = decoratesExpression ? decoratesExpression.split(\",\").map(trim) : [];\r\n  const [nodePropertyText, statePropertyText] = bindExpression.split(\":\").map(trim);\r\n  const { property:nodeProperty, filters:inputFilterTexts } = parseProperty(nodePropertyText);\r\n  const { property:stateProperty, filters:outputFilterTexts } = parseProperty(statePropertyText);\r\n  return { nodeProperty, stateProperty, inputFilterTexts, outputFilterTexts, decorates };\r\n};\r\n\r\n/**\r\n * parse bind text and return BindText[]\r\n */\r\nconst parseExpressions = (text:string): IBindText[] => {\r\n  return text.split(\";\").map(trim).filter(has).map(s => parseExpression(s));\r\n};\r\n\r\nconst cache:{[key:string]: IBindText[]} = {};\r\n\r\n/**\r\n * バインドテキスト（data-bind属性やコメント等から取得した文字列）を解析し、\r\n * バインディング情報（IBindText[]）に変換するユーティリティ関数群。\r\n *\r\n * - フィルターやデコレータ、プロパティ名などをパースし、構造化データとして返す\r\n * - \"textContent:value|eq,100|falsey@decorate1,decorate2\" のような複雑な記法にも対応\r\n * - セミコロン区切りで複数バインドもサポート\r\n * - パース結果はキャッシュし、同じ入力の再解析を防止\r\n *\r\n * @param text バインドテキスト\r\n * @returns    解析済みバインディング情報（IBindText[]）\r\n */\r\nexport function parseBindText(\r\n  text: string\r\n): IBindText[] {\r\n  if (text.trim() === \"\") {\r\n    return [];\r\n  }\r\n  return cache[text] ?? (cache[text] = parseExpressions(text));\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\nconst DATASET_BIND_PROPERTY = 'data-bind';\r\n\r\nconst removeAttributeFromElement = (node:Node):void => {\r\n  const element = node as Element;\r\n  element.removeAttribute(DATASET_BIND_PROPERTY);\r\n}\r\n\r\ntype RemoveAttributeByNodeType = {\r\n  [key in NodeType]: ((node:Node)=>void) | undefined;\r\n}\r\n\r\nconst removeAttributeByNodeType:RemoveAttributeByNodeType = {\r\n  HTMLElement: removeAttributeFromElement,\r\n  SVGElement : removeAttributeFromElement,\r\n  Text       : undefined,\r\n  Template   : undefined,\r\n}\r\n\r\n/**\r\n * 指定ノードから data-bind 属性を削除するユーティリティ関数。\r\n *\r\n * - ノードタイプ（HTMLElement, SVGElement）の場合のみ data-bind 属性を削除\r\n * - Text, Template ノードは対象外\r\n *\r\n * @param node     対象ノード\r\n * @param nodeType ノードタイプ（\"HTMLElement\" | \"SVGElement\" | \"Text\" | \"Template\"）\r\n * @returns        なし\r\n */\r\nexport function removeDataBindAttribute(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n):void {\r\n  return removeAttributeByNodeType[nodeType]?.(node);\r\n}\r\n","import { NodeType } from \"./types\";\r\n\r\nconst replaceTextNodeText = (node:Node):Node => {\r\n  const textNode = document.createTextNode(\"\");\r\n  node.parentNode?.replaceChild(textNode, node);\r\n  return textNode;\r\n}\r\n\r\ntype ReplaceTextNodeFn = {\r\n  [key in NodeType]: ((node:Node)=>Node) | undefined;\r\n}\r\n\r\nconst replaceTextNodeFn:ReplaceTextNodeFn = {\r\n  Text       : replaceTextNodeText,\r\n  HTMLElement: undefined,\r\n  Template   : undefined,\r\n  SVGElement : undefined\r\n}\r\n\r\n/**\r\n * コメントノードをテキストノードに置き換えるユーティリティ関数。\r\n *\r\n * - ノードタイプが \"Text\" の場合のみ、コメントノードを空のテキストノードに置換する\r\n * - それ以外のノードタイプ（HTMLElement, Template, SVGElement）は何もしない\r\n *\r\n * @param node     対象ノード\r\n * @param nodeType ノードタイプ（\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\"）\r\n * @returns        置換後のノード（または元のノード）\r\n */\r\nexport function replaceTextNodeFromComment(\r\n  node    : Node, \r\n  nodeType: NodeType\r\n): Node {\r\n  return replaceTextNodeFn[nodeType]?.(node) ?? node;\r\n}\r\n","import { getAbsoluteNodePath } from \"./getAbsoluteNodePath.js\";\r\nimport { getBindingNodeCreator } from \"./getBindingNodeCreator.js\";\r\nimport { getBindingStateCreator } from \"./getBindingStateCreator.js\";\r\nimport { getDataBindText } from \"./getDataBindText.js\";\r\nimport { getNodeType } from \"./getNodeType.js\";\r\nimport { parseBindText } from \"./parseBindText.js\";\r\nimport { removeDataBindAttribute } from \"./removeDataBindAttribute.js\";\r\nimport { replaceTextNodeFromComment } from \"./replaceTextNodeFromComment.js\";\r\nimport { IBindingCreator, IBindText, IDataBindAttributes, NodePath, NodeType } from \"./types\";\r\n\r\n/**\r\n * DataBindAttributesクラスは、DOMノードからバインディング情報を抽出・解析し、\r\n * バインディング生成に必要な情報（ノード種別・パス・バインドテキスト・クリエイター）を管理します。\r\n *\r\n * - ノード種別やパスを特定\r\n * - data-bind属性やコメントノードからバインドテキストを取得・解析\r\n * - バインドテキストごとにバインディング生成関数（ノード用・状態用）を用意\r\n * - data-bind属性やコメントノードはパース後に削除・置換\r\n *\r\n * これにより、テンプレート内のバインディング定義を一元的に管理し、後続のバインディング構築処理を効率化します。\r\n */\r\nclass DataBindAttributes implements IDataBindAttributes {\r\n  nodeType     : NodeType; // ノードの種別\r\n  nodePath     : NodePath; // ノードのルート\r\n  bindTexts    : IBindText[]; // BINDテキストの解析結果\r\n  creatorByText: Map<IBindText, IBindingCreator> = new Map(); // BINDテキストからバインディングクリエイターを取得\r\n  constructor(node: Node) {\r\n    this.nodeType = getNodeType(node);\r\n    const text = getDataBindText(this.nodeType, node);\r\n\r\n    // コメントノードの場合はTextノードに置換（template.contentが書き換わる点に注意）\r\n    node = replaceTextNodeFromComment(node, this.nodeType);\r\n\r\n    // data-bind属性を削除（パース後は不要なため）\r\n    removeDataBindAttribute(node, this.nodeType);\r\n\r\n    this.nodePath = getAbsoluteNodePath(node);\r\n    this.bindTexts = parseBindText(text);\r\n\r\n    // 各バインドテキストごとにバインディング生成関数を用意\r\n    for(let i = 0; i < this.bindTexts.length; i++) {\r\n      const bindText = this.bindTexts[i];\r\n      const creator: IBindingCreator = {\r\n        createBindingNode : getBindingNodeCreator(\r\n          node, \r\n          bindText.nodeProperty, \r\n          bindText.inputFilterTexts,\r\n          bindText.decorates\r\n        ),\r\n        createBindingState: getBindingStateCreator(\r\n          bindText.stateProperty, \r\n          bindText.outputFilterTexts\r\n        ),\r\n      }\r\n      this.creatorByText.set(bindText, creator);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * 指定ノードからDataBindAttributesインスタンスを生成するファクトリ関数。\r\n */\r\nexport function createDataBindAttributes(node: Node): IDataBindAttributes {\r\n  return new DataBindAttributes(node);\r\n}","import { COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants.js\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { NodeType } from \"./types\";\r\n\r\nconst COMMENT_EMBED_MARK_LEN = COMMENT_EMBED_MARK.length;\r\nconst COMMENT_TEMPLATE_MARK_LEN = COMMENT_TEMPLATE_MARK.length;\r\n\r\n/**\r\n * ノード種別ごとにdata-bindテキスト（バインディング定義文字列）を取得するユーティリティ関数。\r\n *\r\n * - Textノード: コメントマーク以降のテキストを取得し、\"textContent:\"を付与\r\n * - HTMLElement: data-bind属性値を取得\r\n * - Templateノード: コメントマーク以降のIDからテンプレートを取得し、そのdata-bind属性値を取得\r\n * - SVGElement: data-bind属性値を取得\r\n *\r\n * @param nodeType ノード種別（\"Text\" | \"HTMLElement\" | \"Template\" | \"SVGElement\"）\r\n * @param node     対象ノード\r\n * @returns        バインディング定義文字列\r\n */\r\nexport function getDataBindText(nodeType: NodeType, node: Node): string {\r\n  switch (nodeType) {\r\n    case \"Text\": {\r\n      const text = node.textContent?.slice(COMMENT_EMBED_MARK_LEN).trim() ?? \"\";\r\n      return \"textContent:\" + text;\r\n    }\r\n    case \"HTMLElement\": {\r\n      return (node as HTMLElement).getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    case \"Template\": {\r\n      const text = node.textContent?.slice(COMMENT_TEMPLATE_MARK_LEN).trim();\r\n      const id = Number(text);\r\n      const template = getTemplateById(id) ?? raiseError(`Template not found: ${text}`);\r\n      return template.getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    case \"SVGElement\": {\r\n      return (node as SVGElement).getAttribute(DATA_BIND_ATTRIBUTE) ?? \"\";\r\n    }\r\n    default:\r\n      return \"\";\r\n  }\r\n}","import { NodePath } from \"./types\";\r\n\r\n/**\r\n * 指定ノードの「親からのインデックス」をルートまで辿り、絶対パス（NodePath）として返すユーティリティ関数。\r\n *\r\n * 例: ルートから見て [0, 2, 1] のような配列を返す。\r\n *     これは「親→子→孫…」とたどったときの各階層でのインデックスを表す。\r\n *\r\n * @param node 対象のDOMノード\r\n * @returns    ルートからこのノードまでのインデックス配列（NodePath）\r\n */\r\nexport function getAbsoluteNodePath(node: Node): NodePath {\r\n  let routeIndexes: NodePath = [];\r\n  while(node.parentNode !== null) {\r\n    const childNodes = Array.from(node.parentNode.childNodes) as Node[];\r\n    routeIndexes = [ childNodes.indexOf(node), ...routeIndexes ];\r\n    node = node.parentNode;\r\n  }\r\n  return routeIndexes;\r\n}","import { DATA_BIND_ATTRIBUTE, COMMENT_EMBED_MARK, COMMENT_TEMPLATE_MARK } from \"../constants.js\";\r\n\r\n/**\r\n * \"@@:\"もしくは\"@@|\"で始まるコメントノードを取得する\r\n */\r\nfunction isCommentNode(node: Node): boolean {\r\n  return node instanceof Comment && (\r\n    (node.textContent?.indexOf(COMMENT_EMBED_MARK) === 0) || (node.textContent?.indexOf(COMMENT_TEMPLATE_MARK) === 0)\r\n  );\r\n} \r\n\r\n/**\r\n * 指定ノード以下のツリーから「data-bind属性を持つ要素」または\r\n * 「特定のマーク（@@: または @@|）で始まるコメントノード」をすべて取得するユーティリティ関数。\r\n *\r\n * - Elementノードの場合: data-bind属性があるものだけを抽出\r\n * - Commentノードの場合: COMMENT_EMBED_MARK または COMMENT_TEMPLATE_MARK で始まるものだけを抽出\r\n * - DOMツリー全体をTreeWalkerで効率的に走査\r\n *\r\n * @param root 探索の起点となるノード\r\n * @returns    条件に合致したノードの配列\r\n */\r\nexport function getNodesHavingDataBind(root: Node): Node[] {\r\n  const nodes: Node[] = [];\r\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, {\r\n    acceptNode(node:Node) {\r\n      return (node instanceof Element) ? \r\n        (node.hasAttribute(DATA_BIND_ATTRIBUTE) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP)\r\n        : (isCommentNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\r\n    }\r\n  });\r\n  while (walker.nextNode()) {\r\n    nodes.push(walker.currentNode);\r\n  }\r\n  return nodes;\r\n}\r\n\r\n","import { createDataBindAttributes } from \"./createDataBindAttributes.js\";\r\nimport { getNodesHavingDataBind } from \"./getNodesHavingDataBind.js\";\r\nimport { IDataBindAttributes } from \"./types\";\r\n\r\nconst listDataBindAttributesById: {[key:number]:IDataBindAttributes[]} = {};\r\n\r\nconst listPathsSetById: {[key:number]:Set<string>} = {};\r\n\r\nconst pathsSetById: {[key:number]:Set<string>} = {};\r\n\r\n/**\r\n * テンプレートの DocumentFragment から data-bind 対象ノードを抽出し、\r\n * IDataBindAttributes の配列へ変換するユーティリティ。\r\n */\r\nfunction getDataBindAttributesFromTemplate(content: DocumentFragment): IDataBindAttributes[] {\r\n  const nodes = getNodesHavingDataBind(content);\r\n  return nodes.map(node => createDataBindAttributes(node));\r\n}\r\n\r\n/**\r\n * テンプレート内のバインディング情報（data-bind 属性やコメント）を解析・登録し、\r\n * テンプレート ID ごとに属性リストと状態パス集合をキャッシュする。\r\n *\r\n * - getNodesHavingDataBind → createDataBindAttributes の順で解析\r\n * - for バインディングの stateProperty は listPaths にも登録\r\n *\r\n * @param id      テンプレート ID\r\n * @param content テンプレートの DocumentFragment\r\n * @param rootId  ルートテンプレート ID（省略時は id と同じ）\r\n * @returns       解析済みバインディング属性リスト\r\n */\r\nexport function registerDataBindAttributes(\r\n  id     : number, \r\n  content: DocumentFragment,\r\n  rootId : number = id\r\n): IDataBindAttributes[] {\r\n  const dataBindAttributes = getDataBindAttributesFromTemplate(content);\r\n  const paths = pathsSetById[rootId] ?? (pathsSetById[rootId] = new Set<string>());\r\n  const listPaths = listPathsSetById[rootId] ?? (listPathsSetById[rootId] = new Set<string>());\r\n  for(let i = 0; i < dataBindAttributes.length; i++) {\r\n    const attribute = dataBindAttributes[i];\r\n    for(let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      paths.add(bindText.stateProperty);\r\n      if (bindText.nodeProperty === \"for\") {\r\n        listPaths.add(bindText.stateProperty);\r\n      }\r\n    }\r\n  }\r\n  return listDataBindAttributesById[id] = dataBindAttributes;\r\n}\r\n\r\n/** テンプレート ID からバインディング属性リストを取得 */\r\nexport const getDataBindAttributesById = (id: number): IDataBindAttributes[] => {\r\n  return listDataBindAttributesById[id];\r\n}\r\n\r\n/** テンプレート ID から for バインディングの stateProperty 集合を取得 */\r\nexport const getListPathsSetById = (id: number): Set<string> => {\r\n  return listPathsSetById[id] ?? [];\r\n};\r\n\r\n/** テンプレート ID から全バインディングの stateProperty 集合を取得 */\r\nexport const getPathsSetById = (id: number): Set<string> => {\r\n  return pathsSetById[id] ?? [];\r\n};","/**\r\n * HTMLTemplateElement を ID で登録・取得するための管理モジュール。\r\n *\r\n * 役割:\r\n * - registerTemplate: 指定 ID でテンプレートを登録（空テキスト除去と data-bind 解析を実行）\r\n * - getTemplateById: 指定 ID のテンプレートを取得（未登録時はエラー）\r\n *\r\n * Throws（getTemplateById）:\r\n * - TMP-001 Template not found: 未登録のテンプレート ID を要求\r\n */\r\nimport { registerDataBindAttributes } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { removeEmptyTextNodes } from \"./removeEmptyTextNodes.js\";\r\n\r\nconst templateById:Record<number, HTMLTemplateElement> = {};\r\n\r\n/**\r\n * テンプレートを ID で登録し、内部インデックスと data-bind 情報を構築する。\r\n *\r\n * @param id       テンプレート ID\r\n * @param template HTMLTemplateElement\r\n * @param rootId   ルートテンプレート ID（ネスト解析用）\r\n * @returns       登録した ID\r\n */\r\nexport function registerTemplate(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number\r\n): number {\r\n  removeEmptyTextNodes(template.content);\r\n  registerDataBindAttributes(id, template.content, rootId);  \r\n  templateById[id] = template;\r\n  return id;\r\n}\r\n\r\n/**\r\n * 登録済みテンプレートを取得する。\r\n *\r\n * @throws TMP-001 Template not found\r\n */\r\nexport function getTemplateById(id: number): HTMLTemplateElement {\r\n  return templateById[id] ?? raiseError({\r\n    code: \"TMP-001\",\r\n    message: `Template not found: ${id}`,\r\n    context: { where: 'registerTemplate.getTemplateById', templateId: id },\r\n    docsUrl: \"./docs/error-codes.md#tmp\",\r\n  });\r\n}","/**\r\n * removeEmptyTextNodes.ts\r\n *\r\n * DocumentFragment内の空テキストノードを削除するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - content（DocumentFragment）の直下にある空白のみのテキストノードを検出し、削除する\r\n *\r\n * 設計ポイント:\r\n * - childNodesをArray.fromで配列化し、forEachで全ノードを走査\r\n * - nodeTypeがTEXT_NODEかつ、nodeValueが空白のみの場合にremoveChildで削除\r\n * - テンプレート処理やクリーンなDOM生成時に利用\r\n */\r\nexport function removeEmptyTextNodes(content:DocumentFragment):void {\r\n  Array.from(content.childNodes).forEach(node => {\r\n    if (node.nodeType === Node.TEXT_NODE && !(node.nodeValue ?? \"\").trim()) {\r\n      content.removeChild(node);\r\n    }\r\n  });  \r\n}\r\n","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IReadonlyStateProxy, IWritableStateHandler, IWritableStateProxy } from \"../StateClass/types\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { IRenderer } from \"../Updater/types\";\r\nimport { CreateBindingNodeByNodeFn, IBindingNode } from \"./BindingNode/types\";\r\nimport { CreateBindingStateByStateFn, IBindingState } from \"./BindingState/types\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\n\r\n/**\r\n * Bindingクラスは、1つのバインディング（ノードと状態の対応）を管理する中核的な実装です。\r\n *\r\n * 主な役割:\r\n * - DOMノードと状態（State）を結びつけるバインディングノード（bindingNode）とバインディング状態（bindingState）の生成・管理\r\n * - バインディングの初期化（init）、再描画（render）、状態値の更新（updateStateValue）などの処理を提供\r\n * - バージョン管理により、不要な再描画を防止\r\n *\r\n * 設計ポイント:\r\n * - createBindingNode, createBindingStateファクトリで柔軟なバインディング構造に対応\r\n * - renderでバージョン差分がある場合のみバインディングノードを更新\r\n * - 双方向バインディング時はupdateStateValueで状態プロキシに値を反映\r\n * - createBinding関数で一貫したバインディング生成を提供\r\n */\r\nclass Binding implements IBinding {\r\n  parentBindContent: IBindContent;\r\n  node             : Node;\r\n  engine           : IComponentEngine;\r\n  bindingNode      : IBindingNode;\r\n  bindingState     : IBindingState;\r\n  version          : number | undefined;\r\n  constructor(\r\n    parentBindContent : IBindContent,\r\n    node              : Node,\r\n    engine            : IComponentEngine,\r\n    createBindingNode : CreateBindingNodeByNodeFn, \r\n    createBindingState: CreateBindingStateByStateFn,\r\n  ) {\r\n    this.parentBindContent = parentBindContent\r\n    this.node = node;\r\n    this.engine = engine\r\n    this.bindingNode = createBindingNode(this, node, engine.inputFilters);\r\n    this.bindingState = createBindingState(this, engine.outputFilters);\r\n  }\r\n\r\n  get bindContents(): IBindContent[] {\r\n    return this.bindingNode.bindContents;\r\n  }\r\n\r\n  init() {\r\n    this.bindingNode.init();\r\n    this.bindingState.init();\r\n  }\r\n\r\n  updateStateValue(writeState:IWritableStateProxy, handler: IWritableStateHandler, value: any) {\r\n    return this.bindingState.assignValue(writeState, handler, value);\r\n  }\r\n\r\n  notifyRedraw(refs: IStatePropertyRef[]) {\r\n    this.bindingNode.notifyRedraw(refs);\r\n  }\r\n\r\n  applyChange(renderer: IRenderer): void {\r\n    if (renderer.updatedBindings.has(this)) return;\r\n    this.bindingNode.applyChange(renderer);\r\n  }\r\n}\r\n\r\n/**\r\n * バインディング生成用ファクトリ関数\r\n * - 各種ファクトリ・エンジン・ノード情報からBindingインスタンスを生成\r\n */\r\nexport function createBinding(\r\n  parentBindContent : IBindContent,\r\n  node              : Node, \r\n  engine            : IComponentEngine, \r\n  createBindingNode : CreateBindingNodeByNodeFn, \r\n  createBindingState: CreateBindingStateByStateFn\r\n): IBinding {\r\n  return new Binding(\r\n    parentBindContent, \r\n    node, \r\n    engine, \r\n    createBindingNode, \r\n    createBindingState\r\n  );\r\n}","/**\r\n * createLoopContext.ts\r\n *\r\n * ループバインディング（for等）で利用するLoopContext（ループコンテキスト）管理クラスとファクトリ関数の実装です。\r\n *\r\n * 主な役割:\r\n * - ループごとのプロパティパス・インデックス・BindContentを紐付けて管理\r\n * - 親ループコンテキストの探索やキャッシュ、インデックスの再割り当て・クリアなどを提供\r\n * - ループ階層をたどるwalk/serializeや、名前でのfind検索も可能\r\n *\r\n * 設計ポイント:\r\n * - WeakRefでlistIndexを保持し、GCフレンドリーな設計\r\n * - parentLoopContextで親ループを遅延探索・キャッシュし、効率的な親子関係管理を実現\r\n * - findで名前からループコンテキストを高速検索（キャッシュ付き）\r\n * - walk/serializeでループ階層をたどる処理を簡潔に記述可能\r\n * - createLoopContextファクトリで一貫した生成・管理が可能\r\n */\r\nimport { IBindContent } from \"../DataBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { ILoopContext } from \"./types\";\r\n\r\nclass LoopContext implements ILoopContext {\r\n  #ref: IStatePropertyRef | null;\r\n  #info: IStructuredPathInfo;\r\n  #bindContent : IBindContent;\r\n  constructor(\r\n    ref: IStatePropertyRef,\r\n    bindContent: IBindContent\r\n  ) {\r\n    this.#ref = ref;\r\n    this.#info = ref.info;\r\n    this.#bindContent = bindContent;\r\n  }\r\n  get ref(): IStatePropertyRef {\r\n    return this.#ref ?? raiseError({\r\n      code: 'STATE-202',\r\n      message: 'ref is null',\r\n      context: { where: 'LoopContext.ref', path: this.#info.pattern },\r\n      docsUrl: '/docs/error-codes.md#state',\r\n    });\r\n  }\r\n  get path(): string {\r\n    return this.ref.info.pattern;\r\n  }\r\n  get info(): IStructuredPathInfo {\r\n    return this.ref.info;\r\n  }\r\n  get listIndex(): IListIndex {\r\n    return this.ref.listIndex ?? raiseError({\r\n      code: 'LIST-201',\r\n      message: 'listIndex is required',\r\n      context: { where: 'LoopContext.listIndex', path: this.#info.pattern },\r\n      docsUrl: '/docs/error-codes.md#list',\r\n    });\r\n  }\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    this.#ref = getStatePropertyRef(this.#info, listIndex);\r\n    // 構造は変わらないので、#parentLoopContext、#cacheはクリアする必要はない\r\n  }\r\n  clearListIndex():void {\r\n    this.#ref = null;\r\n  }\r\n  get bindContent(): IBindContent {\r\n    return this.#bindContent;\r\n  }\r\n\r\n  #parentLoopContext: ILoopContext | null | undefined;\r\n  get parentLoopContext(): ILoopContext | null {\r\n    if (typeof this.#parentLoopContext === \"undefined\") {\r\n      let currentBindContent: IBindContent | null = this.bindContent;\r\n      while(currentBindContent !== null) {\r\n        if (currentBindContent.loopContext !== null && currentBindContent.loopContext !== this) {\r\n          this.#parentLoopContext = currentBindContent.loopContext;\r\n          break;\r\n        }\r\n        currentBindContent = currentBindContent.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      if (typeof this.#parentLoopContext === \"undefined\") this.#parentLoopContext = null;\r\n    }\r\n    return this.#parentLoopContext;\r\n  }\r\n\r\n  #cache:Record<string, ILoopContext | null> = {};\r\n  find(name: string): ILoopContext | null {\r\n    let loopContext = this.#cache[name];\r\n    if (typeof loopContext === \"undefined\") {\r\n      let currentLoopContext: ILoopContext | null = this;\r\n      while(currentLoopContext !== null) {\r\n        if (currentLoopContext.path === name) break;\r\n        currentLoopContext = currentLoopContext.parentLoopContext;\r\n      }\r\n      loopContext = this.#cache[name] = currentLoopContext;\r\n    }\r\n    return loopContext;\r\n  }\r\n\r\n  walk(callback: (loopContext: ILoopContext) => void): void {\r\n    let currentLoopContext: ILoopContext | null = this;\r\n    while(currentLoopContext !== null) {\r\n      callback(currentLoopContext);\r\n      currentLoopContext = currentLoopContext.parentLoopContext;\r\n    }\r\n  }\r\n\r\n  serialize(): ILoopContext[] {\r\n    const results: ILoopContext[] = [];\r\n    this.walk((loopContext) => {\r\n      results.unshift(loopContext);\r\n    });\r\n    return results;\r\n  }\r\n\r\n}\r\n\r\n// 生成されたあと、IBindContentのloopContextに登録される\r\n// IBindContentにずっと保持される\r\nexport function createLoopContext(\r\n  ref: IStatePropertyRef,\r\n  bindContent: IBindContent\r\n): ILoopContext {\r\n  return new LoopContext(ref, bindContent);\r\n}","import { resolveNodeFromPath } from \"../BindingBuilder/resolveNodeFromPath.js\";\r\nimport { ILoopContext } from \"../LoopContext/types\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { createBinding } from \"./Binding.js\";\r\nimport { IBindContent, IBinding } from \"./types\";\r\nimport { createLoopContext } from \"../LoopContext/createLoopContext.js\";\r\nimport { getDataBindAttributesById } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { hasLazyLoadComponents, loadLazyLoadComponent } from \"../WebComponents/loadFromImportMap.js\";\r\nimport { IListIndex } from \"../ListIndex/types.js\";\r\nimport { IRenderer } from \"../Updater/types.js\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types.js\";\r\nimport { BindingNode } from \"./BindingNode/BindingNode.js\";\r\n\r\n/**\r\n * 指定テンプレートIDから DocumentFragment を生成するヘルパー。\r\n *\r\n * Params:\r\n * - id: 登録済みテンプレートID\r\n *\r\n * Returns:\r\n * - テンプレート内容を複製した DocumentFragment\r\n *\r\n * Throws:\r\n * - BIND-101 Template not found: 未登録IDが指定された場合\r\n */\r\nfunction createContent(id: number): DocumentFragment {\r\n  const template = getTemplateById(id) ?? \r\n    raiseError({\r\n      code: \"BIND-101\",\r\n      message: `Template not found: ${id}`,\r\n      context: { where: 'BindContent.createContent', templateId: id },\r\n      docsUrl: \"./docs/error-codes.md#bind\",\r\n    });\r\n  const fragment = document.importNode(template.content, true);\r\n  if (hasLazyLoadComponents()) {\r\n    const lazyLoadElements = fragment.querySelectorAll(\":not(:defined)\");\r\n    for(let i = 0; i < lazyLoadElements.length; i++) {\r\n      const tagName = lazyLoadElements[i].tagName.toLowerCase();\r\n      loadLazyLoadComponent(tagName);\r\n    }\r\n  }\r\n  return fragment;\r\n}\r\n\r\n/**\r\n * テンプレート内の data-bind 情報から IBinding 配列を構築する。\r\n *\r\n * Params:\r\n * - bindContent: 親 BindContent\r\n * - id: テンプレートID\r\n * - engine: コンポーネントエンジン\r\n * - content: テンプレートから複製したフラグメント\r\n *\r\n * Returns:\r\n * - 生成された IBinding の配列\r\n *\r\n * Throws:\r\n * - BIND-101 Data-bind is not set: テンプレートに data-bind 情報が未登録\r\n * - BIND-102 Node not found: パスで指すノードが見つからない\r\n * - BIND-103 Creator not found: 対応する BindingCreator が未登録\r\n */\r\nfunction createBindings(\r\n  bindContent: IBindContent, \r\n  id         : number, \r\n  engine     : IComponentEngine, \r\n  content    : DocumentFragment\r\n): [IBinding[], IBinding[]] {\r\n  const attributes = getDataBindAttributesById(id) ?? \r\n    raiseError({\r\n      code: \"BIND-101\",\r\n      message: \"Data-bind is not set\",\r\n      context: { where: 'BindContent.createBindings', templateId: id },\r\n      docsUrl: \"./docs/error-codes.md#bind\",\r\n    });\r\n  const bindings: IBinding[] = [];\r\n  const blockBindings: IBinding[] = [];\r\n  for(let i = 0; i < attributes.length; i++) {\r\n    const attribute = attributes[i];\r\n    const node = resolveNodeFromPath(content, attribute.nodePath) ?? \r\n      raiseError({\r\n        code: \"BIND-102\",\r\n        message: `Node not found: ${attribute.nodePath}`,\r\n        context: { where: 'BindContent.createBindings', templateId: id, nodePath: attribute.nodePath },\r\n        docsUrl: \"./docs/error-codes.md#bind\",\r\n      });\r\n    for(let j = 0; j < attribute.bindTexts.length; j++) {\r\n      const bindText = attribute.bindTexts[j];\r\n      const creator = attribute.creatorByText.get(bindText) ?? \r\n        raiseError({\r\n          code: \"BIND-103\",\r\n          message: `Creator not found: ${bindText}`,\r\n          context: { where: 'BindContent.createBindings', templateId: id, bindText },\r\n          docsUrl: \"./docs/error-codes.md#bind\",\r\n        });\r\n      const binding = createBinding(\r\n        bindContent, \r\n        node, \r\n        engine, \r\n        creator.createBindingNode, \r\n        creator.createBindingState\r\n      );\r\n      if (binding.bindingNode.isBlock) {\r\n        blockBindings.push(binding);\r\n      }\r\n      bindings.push(binding);\r\n    }\r\n  }\r\n  return [bindings, blockBindings];\r\n}\r\n\r\n/**\r\n * BindContent は、テンプレートから生成された DOM 断片（DocumentFragment）と\r\n * そのバインディング情報（IBinding[]）を管理する実装です。\r\n *\r\n * 主な役割:\r\n * - テンプレートIDから DOM 断片を生成し、バインディング情報を構築\r\n * - mount/mountBefore/mountAfter/unmount で DOM への挿入・削除を制御\r\n * - applyChange で各 IBinding に更新を委譲\r\n * - ループ時の LoopContext やリストインデックス管理にも対応\r\n * - getLastNode で再帰的に最後のノードを取得\r\n * - assignListIndex でループ内のリストインデックスを再割り当て\r\n *\r\n * Throws（代表例）:\r\n * - BIND-101 Template not found: createContent 内で未登録テンプレートID\r\n * - BIND-101/102/103: createBindings 内の data-bind 情報不足/不整合\r\n * - BIND-104 Child bindContent not found: getLastNode の子探索で不整合\r\n * - BIND-201 LoopContext is null: assignListIndex 実行時に LoopContext 未初期化\r\n */\r\nclass BindContent implements IBindContent {\r\n  loopContext  : ILoopContext | null;\r\n  parentBinding: IBinding | null;\r\n  childNodes   : Node[];\r\n  fragment     : DocumentFragment;\r\n  engine       : IComponentEngine | undefined;\r\n  bindings: IBinding[] = [];\r\n  blockBindings: IBinding[] = [];\r\n  #id;\r\n  get id() {\r\n    return this.#id;\r\n  }\r\n  /**\r\n   * この BindContent が既に DOM にマウントされているかどうか。\r\n   * 判定は childNodes[0] の親が fragment 以外かで行う。\r\n   */\r\n  get isMounted() {\r\n    return this.childNodes.length > 0 && this.childNodes[0].parentNode !== this.fragment;\r\n  }\r\n  /**\r\n   * 先頭の子ノードを返す。存在しなければ null。\r\n   */\r\n  get firstChildNode() {\r\n    return this.childNodes[0] ?? null;\r\n  }\r\n  /**\r\n   * 末尾の子ノードを返す。存在しなければ null。\r\n   */\r\n  get lastChildNode() {\r\n    return this.childNodes[this.childNodes.length - 1] ?? null;\r\n  }\r\n\r\n  get hasBlockBinding() {\r\n    return this.blockBindings.length > 0;\r\n  }\r\n  /**\r\n   * 再帰的に最終ノード（末尾のバインディング配下も含む）を取得する。\r\n   *\r\n   * Params:\r\n   * - parentNode: 検証対象の親ノード（このノード配下にあることを期待）\r\n   *\r\n   * Returns:\r\n   * - 最終ノード（Node）または null（親子関係が崩れている場合）\r\n   *\r\n   * Throws:\r\n   * - BIND-104 子 BindContent が見つからない（不整合）\r\n   */\r\n  getLastNode(parentNode: Node): Node | null {\r\n    const lastBinding = this.bindings[this.bindings.length - 1];\r\n    const lastChildNode = this.lastChildNode;\r\n    if (typeof lastBinding !== \"undefined\" && lastBinding.node === lastChildNode) {\r\n      if (lastBinding.bindContents.length > 0) {\r\n        const childBindContent = lastBinding.bindContents.at(-1) ?? raiseError({\r\n          code: \"BIND-104\",\r\n          message: \"Child bindContent not found\",\r\n          context: { where: 'BindContent.getLastNode', templateId: this.#id },\r\n          docsUrl: \"./docs/error-codes.md#bind\",\r\n        });\r\n        const lastNode = childBindContent.getLastNode(parentNode);\r\n        if (lastNode !== null) {\r\n          return lastNode;\r\n        }\r\n      }\r\n    }\r\n    if (parentNode !== lastChildNode?.parentNode) {\r\n      return null;\r\n    }\r\n    return lastChildNode;\r\n  }\r\n  #currentLoopContext: ILoopContext | null | undefined;\r\n  /**\r\n   * 現在のループ文脈（LoopContext）を返す。自身に無ければ親方向へ遡って探索し、\r\n   * 一度解決した値はフィールドにキャッシュする。\r\n   */\r\n  get currentLoopContext(): ILoopContext | null {\r\n    if (typeof this.#currentLoopContext === \"undefined\") {\r\n      let bindContent: IBindContent | null = this;\r\n      while(bindContent !== null) {\r\n        if (bindContent.loopContext !== null) break; ;\r\n        bindContent = bindContent.parentBinding?.parentBindContent ?? null;\r\n      }\r\n      this.#currentLoopContext = bindContent?.loopContext ?? null;\r\n    }\r\n    return this.#currentLoopContext;\r\n  }\r\n  /**\r\n   * コンストラクタ。\r\n   * - テンプレートから DocumentFragment と childNodes を構築\r\n   * - ループ参照（loopRef.listIndex）がある場合に LoopContext を生成\r\n   * - テンプレートに基づき Bindings を生成\r\n   */\r\n  constructor(\r\n    parentBinding: IBinding | null,\r\n    id           : number, \r\n    engine       : IComponentEngine, \r\n    loopRef      : IStatePropertyRef,\r\n  ) {\r\n    this.parentBinding = parentBinding;\r\n    this.#id = id;\r\n    this.fragment = createContent(id);\r\n    this.childNodes = Array.from(this.fragment.childNodes);\r\n    this.engine = engine;\r\n    this.loopContext = (loopRef.listIndex !== null) ? createLoopContext(loopRef, this) : null;\r\n    const [ bindings, blockBindings ] = createBindings(\r\n      this, \r\n      id, \r\n      engine, \r\n      this.fragment\r\n    );\r\n    this.bindings = bindings;\r\n    this.blockBindings = blockBindings;\r\n  }\r\n  /**\r\n   * 末尾にマウント（appendChild）。\r\n   * 注意: idempotent ではないため、重複マウントは呼び出し側で避けること。\r\n   */\r\n  mount(parentNode: Node) {\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentNode.appendChild(this.childNodes[i]);\r\n    }\r\n  }\r\n  /**\r\n   * 指定ノードの直前にマウント（insertBefore）。\r\n   */\r\n  mountBefore(parentNode: Node, beforeNode: Node | null) {\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentNode.insertBefore(this.childNodes[i], beforeNode);\r\n    }\r\n  }\r\n  /**\r\n   * 指定ノードの直後にマウント（afterNode.nextSibling を before にして insertBefore）。\r\n   */\r\n  mountAfter(parentNode: Node, afterNode: Node | null) {\r\n    const beforeNode = afterNode?.nextSibling ?? null;\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentNode.insertBefore(this.childNodes[i], beforeNode);\r\n    }\r\n  }\r\n  /**\r\n   * アンマウント（親から childNodes を一括で取り外す）。\r\n   * コメント/テキストノードにも対応するため parentNode を使用。\r\n   * 親が既に無い場合は no-op。\r\n   */\r\n  unmount() {\r\n    // コメント/テキストノードでも確実に取得できるよう parentNode を使用する\r\n    const parentNode = this.childNodes[0]?.parentNode ?? null;\r\n    if (parentNode === null) {\r\n      return; // すでにDOMから削除されている場合は何もしない\r\n    }\r\n    for(let i = 0; i < this.childNodes.length; i++) {\r\n      parentNode.removeChild(this.childNodes[i]);\r\n    }\r\n  }\r\n  /**\r\n   * 生成済みの全 Binding を初期化。\r\n   * createBindContent 直後および assignListIndex 後に呼び出される。\r\n   */\r\n  init() {\r\n    for(let i = 0; i < this.bindings.length; i++) {\r\n      this.bindings[i].init();\r\n    }\r\n  }\r\n  /**\r\n   * ループ中の ListIndex を再割当てし、Bindings を再初期化する。\r\n   * Throws:\r\n   * - BIND-201 LoopContext が未初期化\r\n   */\r\n  assignListIndex(listIndex: IListIndex): void {\r\n    if (this.loopContext == null) raiseError({\r\n      code: \"BIND-201\",\r\n      message: \"LoopContext is null\",\r\n      context: { where: 'BindContent.assignListIndex', templateId: this.#id },\r\n      docsUrl: \"./docs/error-codes.md#bind\",\r\n    });\r\n    this.loopContext.assignListIndex(listIndex);\r\n    this.init();\r\n  }\r\n  /**\r\n   * 変更適用エントリポイント。\r\n   * Renderer から呼ばれ、各 Binding に applyChange を委譲する。\r\n   * renderer.updatedBindings に載っているものは二重適用を避ける。\r\n   */\r\n  applyChange(renderer: IRenderer): void {\r\n    for(let i = 0; i < this.bindings.length; i++) {\r\n      const binding = this.bindings[i];\r\n      if (renderer.updatedBindings.has(binding)) continue;\r\n      binding.applyChange(renderer);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * BindContent を生成して初期化（bindings.init）までを行うファクトリ関数。\r\n * \r\n * Params:\r\n * - parentBinding: 親の IBinding（なければ null）\r\n * - id: テンプレートID\r\n * - engine: コンポーネントエンジン\r\n * - loopRef: ループ用の StatePropertyRef（listIndex を含む場合に LoopContext を構築）\r\n *\r\n * Returns:\r\n * - 初期化済みの IBindContent\r\n */\r\nexport function createBindContent(\r\n  parentBinding: IBinding | null,\r\n  id           : number, \r\n  engine       :IComponentEngine, \r\n  loopRef      : IStatePropertyRef,\r\n):IBindContent {\r\n  const bindContent = new BindContent(\r\n    parentBinding, \r\n    id, \r\n    engine, \r\n    loopRef,\r\n  );\r\n  bindContent.init();\r\n  return bindContent;\r\n}","/**\r\n * loadFromImportMap\r\n *\r\n * importmap のエイリアスを走査し、ルート/コンポーネントを自動登録する。\r\n * - @routes/*: entryRoute でルーティング登録（/root → / に正規化）\r\n * - @components/*: SFC を読み込み、ComponentClass を生成して registerComponentClass\r\n * - #lazy サフィックスが付与されている場合は遅延ロード用に保持\r\n *\r\n * 戻り値: Promise<void>\r\n * Throws: 重大な例外は基本なし（見つからないエイリアスは warn として扱う）\r\n */\r\nimport { entryRoute } from \"../Router/Router\";\r\nimport { raiseError } from \"../utils\";\r\nimport { createComponentClass } from \"./createComponentClass\";\r\nimport { loadImportmap } from \"./loadImportmap\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent\";\r\nimport { registerComponentClass } from \"./registerComponentClass\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nconst ROUTES_KEY = \"@routes/\";\r\nconst COMPONENTS_KEY = \"@components/\";\r\nconst LAZY_LOAD_SUFFIX = \"#lazy\";\r\nconst LAZY_LOAD_SUFFIX_LEN = LAZY_LOAD_SUFFIX.length;\r\n\r\nconst lazyLoadComponentAliasByTagName: Record<string, string> = {};\r\n\r\nexport async function loadFromImportMap(): Promise<void> {\r\n  const importmap = loadImportmap();\r\n  if (importmap.imports) {\r\n    const loadAliasByTagName: Map<string, string> = new Map();\r\n    for (const [alias, value] of Object.entries(importmap.imports)) {\r\n      let tagName, isLazyLoad;\r\n      if (alias.startsWith(ROUTES_KEY)) {\r\n        isLazyLoad = alias.endsWith(LAZY_LOAD_SUFFIX);\r\n        // remove the prefix '@routes' and the suffix '#lazy' if it exists\r\n        const path = alias.slice(ROUTES_KEY.length - 1, isLazyLoad ? -LAZY_LOAD_SUFFIX_LEN : undefined); \r\n        const pathWithoutParams = path.replace(/:[^\\s/]+/g, \"\"); // remove the params\r\n        tagName = \"routes\" + pathWithoutParams.replace(/\\//g, \"-\"); // replace '/' with '-'\r\n        entryRoute(tagName, path === \"/root\" ? \"/\" : path); // routing\r\n      } if (alias.startsWith(COMPONENTS_KEY)) {\r\n        isLazyLoad = alias.endsWith(LAZY_LOAD_SUFFIX);\r\n        // remove the prefix '@components/' and the suffix '#lazy' if it exists\r\n        tagName = alias.slice(COMPONENTS_KEY.length, isLazyLoad ? -LAZY_LOAD_SUFFIX_LEN : undefined);\r\n      }\r\n      if (!tagName) {\r\n        continue;\r\n      }\r\n      if (isLazyLoad) {\r\n        // Lazy Load用のコンポーネントのエイリアスを格納\r\n        lazyLoadComponentAliasByTagName[tagName] = alias;\r\n        continue; // Lazy Loadの場合はここでスキップ\r\n      }\r\n      loadAliasByTagName.set(tagName, alias);\r\n    }\r\n    for (const [tagName, alias] of loadAliasByTagName.entries()) {\r\n      // 非Lazy Loadのコンポーネントはここで登録\r\n      const componentData = await loadSingleFileComponent(alias);\r\n      const componentClass = createComponentClass(componentData);\r\n      registerComponentClass(tagName, componentClass);\r\n    }\r\n  }\r\n}\r\n\r\nexport function hasLazyLoadComponents(): boolean {\r\n  return Object.keys(lazyLoadComponentAliasByTagName).length > 0;\r\n}\r\n\r\nexport function isLazyLoadComponent(tagName: string): boolean {\r\n  return lazyLoadComponentAliasByTagName.hasOwnProperty(tagName);\r\n}\r\n\r\nexport function loadLazyLoadComponent(tagName: string): void {\r\n  const alias = lazyLoadComponentAliasByTagName[tagName];\r\n  if (!alias) {\r\n    // 警告として扱うが、構造化メタ情報を付加\r\n    const err = {\r\n      code: \"IMP-201\",\r\n      message: `Alias not found for tagName: ${tagName}`,\r\n      context: { where: 'loadFromImportMap.loadLazyLoadComponent', tagName },\r\n      docsUrl: \"./docs/error-codes.md#imp\",\r\n      severity: \"warn\" as const,\r\n    };\r\n    // 既存挙動は warn + return のため、throw はせず console.warn にメタを付与\r\n    console.warn(err.message, { code: err.code, context: err.context, docsUrl: err.docsUrl, severity: err.severity });\r\n    return;\r\n  }\r\n  delete lazyLoadComponentAliasByTagName[tagName]; // 一度ロードしたら削除\r\n  queueMicrotask(async () => {\r\n    const componentData = await loadSingleFileComponent(alias);\r\n    const componentClass = createComponentClass(componentData);\r\n    registerComponentClass(tagName, componentClass);\r\n  });\r\n}\r\n","import { raiseError } from \"../utils.js\";\r\nimport { IComponentConfig } from \"../WebComponents/types\";\r\nimport { canHaveShadowRoot } from \"./canHaveShadowRoot.js\";\r\n\r\nfunction getParentShadowRoot(parentNode: Node | null): ShadowRoot|undefined{\r\n  let node: Node | null = parentNode;\r\n  while(node) {\r\n    if (node instanceof ShadowRoot) {\r\n      return node;\r\n    }\r\n    node = node.parentNode;\r\n  }\r\n}\r\n\r\n/**\r\n * 指定したHTMLElementにShadow DOMをアタッチし、スタイルシートを適用するユーティリティ関数。\r\n *\r\n * - config.enableShadowDomがtrueの場合は、ShadowRootを生成し、adoptedStyleSheetsでスタイルを適用\r\n * - extends指定がある場合はcanHaveShadowRootで拡張可能かチェック\r\n * - Shadow DOMを使わない場合は、親のShadowRootまたはdocumentにスタイルシートを追加\r\n * - すでに同じスタイルシートが含まれていれば重複追加しない\r\n *\r\n * @param element    対象のHTMLElement\r\n * @param config     コンポーネント設定\r\n * @param styleSheet 適用するCSSStyleSheet\r\n * @throws           Shadow DOM非対応の組み込み要素を拡張しようとした場合はエラー\r\n */\r\nexport function attachShadow(element: HTMLElement, config: IComponentConfig, styleSheet: CSSStyleSheet): void {\r\n    if (config.enableShadowDom) {\r\n      if (config.extends === null || canHaveShadowRoot(config.extends)) {\r\n        if (!element.shadowRoot) {\r\n          const shadowRoot = element.attachShadow({ mode: 'open' });\r\n          shadowRoot.adoptedStyleSheets = [styleSheet];\r\n        }\r\n      } else {\r\n        raiseError(`ComponentEngine: Shadow DOM not supported for builtin components that extend ${config.extends}`);\r\n      }\r\n    } else {\r\n      const shadowRootOrDocument = getParentShadowRoot(element.parentNode) || document;\r\n      const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n      if (!styleSheets.includes(styleSheet)) {\r\n        shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, styleSheet];\r\n      }\r\n    }\r\n\r\n}","/**\r\n * 指定したタグ名の要素がShadowRootを持てるかどうかを判定するユーティリティ関数。\r\n *\r\n * - 指定タグ名で要素を生成し、attachShadowメソッドが存在するかどうかで判定\r\n * - 無効なタグ名やattachShadow未対応の場合はfalseを返す\r\n *\r\n * @param tagName 判定したい要素のタグ名（例: \"div\", \"span\", \"input\" など）\r\n * @returns       ShadowRootを持てる場合はtrue、持てない場合はfalse\r\n */\r\nexport function canHaveShadowRoot(tagName: string): boolean {\r\n  try {\r\n    // 一時的に要素を作成\r\n    const element = document.createElement(tagName);\r\n    // `attachShadow` メソッドが存在し、実行可能かを確認\r\n    if (typeof element.attachShadow !== \"function\") {\r\n      return false;\r\n    }\r\n    // 一時的にShadowRootをアタッチしてみる\r\n    const shadowRoot = element.attachShadow({ mode: 'open' });\r\n    return true;\r\n  } catch {\r\n    // 無効なタグ名などが渡された場合は false を返す\r\n    return false;\r\n  }\r\n}\r\n","import { IBinding } from \"../DataBinding/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { raiseError } from \"../utils\";\r\nimport { StructiveComponent } from \"../WebComponents/types\";\r\nimport { IComponentStateBinding } from \"./types\";\r\n\r\n/**\r\n * ComponentStateBinding\r\n *\r\n * 目的:\r\n * - 親コンポーネントの状態パスと子コンポーネント側のサブパスを一対一で関連付け、\r\n *   双方向にパス変換・参照できるようにする（親->子/子->親）。\r\n *\r\n * 制約:\r\n * - 親パス/子パスは 1:1 のみ（重複登録は STATE-303）\r\n * - 最長一致でのパス変換を行い、下位セグメントはそのまま連結\r\n */\r\nclass ComponentStateBinding implements IComponentStateBinding {\r\n  parentPaths: Set<string> = new Set<string>();\r\n  childPaths: Set<string> = new Set<string>();\r\n  childPathByParentPath: Map<string, string> = new Map();\r\n  parentPathByChildPath: Map<string, string> = new Map();\r\n  bindingByParentPath: Map<string, IBinding> = new Map();\r\n  bindingByChildPath: Map<string, IBinding> = new Map();\r\n  bindings: WeakSet<IBinding> = new WeakSet();\r\n\r\n  addBinding(binding: IBinding): void {\r\n    if (this.bindings.has(binding)) {\r\n      return; // 既にバインディングが追加されている場合は何もしない\r\n    }\r\n    const parentPath = binding.bindingState.pattern;\r\n    const childPath = binding.bindingNode.subName;\r\n    if (this.childPathByParentPath.has(parentPath)) {\r\n      raiseError({\r\n        code: \"STATE-303\",\r\n  message: `Parent path \"${parentPath}\" already has a child path`,\r\n        context: { parentPath, existingChildPath: this.childPathByParentPath.get(parentPath) },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    if (this.parentPathByChildPath.has(childPath)) {\r\n      raiseError({\r\n        code: \"STATE-303\",\r\n  message: `Child path \"${childPath}\" already has a parent path`,\r\n        context: { childPath, existingParentPath: this.parentPathByChildPath.get(childPath) },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    this.childPathByParentPath.set(parentPath, childPath);\r\n    this.parentPathByChildPath.set(childPath, parentPath);\r\n    this.parentPaths.add(parentPath);\r\n    this.childPaths.add(childPath);\r\n    this.bindingByParentPath.set(parentPath, binding);\r\n    this.bindingByChildPath.set(childPath, binding);\r\n    this.bindings.add(binding);\r\n  }\r\n  \r\n  getChildPath(parentPath: string): string | undefined {\r\n    return this.childPathByParentPath.get(parentPath);\r\n  }\r\n\r\n  getParentPath(childPath: string): string | undefined {\r\n    return this.parentPathByChildPath.get(childPath);\r\n  }\r\n\r\n  toParentPathFromChildPath(childPath: string): string {\r\n    // 子から親へ: 最長一致する childPaths のエントリを探し、残差のセグメントを親に連結\r\n    const childPathInfo = getStructuredPathInfo(childPath);\r\n    const matchPaths = childPathInfo.cumulativePathSet.intersection(this.childPaths);\r\n    if (matchPaths.size === 0) {\r\n      raiseError({\r\n        code: \"STATE-302\",\r\n  message: `No parent path found for child path \"${childPath}\"`,\r\n        context: { childPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    const matchPathArray = Array.from(matchPaths);\r\n    const longestMatchPath = matchPathArray[matchPathArray.length - 1];\r\n    const remainPath = childPath.slice(longestMatchPath.length); // include the dot\r\n    const matchParentPath = this.parentPathByChildPath.get(longestMatchPath);\r\n    if (typeof matchParentPath === \"undefined\") {\r\n      raiseError({\r\n        code: \"STATE-302\",\r\n  message: `No parent path found for child path \"${childPath}\"`,\r\n        context: { childPath, longestMatchPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    return matchParentPath + remainPath;\r\n  }\r\n\r\n  toChildPathFromParentPath(parentPath: string): string {\r\n    // 親から子へ: 最長一致する parentPaths のエントリを探し、残差のセグメントを子に連結\r\n    const parentPathInfo = getStructuredPathInfo(parentPath);\r\n    const matchPaths = parentPathInfo.cumulativePathSet.intersection(this.parentPaths);\r\n    if (matchPaths.size === 0) {\r\n      raiseError({\r\n        code: \"STATE-302\",\r\n  message: `No child path found for parent path \"${parentPath}\"`,\r\n        context: { parentPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    const matchPathArray = Array.from(matchPaths);\r\n    const longestMatchPath = matchPathArray[matchPathArray.length - 1];\r\n    const remainPath = parentPath.slice(longestMatchPath.length); // include the dot\r\n    const matchChildPath = this.childPathByParentPath.get(longestMatchPath);\r\n    if (typeof matchChildPath === \"undefined\") {\r\n      raiseError({\r\n        code: \"STATE-302\",\r\n  message: `No child path found for parent path \"${parentPath}\"`,\r\n        context: { parentPath, longestMatchPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    return matchChildPath + remainPath;\r\n  }\r\n\r\n  startsWithByChildPath(childPathInfo: IStructuredPathInfo): string | null {\r\n    if (this.childPaths.size === 0) {\r\n      return null;\r\n    }\r\n    const matchPaths = childPathInfo.cumulativePathSet.intersection(this.childPaths);\r\n    if (matchPaths.size === 0) {\r\n      return null;\r\n    } else {\r\n      const matches = Array.from(matchPaths);\r\n      const longestMatchPath = matches[matches.length - 1];\r\n      return longestMatchPath;\r\n    }\r\n  }\r\n\r\n  bind(parentComponent: StructiveComponent, childComponent: StructiveComponent): void {\r\n    // bindParentComponent\r\n    const bindings = parentComponent.getBindingsFromChild(childComponent);\r\n    for (const binding of bindings ?? []) {\r\n      this.addBinding(binding);\r\n    }\r\n  }\r\n}\r\n\r\nexport function createComponentStateBinding(): IComponentStateBinding {\r\n  return new ComponentStateBinding();\r\n}","import { IComponentEngine } from \"../ComponentEngine/types\";\r\nimport { IComponentStateBinding } from \"../ComponentStateBinding/types\";\r\nimport { SetByRefSymbol } from \"../StateClass/symbols\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { update } from \"../Updater/Updater\";\r\nimport { raiseError } from \"../utils\";\r\nimport { AssignStateSymbol, NotifyRedrawSymbol } from \"./symbols\";\r\nimport { IComponentStateInput, IComponentStateInputHandler } from \"./types\";\r\n\r\nclass ComponentStateInputHandler implements IComponentStateInputHandler {\r\n  private componentStateBinding: IComponentStateBinding;\r\n  private engine: IComponentEngine;\r\n  constructor(engine:IComponentEngine, componentStateBinding: IComponentStateBinding) {\r\n    this.componentStateBinding = componentStateBinding;\r\n    this.engine = engine;\r\n  }\r\n\r\n  assignState(object: any): void {\r\n    update(this.engine, null, async (updater, stateProxy, handler) => {\r\n      for(const [key, value] of Object.entries(object)) {\r\n        const childPathInfo = getStructuredPathInfo(key);\r\n        const childRef = getStatePropertyRef(childPathInfo, null);\r\n        stateProxy[SetByRefSymbol](childRef, value);\r\n      }     \r\n    });\r\n  }\r\n\r\n  /**\r\n   * listindexに一致するかどうかは事前にスクリーニングしておく\r\n   * @param refs \r\n   */\r\n  notifyRedraw(refs: IStatePropertyRef[]): void {\r\n    for(const parentPathRef of refs) {\r\n      try {\r\n        const childPath = this.componentStateBinding.toChildPathFromParentPath(parentPathRef.info.pattern);\r\n        const childPathInfo = getStructuredPathInfo(childPath);\r\n        const childListIndex = parentPathRef.listIndex;\r\n        const childRef = getStatePropertyRef(childPathInfo, childListIndex);\r\n        const value = this.engine.getPropertyValue(childRef);\r\n        // Ref情報をもとに状態更新キューに追加\r\n        update(this.engine, null, async (updater, stateProxy, handler) => {\r\n          const childRef = getStatePropertyRef(childPathInfo, childListIndex);\r\n          updater.enqueueRef(childRef);\r\n        });\r\n      } catch(e) {\r\n        // 対象でないものは何もしない\r\n      }\r\n    }\r\n  }\r\n\r\n  get(target:any, prop:PropertyKey, receiver:IComponentStateInput) {\r\n    if (prop === AssignStateSymbol) {\r\n      return this.assignState.bind(this);\r\n    } else if (prop === NotifyRedrawSymbol) {\r\n      return this.notifyRedraw.bind(this);\r\n    } else if (typeof prop === \"string\") {\r\n      const ref = getStatePropertyRef(getStructuredPathInfo(prop), null);\r\n      return this.engine.getPropertyValue(ref);\r\n    }\r\n    raiseError(`Property \"${String(prop)}\" is not supported in ComponentStateInput.`);\r\n  }\r\n\r\n  set(target:any, prop:PropertyKey, value:any, receiver:IComponentStateInput): boolean {\r\n    if (typeof prop === \"string\") {\r\n      const ref = getStatePropertyRef(getStructuredPathInfo(prop), null);\r\n      this.engine.setPropertyValue(ref, value);\r\n      return true;\r\n    }\r\n    raiseError(`Property \"${String(prop)}\" is not supported in ComponentStateInput.`);\r\n  }\r\n}\r\n\r\nexport function createComponentStateInput(\r\n  engine: IComponentEngine,\r\n  componentStateBinding: IComponentStateBinding\r\n): IComponentStateInput {\r\n  const handler = new ComponentStateInputHandler(engine, componentStateBinding);\r\n  return new Proxy({}, handler) as IComponentStateInput;\r\n}","import { IComponentStateBinding } from \"../ComponentStateBinding/types\";\r\nimport { IListIndex } from \"../ListIndex/types\";\r\nimport { SetByRefSymbol } from \"../StateClass/symbols\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { IStructuredPathInfo } from \"../StateProperty/types\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types\";\r\nimport { update } from \"../Updater/Updater\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IComponentStateOutput } from \"./types\";\r\n\r\nclass ComponentStateOutput implements IComponentStateOutput {\r\n  binding: IComponentStateBinding;\r\n  constructor(binding: IComponentStateBinding) {\r\n    this.binding = binding;\r\n  }\r\n\r\n  get(ref: IStatePropertyRef): any {\r\n    const childPath = this.binding.startsWithByChildPath(ref.info);\r\n    if (childPath === null) {\r\n      raiseError(`No child path found for path \"${ref.info.toString()}\".`);\r\n    }\r\n    const binding = this.binding.bindingByChildPath.get(childPath);\r\n    if (typeof binding === \"undefined\") {\r\n      raiseError(`No binding found for child path \"${childPath}\".`);\r\n    }\r\n    const parentPathInfo = getStructuredPathInfo(this.binding.toParentPathFromChildPath(ref.info.pattern));\r\n    const parentRef = getStatePropertyRef(parentPathInfo, ref.listIndex ?? binding.bindingState.listIndex);\r\n    return binding.engine.getPropertyValue(parentRef);\r\n  }\r\n\r\n  set(ref: IStatePropertyRef, value: any): boolean {\r\n    const childPath = this.binding.startsWithByChildPath(ref.info);\r\n    if (childPath === null) {\r\n      raiseError(`No child path found for path \"${ref.info.toString()}\".`);\r\n    }\r\n    const binding = this.binding.bindingByChildPath.get(childPath);\r\n    if (typeof binding === \"undefined\") {\r\n      raiseError(`No binding found for child path \"${childPath}\".`);\r\n    }\r\n    const parentPathInfo = getStructuredPathInfo(this.binding.toParentPathFromChildPath(ref.info.pattern));\r\n    const engine = binding.engine;\r\n    const parentRef = getStatePropertyRef(parentPathInfo, ref.listIndex ?? binding.bindingState.listIndex);\r\n    update(engine, null, async (updater, stateProxy, handler) => {\r\n      stateProxy[SetByRefSymbol](parentRef, value);\r\n    });\r\n    return true;\r\n  }\r\n\r\n  startsWith(pathInfo: IStructuredPathInfo): boolean {\r\n    return this.binding.startsWithByChildPath(pathInfo) !== null;\r\n  }\r\n\r\n  getListIndexes(ref: IStatePropertyRef): IListIndex[] | null {\r\n    const childPath = this.binding.startsWithByChildPath(ref.info);\r\n    if (childPath === null) {\r\n      raiseError(`No child path found for path \"${ref.info.toString()}\".`);\r\n    }\r\n    const binding = this.binding.bindingByChildPath.get(childPath);\r\n    if (typeof binding === \"undefined\") {\r\n      raiseError(`No binding found for child path \"${childPath}\".`);\r\n    }\r\n    const parentPathInfo = getStructuredPathInfo(this.binding.toParentPathFromChildPath(ref.info.pattern));\r\n    const parentRef = getStatePropertyRef(parentPathInfo, ref.listIndex);\r\n    return binding.engine.getListIndexes(parentRef);\r\n  }\r\n}\r\n\r\nexport function createComponentStateOutput(binding: IComponentStateBinding): IComponentStateOutput {\r\n  return new ComponentStateOutput(binding);\r\n}","import { createBindContent } from \"../DataBinding/BindContent.js\";\r\nimport { IBindContent, IBinding } from \"../DataBinding/types\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { IState, IStructiveState } from \"../StateClass/types\";\r\nimport { ComponentType, IComponentConfig, IComponentStatic, StructiveComponent } from \"../WebComponents/types\";\r\nimport { attachShadow } from \"./attachShadow.js\";\r\nimport { ISaveInfoByResolvedPathInfo, IComponentEngine, ICacheEntry } from \"./types\";\r\nimport { ConnectedCallbackSymbol, DisconnectedCallbackSymbol, GetByRefSymbol, SetByRefSymbol, SetCacheableSymbol } from \"../StateClass/symbols.js\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { createReadonlyStateHandler, createReadonlyStateProxy } from \"../StateClass/createReadonlyStateProxy.js\";\r\nimport { IComponentStateBinding } from \"../ComponentStateBinding/types.js\";\r\nimport { createComponentStateBinding } from \"../ComponentStateBinding/createComponentStateBinding.js\";\r\nimport { createComponentStateInput } from \"../ComponentStateInput/createComponentStateInput.js\";\r\nimport { createComponentStateOutput } from \"../ComponentStateOutput/createComponentStateOutput.js\";\r\nimport { IComponentStateInput } from \"../ComponentStateInput/types.js\";\r\nimport { IComponentStateOutput } from \"../ComponentStateOutput/types.js\";\r\nimport { AssignStateSymbol } from \"../ComponentStateInput/symbols.js\";\r\nimport { IListIndex } from \"../ListIndex/types.js\";\r\nimport { IPathManager } from \"../PathManager/types.js\";\r\nimport { update } from \"../Updater/Updater.js\";\r\nimport { getStatePropertyRef } from \"../StatePropertyRef/StatepropertyRef.js\";\r\nimport { RESERVED_WORD_SET } from \"../constants.js\";\r\nimport { addPathNode } from \"../PathTree/PathNode.js\";\r\nimport { IStatePropertyRef } from \"../StatePropertyRef/types.js\";\r\n\r\n/**\r\n * ComponentEngine は、Structive コンポーネントの状態・依存関係・\r\n * バインディング・ライフサイクル・レンダリングを統合する中核エンジンです。\r\n *\r\n * 主な役割:\r\n * - 状態インスタンスやプロキシの生成・管理\r\n * - テンプレート/スタイルシート/フィルター/バインディングの管理\r\n * - 依存関係グラフ（PathTree）の構築と管理\r\n * - バインディング情報やリスト情報の保存・取得\r\n * - ライフサイクル（connected/disconnected）処理\r\n * - Shadow DOM の適用、またはブロックモードのプレースホルダー運用\r\n * - 状態プロパティの取得・設定\r\n * - バインディングの追加・存在判定・リスト管理\r\n *\r\n * Throws（代表例）:\r\n * - BIND-201 bindContent not initialized yet / Block parent node is not set\r\n * - STATE-202 Failed to parse state from dataset\r\n *\r\n * 備考:\r\n * - 非同期初期化（waitForInitialize）と切断待機（waitForDisconnected）を提供\r\n * - Updater と連携したバッチ更新で効率的なレンダリングを実現\r\n */\r\n\r\nconst EMPTY_SAVE_INFO: ISaveInfoByResolvedPathInfo = {\r\n  list: null,\r\n  listIndexes: null,\r\n  listClone: null,\r\n};\r\nexport class ComponentEngine implements IComponentEngine {\r\n  type          : ComponentType = 'autonomous';\r\n  config        : IComponentConfig;\r\n  template      : HTMLTemplateElement;\r\n  styleSheet    : CSSStyleSheet;\r\n  stateClass    : IStructiveState;\r\n  state         : IState;\r\n  inputFilters  : FilterWithOptions;\r\n  outputFilters : FilterWithOptions;\r\n  #bindContent  :IBindContent | null = null;\r\n \r\n  get bindContent(): IBindContent {\r\n    if (this.#bindContent === null) {\r\n      raiseError({\r\n        code: 'BIND-201',\r\n        message: 'bindContent not initialized yet',\r\n        context: { where: 'ComponentEngine.bindContent.get', componentId: (this.owner.constructor as IComponentStatic).id },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n    }\r\n    return this.#bindContent;\r\n  }\r\n  baseClass     : typeof HTMLElement = HTMLElement;\r\n  owner         : StructiveComponent;\r\n\r\n  bindingsByListIndex : WeakMap<IListIndex, Set<IBinding>> = new WeakMap();\r\n\r\n  bindingsByComponent: WeakMap<StructiveComponent, Set<IBinding>> = new WeakMap();\r\n  structiveChildComponents: Set<StructiveComponent> = new Set();\r\n\r\n  #waitForInitialize : PromiseWithResolvers<void> = Promise.withResolvers<void>();\r\n  #waitForDisconnected: PromiseWithResolvers<void> | null = null;\r\n  \r\n  #stateBinding: IComponentStateBinding = createComponentStateBinding();\r\n  stateInput: IComponentStateInput;\r\n  stateOutput: IComponentStateOutput;\r\n  #blockPlaceholder: Comment | null = null; // ブロックプレースホルダー\r\n  #blockParentNode: Node | null = null; // ブロックプレースホルダーの親ノード\r\n  #ignoreDissconnectedCallback: boolean = false; // disconnectedCallbackを無視するフラグ\r\n\r\n  #currentVersion: number = 0;\r\n  get currentVersion(): number {\r\n    return this.#currentVersion;\r\n  }\r\n\r\n  versionUp(): number {\r\n    return ++this.#currentVersion;\r\n  }\r\n\r\n  cache: WeakMap<IStatePropertyRef, ICacheEntry> = new WeakMap(); // StatePropertyRefごとのキャッシュエントリ\r\n  constructor(config: IComponentConfig, owner: StructiveComponent) {\r\n    this.config = config;\r\n    if (this.config.extends) {\r\n      this.type = 'builtin';\r\n    }\r\n    const componentClass = owner.constructor as IComponentStatic;\r\n    this.template = componentClass.template;\r\n    this.styleSheet = componentClass.styleSheet;\r\n    this.stateClass = componentClass.stateClass;\r\n    this.state = new this.stateClass();\r\n    this.inputFilters = componentClass.inputFilters;\r\n    this.outputFilters = componentClass.outputFilters;\r\n    this.owner =  owner;\r\n    this.stateInput = createComponentStateInput(this, this.#stateBinding);\r\n    this.stateOutput = createComponentStateOutput(this.#stateBinding);\r\n  }\r\n\r\n  get pathManager(): IPathManager {\r\n    return (this.owner.constructor as IComponentStatic).pathManager;\r\n  }\r\n\r\n  setup(): void {\r\n    // 実体化された state オブジェクトのプロパティをすべて PathManager に登録する\r\n    // ToDo:prototypeを遡ったほうが良い\r\n    for(const path in this.state) {\r\n      if (RESERVED_WORD_SET.has(path) || this.pathManager.alls.has(path)) {\r\n        continue;\r\n      }\r\n      this.pathManager.alls.add(path);\r\n      addPathNode(this.pathManager.rootNode, path);\r\n    }\r\n    const componentClass = this.owner.constructor as IComponentStatic;\r\n    const rootRef = getStatePropertyRef(getStructuredPathInfo(''), null);\r\n    this.#bindContent = createBindContent(null, componentClass.id, this, rootRef); // this.stateArrayPropertyNamePatternsが変更になる可能性がある\r\n  }\r\n\r\n  get waitForInitialize(): PromiseWithResolvers<void> {\r\n    return this.#waitForInitialize;\r\n  }\r\n\r\n  async connectedCallback(): Promise<void> {\r\n    await this.#waitForDisconnected?.promise; // disconnectedCallbackが呼ばれている場合は待つ\r\n    await this.owner.parentStructiveComponent?.waitForInitialize.promise;\r\n    // コンポーネントの状態を初期化する\r\n    if (this.owner.dataset.state) {\r\n      // data-state属性から状態を取得する\r\n      try {\r\n        const json = JSON.parse(this.owner.dataset.state);\r\n        this.stateInput[AssignStateSymbol](json);\r\n      } catch(e) {\r\n        raiseError({\r\n          code: 'STATE-202',\r\n          message: 'Failed to parse state from dataset',\r\n          context: { where: 'ComponentEngine.connectedCallback', datasetState: this.owner.dataset.state },\r\n          docsUrl: './docs/error-codes.md#state',\r\n          cause: e as any,\r\n        });\r\n      }\r\n    }\r\n    const parentComponent = this.owner.parentStructiveComponent;\r\n    if (parentComponent) {\r\n      // 親コンポーネントの状態をバインドする\r\n      parentComponent.registerChildComponent(this.owner);\r\n      // 親コンポーネントの状態を子コンポーネントにバインドする\r\n      this.#stateBinding.bind(parentComponent, this.owner);\r\n    }\r\n    if (this.config.enableWebComponents) {\r\n      attachShadow(this.owner, this.config, this.styleSheet);\r\n    } else {\r\n      this.#blockParentNode = this.owner.parentNode;\r\n      this.#blockPlaceholder = document.createComment(\"Structive block placeholder\");\r\n      try {\r\n        this.#ignoreDissconnectedCallback = true; // disconnectedCallbackを無視するフラグを立てる\r\n        this.owner.replaceWith(this.#blockPlaceholder); // disconnectCallbackが呼ばれてしまう\r\n      } finally {\r\n        this.#ignoreDissconnectedCallback = false;\r\n      }\r\n    }\r\n\r\n    if (this.config.enableWebComponents) {\r\n      // Shadow DOMにバインドコンテンツをマウントする\r\n      this.bindContent.mount(this.owner.shadowRoot ?? this.owner);\r\n    } else {\r\n      // ブロックプレースホルダーの親ノードにバインドコンテンツをマウントする\r\n      const parentNode = this.#blockParentNode ?? raiseError({\r\n        code: 'BIND-201',\r\n        message: 'Block parent node is not set',\r\n        context: { where: 'ComponentEngine.connectedCallback', mode: 'block' },\r\n        docsUrl: './docs/error-codes.md#bind',\r\n      });\r\n      this.bindContent.mountAfter(parentNode, this.#blockPlaceholder);\r\n    }\r\n\r\n    await update(this, null, async (updater, stateProxy, handler) => {\r\n      // 状態の初期レンダリングを行う\r\n      for(const path of this.pathManager.alls) {\r\n        const info = getStructuredPathInfo(path);\r\n        if (info.pathSegments.length !== 1) continue; // ルートプロパティのみ\r\n        if (this.pathManager.funcs.has(path)) continue; // 関数は除外\r\n        const ref = getStatePropertyRef(info, null);\r\n        updater.enqueueRef(ref);\r\n      }\r\n      await stateProxy[ConnectedCallbackSymbol]();\r\n    });\r\n\r\n    // レンダリングが終わってから実行する\r\n    queueMicrotask(() => {\r\n      this.#waitForInitialize.resolve();\r\n    });\r\n  }\r\n\r\n  async disconnectedCallback(): Promise<void> {\r\n    this.#waitForDisconnected = Promise.withResolvers<void>();\r\n    try {\r\n      if (this.#ignoreDissconnectedCallback) return; // disconnectedCallbackを無視するフラグが立っている場合は何もしない\r\n      await update(this, null, async (updater, stateProxy, handler) => {\r\n        await stateProxy[DisconnectedCallbackSymbol]();\r\n      });\r\n      // 親コンポーネントから登録を解除する\r\n      this.owner.parentStructiveComponent?.unregisterChildComponent(this.owner);\r\n      if (!this.config.enableWebComponents) {\r\n        this.#blockPlaceholder?.remove();\r\n        this.#blockPlaceholder = null;\r\n        this.#blockParentNode = null;\r\n      }\r\n    } finally {\r\n      this.#waitForDisconnected.resolve(); // disconnectedCallbackが呼ばれたことを通知   \r\n    }\r\n  }\r\n\r\n  #saveInfoByStructuredPathId: { [id:number]: ISaveInfoByResolvedPathInfo } = {};\r\n  #saveInfoByResolvedPathInfoIdByListIndex: WeakMap<IListIndex, { [id:number]: ISaveInfoByResolvedPathInfo }> = new WeakMap();\r\n  #saveInfoByRef: WeakMap<IStatePropertyRef, ISaveInfoByResolvedPathInfo> = new WeakMap();\r\n  #listByRef: WeakMap<IStatePropertyRef, any[] | null> = new WeakMap();\r\n  #listIndexesByRef: WeakMap<IStatePropertyRef, IListIndex[] | null> = new WeakMap();\r\n  #bindingsByRef: WeakMap<IStatePropertyRef, IBinding[]> = new WeakMap();\r\n  #listCloneByRef: WeakMap<IStatePropertyRef, any[] | null> = new WeakMap();\r\n\r\n  saveBinding(\r\n    ref      : IStatePropertyRef,\r\n    binding  : IBinding\r\n  ): void {\r\n    const bindings = this.#bindingsByRef.get(ref);\r\n    if (typeof bindings !== \"undefined\") {\r\n      bindings.push(binding);\r\n      return;\r\n    }\r\n    this.#bindingsByRef.set(ref, [binding]);\r\n  }\r\n\r\n  saveListAndListIndexes(\r\n    ref               : IStatePropertyRef,\r\n    list              : any[] | null,\r\n    listIndexes       : IListIndex[] | null\r\n  ): void {\r\n    if (this.pathManager.lists.has(ref.info.pattern)) {\r\n      const saveInfo = {\r\n        list          : list,\r\n        listIndexes   : listIndexes,\r\n        listClone     : list ? Array.from(list) : null,\r\n      }\r\n      this.#saveInfoByRef.set(ref, saveInfo);\r\n    }\r\n  }\r\n\r\n  getBindings(ref: IStatePropertyRef): IBinding[] {\r\n    const bindings = this.#bindingsByRef.get(ref);\r\n    if (typeof bindings !== \"undefined\") {\r\n      return bindings;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  getListIndexes(ref: IStatePropertyRef): IListIndex[] | null {\r\n    if (this.stateOutput.startsWith(ref.info)) {\r\n      return this.stateOutput.getListIndexes(ref);\r\n    }\r\n    return this.#saveInfoByRef.get(ref)?.listIndexes ?? null;\r\n  }\r\n\r\n  getListAndListIndexes(ref: IStatePropertyRef): ISaveInfoByResolvedPathInfo {\r\n    const saveInfo = this.#saveInfoByRef.get(ref);\r\n    if (typeof saveInfo === \"undefined\") {\r\n      return EMPTY_SAVE_INFO;\r\n    }\r\n    return saveInfo;\r\n  }\r\n\r\n  getPropertyValue(ref: IStatePropertyRef): any {\r\n    // プロパティの値を取得する\r\n    //ToDo: Readableを考える\r\n    /*\r\n    const handler = createReadonlyStateHandler(this, null);\r\n    const stateProxy = createReadonlyStateProxy(this.state, handler);\r\n    return stateProxy[GetByRefSymbol](ref);\r\n    */\r\n    return null;\r\n  }\r\n  setPropertyValue(ref: IStatePropertyRef, value: any): void {\r\n    // プロパティの値を設定する\r\n    update(this, null, async (updater, stateProxy, handler) => {\r\n      stateProxy[SetByRefSymbol](ref, value);\r\n    });\r\n  }\r\n  // Structive子コンポーネントを登録する\r\n  registerChildComponent(component: StructiveComponent): void {\r\n    this.structiveChildComponents.add(component);\r\n  }\r\n  unregisterChildComponent(component: StructiveComponent): void {\r\n    this.structiveChildComponents.delete(component);\r\n  }\r\n  \r\n}\r\n\r\nexport function createComponentEngine(config: IComponentConfig, component: StructiveComponent): IComponentEngine {\r\n  return new ComponentEngine(config, component);\r\n}","/**\r\n * replaceMustacheWithTemplateTag.ts\r\n *\r\n * Mustache構文（{{if:条件}}, {{for:式}}, {{endif}}, {{endfor}}, {{elseif:条件}}, {{else}} など）を\r\n * <template>タグやコメントノードに変換するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - HTML文字列内のMustache構文を正規表現で検出し、<template data-bind=\"...\">やコメントノードに変換\r\n * - if/for/endif/endfor/elseif/elseなどの制御構文をネスト対応で<template>タグに変換\r\n * - 通常の埋め込み式（{{expr}}）はコメントノード（<!--embed:expr-->）に変換\r\n *\r\n * 設計ポイント:\r\n * - stackでネスト構造を管理し、endif/endfor/elseif/elseの対応関係を厳密にチェック\r\n * - 不正なネストや対応しない構文にはraiseErrorで例外を発生\r\n * - elseif/elseはnot条件のtemplateを自動生成し、条件分岐を表現\r\n * - コメントノードへの変換で埋め込み式の安全なDOM挿入を実現\r\n */\r\nimport { COMMENT_EMBED_MARK } from \"../constants.js\";\r\nimport { raiseError } from \"../utils.js\";\r\n\r\nconst MUSTACHE_REGEXP = /\\{\\{([^\\}]+)\\}\\}/g;\r\nconst MUSTACHE_TYPES:Set<string> = new Set(['if', 'for', 'endif', 'endfor', 'elseif', 'else']);\r\n\r\ntype MustacheType = 'if' | 'for' | 'endif' | 'endfor' | 'elseif' | 'else';\r\ntype MustacheInfo = {\r\n  type: MustacheType;\r\n  remain: string; // after first ':'\r\n  expr: string;\r\n}\r\n\r\nexport function replaceMustacheWithTemplateTag(html: string): string {\r\n  const stack:MustacheInfo[] = [];\r\n  return html.replaceAll(MUSTACHE_REGEXP, (match, expr) => {\r\n    expr = expr.trim();\r\n    const [ type ] = expr.split(':');\r\n    if (!MUSTACHE_TYPES.has(type)) {\r\n      // embed\r\n      return `<!--${COMMENT_EMBED_MARK}${expr}-->`;\r\n    }\r\n    const remain = expr.slice(type.length + 1).trim();\r\n    const currentInfo:MustacheInfo = { type, expr, remain };\r\n    if (type === 'if' || type === 'for') {\r\n      stack.push(currentInfo);\r\n      return `<template data-bind=\"${expr}\">`;\r\n    } else if (type === 'endif') {\r\n      const endTags = [];\r\n      do {\r\n        const info = stack.pop() ?? raiseError({\r\n          code: 'TMP-102',\r\n          message: 'Endif without if',\r\n          context: { where: 'replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n          docsUrl: './docs/error-codes.md#tmp',\r\n        });\r\n        if (info.type === 'if') {\r\n          endTags.push('</template>');\r\n          break;\r\n        } else if (info.type === 'elseif') {\r\n          endTags.push('</template>');\r\n        } else {\r\n          raiseError({\r\n            code: 'TMP-102',\r\n            message: 'Endif without if',\r\n            context: { where: 'replaceMustacheWithTemplateTag', got: info.type, expr },\r\n            docsUrl: './docs/error-codes.md#tmp',\r\n          });\r\n        }\r\n      } while(true);\r\n      return endTags.join('');\r\n    } else if (type === 'endfor') {\r\n      const info = stack.pop() ?? raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Endif without if',\r\n        context: { where: 'replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n      if (info.type === 'for') {\r\n        return '</template>';\r\n      } else {\r\n        raiseError({\r\n          code: 'TMP-102',\r\n          message: 'Endfor without for',\r\n          context: { where: 'replaceMustacheWithTemplateTag', got: info.type, expr },\r\n          docsUrl: './docs/error-codes.md#tmp',\r\n        });\r\n      }\r\n    } else if (type === 'elseif') {\r\n      const lastInfo = stack.at(-1) ?? raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Elseif without if',\r\n        context: { where: 'replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n      if (lastInfo.type === 'if' || lastInfo.type === 'elseif') {\r\n        stack.push(currentInfo);\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\"><template data-bind=\"if:${remain}\">`;\r\n      } else {\r\n        raiseError({\r\n          code: 'TMP-102',\r\n          message: 'Elseif without if',\r\n          context: { where: 'replaceMustacheWithTemplateTag', got: lastInfo.type, expr },\r\n          docsUrl: './docs/error-codes.md#tmp',\r\n        });\r\n      }\r\n    } else if (type === 'else') {\r\n      const lastInfo = stack.at(-1) ?? raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Else without if',\r\n        context: { where: 'replaceMustacheWithTemplateTag', expr, stackDepth: stack.length },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n      if (lastInfo.type === 'if') {\r\n        return `</template><template data-bind=\"if:${lastInfo.remain}|not\">`;\r\n      } else {\r\n        raiseError({\r\n          code: 'TMP-102',\r\n          message: 'Else without if',\r\n          context: { where: 'replaceMustacheWithTemplateTag', got: lastInfo.type, expr },\r\n          docsUrl: './docs/error-codes.md#tmp',\r\n        });\r\n      }\r\n    } else {\r\n      raiseError({\r\n        code: 'TMP-102',\r\n        message: 'Unknown type',\r\n        context: { where: 'replaceMustacheWithTemplateTag', type, expr },\r\n        docsUrl: './docs/error-codes.md#tmp',\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n\r\n\r\n","/**\r\n * replaceTemplateTagWithComment.ts\r\n *\r\n * <template>タグをコメントノードに置換し、テンプレートを再帰的に登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - 指定したHTMLTemplateElementをコメントノード（<!--template:id-->）に置換\r\n * - SVG内のtemplateタグは通常のtemplate要素に変換し、属性や子ノードを引き継ぐ\r\n * - テンプレート内の入れ子templateも再帰的に置換・登録\r\n * - registerTemplateでテンプレートをID付きで管理\r\n *\r\n * 設計ポイント:\r\n * - テンプレートの階層構造を維持しつつ、DOM上はコメントノードでマーク\r\n * - SVG対応や属性引き継ぎなど、汎用的なテンプレート処理に対応\r\n * - generateIdでユニークIDを割り当て、テンプレート管理を一元化\r\n */\r\nimport { COMMENT_TEMPLATE_MARK, DATA_BIND_ATTRIBUTE } from \"../constants.js\";\r\nimport { generateId } from \"../GlobalId/generateId.js\";\r\nimport { registerTemplate } from \"./registerTemplate.js\";\r\n\r\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\r\n\r\nexport function replaceTemplateTagWithComment(\r\n  id      : number, \r\n  template: HTMLTemplateElement,\r\n  rootId  : number = id\r\n):number {\r\n  // テンプレートの親ノードが存在する場合は、テンプレートをコメントノードに置き換える\r\n  template.parentNode?.replaceChild(document.createComment(`${COMMENT_TEMPLATE_MARK}${id}`), template);\r\n  if (template.namespaceURI === SVG_NS) {\r\n    // SVGタグ内のtemplateタグを想定\r\n    const newTemplate = document.createElement(\"template\");\r\n    const childNodes = Array.from(template.childNodes);\r\n    for(let i = 0; i < childNodes.length; i++) {\r\n      const childNode = childNodes[i];\r\n      newTemplate.content.appendChild(childNode);\r\n    }\r\n    const bindText = template.getAttribute(DATA_BIND_ATTRIBUTE);\r\n    newTemplate.setAttribute(DATA_BIND_ATTRIBUTE, bindText ?? \"\");\r\n    template = newTemplate;\r\n  }\r\n  template.content.querySelectorAll(\"template\").forEach(template => {\r\n    replaceTemplateTagWithComment(generateId(), template, rootId);\r\n  });\r\n  registerTemplate(id, template, rootId);\r\n  return id;\r\n}\r\n","/**\r\n * registerHtml.ts\r\n *\r\n * HTML文字列をテンプレートとして登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - 指定IDでHTMLテンプレートを生成し、data-id属性を付与\r\n * - Mustache構文（{{ }})をテンプレートタグに変換（replaceMustacheWithTemplateTagを利用）\r\n * - テンプレートタグをコメントに置換（replaceTemplateTagWithCommentを利用）\r\n *\r\n * 設計ポイント:\r\n * - テンプレートの動的生成・管理や、構文変換による柔軟なテンプレート処理に対応\r\n * - テンプレートはdocument.createElement(\"template\")で生成し、data-idで識別\r\n */\r\nimport { replaceMustacheWithTemplateTag } from \"./replaceMustacheWithTemplateTag.js\";\r\nimport { replaceTemplateTagWithComment } from \"./replaceTemplateTagWithComment.js\";\r\n\r\nexport function registerHtml(id: number, html:string) {\r\n  const template = document.createElement(\"template\");\r\n  template.dataset.id = id.toString();\r\n  template.innerHTML = replaceMustacheWithTemplateTag(html);\r\n  replaceTemplateTagWithComment(id, template);\r\n}","/**\r\n * createAccessorFunctions.ts\r\n *\r\n * Stateプロパティのパス情報（IStructuredPathInfo）から、動的なgetter/setter関数を生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - パス情報とgetter集合から、最適なアクセサ関数（get/set）を動的に生成\r\n * - ワイルドカード（*）やネストしたプロパティパスにも対応\r\n * - パスやセグメントのバリデーションも実施\r\n *\r\n * 設計ポイント:\r\n * - matchPathsから最長一致のgetterパスを探索し、そこからの相対パスでアクセサを構築\r\n * - パスが一致しない場合はinfo.pathSegmentsから直接アクセサを生成\r\n * - new Functionで高速なgetter/setterを動的生成\r\n * - パスやセグメント名は正規表現で厳密にチェックし、安全性を担保\r\n */\r\nimport { getStructuredPathInfo } from \"./getStructuredPathInfo\";\r\nimport { raiseError } from \"../utils\";\r\nimport { IAccessorFunctions, IStructuredPathInfo } from \"./types\";\r\n\r\nconst checkSegmentRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\r\nconst checkPathRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*(\\.[a-zA-Z_$][0-9a-zA-Z_$]*|\\.\\*)*$/;\r\n\r\nexport function createAccessorFunctions(info: IStructuredPathInfo, getters: Set<string>): IAccessorFunctions {\r\n  const matchPaths = new Set(info.cumulativePaths).intersection(getters);\r\n  let len = -1;\r\n  let matchPath = '';\r\n  for(const curPath of matchPaths) {\r\n    const pathSegments = curPath.split('.');\r\n    if (pathSegments.length === 1) {\r\n      continue;\r\n    }\r\n    if (pathSegments.length > len) {\r\n      len = pathSegments.length;\r\n      matchPath = curPath;\r\n    }\r\n  }\r\n  if (matchPath.length > 0) {\r\n    if (!checkPathRegexp.test(matchPath)) {\r\n      raiseError({\r\n        code: \"STATE-202\",\r\n        message: `Invalid path: ${matchPath}`,\r\n        context: { matchPath },\r\n        docsUrl: \"./docs/error-codes.md#state\",\r\n      });\r\n    }\r\n    const matchInfo = getStructuredPathInfo(matchPath);\r\n    const segments = [];\r\n    let count = matchInfo.wildcardCount;\r\n    for(let i = matchInfo.pathSegments.length; i < info.pathSegments.length; i++) {\r\n      const segment = info.pathSegments[i];\r\n      if (segment === '*') {\r\n        segments.push(\"[this.$\" + (count + 1) + \"]\");\r\n        count++;\r\n      } else {\r\n        if (!checkSegmentRegexp.test(segment)) {\r\n          raiseError({\r\n            code: \"STATE-202\",\r\n            message: `Invalid segment name: ${segment}`,\r\n            context: { segment, matchPath },\r\n            docsUrl: \"./docs/error-codes.md#state\",\r\n          });\r\n        }\r\n        segments.push(\".\" + segment);\r\n      }\r\n    }\r\n    const path = segments.join('');\r\n    return {\r\n      get : new Function('', `return this[\"${matchPath}\"]${path};`) as ()=> any,\r\n      set : new Function('value', `this[\"${matchPath}\"]${path} = value;`) as (value: any) => void,\r\n    }\r\n  } else {\r\n    const segments = [];\r\n    let count = 0;\r\n    for(let i = 0; i < info.pathSegments.length; i++) {\r\n      const segment = info.pathSegments[i];\r\n      if (segment === '*') {\r\n        segments.push(\"[this.$\" + (count + 1) + \"]\");\r\n        count++;\r\n      } else {\r\n        if (!checkSegmentRegexp.test(segment)) {\r\n          raiseError({\r\n            code: \"STATE-202\",\r\n            message: `Invalid segment name: ${segment}`,\r\n            context: { segment },\r\n            docsUrl: \"./docs/error-codes.md#state\",\r\n          });\r\n        }\r\n        segments.push((segments.length > 0 ? \".\" : \"\") + segment);\r\n      }\r\n    }\r\n    const path = segments.join('');\r\n    return {\r\n      get : new Function('', `return this.${path};`) as ()=> any,\r\n      set : new Function('value', `this.${path} = value;`) as (value: any) => void,\r\n    }\r\n  }\r\n\r\n}\r\n","import { getListPathsSetById, getPathsSetById } from \"../BindingBuilder/registerDataBindAttributes\";\r\nimport { RESERVED_WORD_SET } from \"../constants\";\r\nimport { addPathNode, createRootNode } from \"../PathTree/PathNode\";\r\nimport { IPathNode } from \"../PathTree/types\";\r\nimport { createAccessorFunctions } from \"../StateProperty/createAccessorFunctions\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo\";\r\nimport { Constructor } from \"../types\";\r\nimport { StructiveComponentClass } from \"../WebComponents/types\";\r\nimport { Dependencies, IPathManager } from \"./types\";\r\n\r\nclass PathManager implements IPathManager {\r\n  alls: Set<string> = new Set<string>();\r\n  lists: Set<string> = new Set<string>();\r\n  elements: Set<string> = new Set<string>();\r\n  funcs: Set<string> = new Set<string>();\r\n  getters: Set<string> = new Set<string>();\r\n  onlyGetters: Set<string> = new Set<string>();\r\n  setters: Set<string> = new Set<string>();\r\n  getterSetters: Set<string> = new Set<string>();\r\n  optimizes: Set<string> = new Set<string>();\r\n  staticDependencies: Dependencies<string> = new Map<string, Set<string>>();\r\n  dynamicDependencies: Dependencies<string> = new Map<string, Set<string>>();\r\n  rootNode: IPathNode = createRootNode();\r\n  #id: number;\r\n  #stateClass: Constructor<any>;\r\n\r\n  constructor(componentClass: StructiveComponentClass) {\r\n    this.#id = componentClass.id;\r\n    this.#stateClass = componentClass.stateClass;\r\n    const alls = getPathsSetById(this.#id);\r\n    for(const path of alls) {\r\n      const info = getStructuredPathInfo(path);\r\n      this.alls = this.alls.union(info.cumulativePathSet);\r\n    }\r\n    const lists = getListPathsSetById(this.#id);\r\n    this.lists = this.lists.union(lists);\r\n    for(const listPath of lists) {\r\n      const elementPath = listPath + \".*\";\r\n      this.elements.add(elementPath);\r\n    }\r\n    let currentProto = this.#stateClass.prototype;\r\n    while (currentProto && currentProto !== Object.prototype) {\r\n      const getters = Object.getOwnPropertyDescriptors(currentProto);\r\n      if (getters) {\r\n        for (const [key, desc] of Object.entries(getters)) {\r\n          if (RESERVED_WORD_SET.has(key)) {\r\n            continue;\r\n          }\r\n          if (typeof desc.value === \"function\") {\r\n            this.funcs.add(key);\r\n            continue;\r\n          }\r\n          const hasGetter = (desc as PropertyDescriptor).get !== undefined;\r\n          const hasSetter = (desc as PropertyDescriptor).set !== undefined;\r\n          const info = getStructuredPathInfo(key);\r\n          this.alls = this.alls.union(info.cumulativePathSet);\r\n          if (hasGetter) {\r\n            this.getters.add(key);\r\n          }\r\n          if (hasSetter) {\r\n            this.setters.add(key);\r\n          }\r\n          if (hasGetter && !hasSetter) {\r\n            this.onlyGetters.add(key);\r\n          }\r\n          if (hasGetter && hasSetter) {\r\n            this.getterSetters.add(key);\r\n          }\r\n        }\r\n      }\r\n      currentProto = Object.getPrototypeOf(currentProto);\r\n    }\r\n    // 最適化対象のパスを決定し、最適化する\r\n    for(const path of this.alls) {\r\n      if (this.getters.has(path)) {\r\n        continue;\r\n      }\r\n      if (this.setters.has(path)) {\r\n        continue;\r\n      }\r\n      const info = getStructuredPathInfo(path);\r\n      if (info.pathSegments.length === 1) {\r\n        continue;\r\n      }\r\n      const funcs = createAccessorFunctions(info, this.getters);\r\n      Object.defineProperty(this.#stateClass.prototype, path, {\r\n        get: funcs.get,\r\n        set: funcs.set,\r\n        enumerable: true,\r\n        configurable: true,\r\n      });\r\n      this.optimizes.add(path);\r\n    }\r\n    // 静的依存関係の設定\r\n    for(const path of this.alls) {\r\n      addPathNode(this.rootNode, path);\r\n      const info = getStructuredPathInfo(path);\r\n      if (info.parentPath) {\r\n        this.staticDependencies.get(info.parentPath)?.add(path) ?? \r\n          this.staticDependencies.set(info.parentPath, new Set([path]));\r\n      }\r\n    }\r\n  }\r\n\r\n  #dianamicDependencyKeys = new Set<string>();\r\n  addDynamicDependency(target: string, source: string) {\r\n    const key = `${source}=>${target}`;\r\n    if (this.#dianamicDependencyKeys.has(key)) {\r\n      return;\r\n    }\r\n    this.#dianamicDependencyKeys.add(key);\r\n    this.dynamicDependencies.get(source)?.add(target) ?? \r\n      this.dynamicDependencies.set(source, new Set([target]));\r\n  }\r\n}\r\n\r\nexport function createPathManager(componentClass: StructiveComponentClass): IPathManager {\r\n  return new PathManager(componentClass);\r\n}","/**\r\n * createComponentClass.ts\r\n *\r\n * StructiveのWeb Components用カスタム要素クラスを動的に生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - ユーザー定義のcomponentData（stateClass, html, css等）からWeb Componentsクラスを生成\r\n * - StateClass/テンプレート/CSS/バインディング情報などをIDで一元管理・登録\r\n * - 独自のget/setトラップやバインディング、親子コンポーネント探索、フィルター拡張など多機能な基盤を提供\r\n * - 静的プロパティでテンプレート・スタイル・StateClass・フィルター・getter情報などにアクセス可能\r\n * - defineメソッドでカスタム要素として登録\r\n *\r\n * 設計ポイント:\r\n * - findStructiveParentで親Structiveコンポーネントを探索し、階層的な状態管理を実現\r\n * - getter/setter/バインディング最適化やアクセサ自動生成（optimizeAccessor）に対応\r\n * - テンプレート・CSS・StateClass・バインディング情報をIDで一元管理し、再利用性・拡張性を確保\r\n * - フィルターやバインディング情報も静的プロパティで柔軟に拡張可能\r\n */\r\nimport { inputBuiltinFilters, outputBuiltinFilters } from \"../Filter/builtinFilters.js\";\r\nimport { FilterWithOptions } from \"../Filter/types\";\r\nimport { generateId } from \"../GlobalId/generateId.js\";\r\nimport { getStateClassById, registerStateClass } from \"../StateClass/registerStateClass.js\";\r\nimport { getStyleSheetById } from \"../StyleSheet/registerStyleSheet.js\";\r\nimport { registerCss } from \"../StyleSheet/regsiterCss.js\";\r\nimport { createComponentEngine } from \"../ComponentEngine/ComponentEngine.js\";\r\nimport { IComponentEngine } from \"../ComponentEngine/types.js\";\r\nimport { registerHtml } from \"../Template/registerHtml.js\";\r\nimport { getTemplateById } from \"../Template/registerTemplate.js\";\r\nimport { getBaseClass } from \"./getBaseClass.js\";\r\nimport { getComponentConfig } from \"./getComponentConfig.js\";\r\nimport { IComponent, IUserComponentData, IUserConfig, StructiveComponentClass, StructiveComponent } from \"./types\";\r\nimport { getListPathsSetById, getPathsSetById } from \"../BindingBuilder/registerDataBindAttributes.js\";\r\nimport { IStructiveState } from \"../StateClass/types\";\r\nimport { IBinding } from \"../DataBinding/types\";\r\nimport { getStructuredPathInfo } from \"../StateProperty/getStructuredPathInfo.js\";\r\nimport { createAccessorFunctions } from \"../StateProperty/createAccessorFunctions.js\";\r\nimport { config as globalConfig } from \"./getGlobalConfig.js\";\r\nimport { raiseError } from \"../utils.js\";\r\nimport { IComponentStateInput } from \"../ComponentStateInput/types.js\";\r\nimport { findStructiveParent } from \"./findStructiveParent.js\";\r\nimport { IPathManager } from \"../PathManager/types.js\";\r\nimport { createPathManager } from \"../PathManager/PathManager.js\";\r\n\r\n\r\nexport function createComponentClass(componentData: IUserComponentData): StructiveComponentClass {\r\n  const config = (componentData.stateClass.$config ?? {})as IUserConfig;\r\n  const componentConfig = getComponentConfig(config);\r\n  const id = generateId();\r\n  const { html, css, stateClass } = componentData;\r\n  const inputFilters:FilterWithOptions = Object.assign({}, inputBuiltinFilters);\r\n  const outputFilters:FilterWithOptions = Object.assign({}, outputBuiltinFilters);\r\n  stateClass.$isStructive = true;\r\n  registerHtml(id, html);\r\n  registerCss(id, css);\r\n  registerStateClass(id, stateClass);\r\n  const baseClass = getBaseClass(componentConfig.extends);\r\n  const extendTagName = componentConfig.extends;\r\n  return class extends baseClass implements IComponent {\r\n    #engine: IComponentEngine;\r\n\r\n    constructor() {\r\n      super();\r\n      this.#engine = createComponentEngine(componentConfig, this as StructiveComponent);\r\n      this.#engine.setup();\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.#engine.connectedCallback();\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.#engine.disconnectedCallback();\r\n    }\r\n\r\n    #parentStructiveComponent: StructiveComponent | null | undefined;\r\n    get parentStructiveComponent(): StructiveComponent | null {\r\n      if (typeof this.#parentStructiveComponent === \"undefined\") {\r\n        this.#parentStructiveComponent = findStructiveParent(this as StructiveComponent);\r\n      }\r\n      return this.#parentStructiveComponent;\r\n    }\r\n\r\n    get state(): IComponentStateInput {\r\n      return this.#engine.stateInput;\r\n    }\r\n\r\n    get isStructive(): boolean {\r\n      return this.#engine.stateClass.$isStructive ?? false;\r\n    }\r\n\r\n    get waitForInitialize(): PromiseWithResolvers<void> {\r\n      return this.#engine.waitForInitialize;\r\n    }\r\n\r\n    getBindingsFromChild(component: IComponent): Set<IBinding> | null {\r\n      return this.#engine.bindingsByComponent.get(component as StructiveComponent) ?? null;\r\n    }\r\n\r\n    registerChildComponent(component:StructiveComponent): void {\r\n      this.#engine.registerChildComponent(component);\r\n    }\r\n    unregisterChildComponent(component:StructiveComponent): void {\r\n      this.#engine.unregisterChildComponent(component);\r\n    }\r\n    static define(tagName:string) {\r\n      if (extendTagName) {\r\n        customElements.define(tagName, this, { extends: extendTagName });\r\n      } else {\r\n        customElements.define(tagName, this);\r\n      }\r\n    }\r\n\r\n    static get id():number {\r\n      return id;\r\n    }\r\n    static #html:string = html;\r\n    static get html():string {\r\n      return this.#html;\r\n    }\r\n    static set html(value:string) {\r\n      this.#html = value;\r\n      registerHtml(this.id, value);\r\n      this.#template = null;\r\n      this.#pathManager = null; // パス情報をリセット\r\n    }\r\n\r\n    static #css:string = css;\r\n    static get css() {\r\n      return this.#css;\r\n    }\r\n    static set css(value:string) {\r\n      this.#css = value;\r\n      registerCss(this.id, value);\r\n      this.#styleSheet = null;\r\n    }\r\n    static #template: HTMLTemplateElement | null = null;\r\n    static get template():HTMLTemplateElement {\r\n      if (!this.#template) {\r\n        this.#template = getTemplateById(this.id);\r\n      }\r\n      return this.#template;\r\n    }\r\n    static #styleSheet: CSSStyleSheet | null = null;\r\n    static get styleSheet():CSSStyleSheet {\r\n      if (!this.#styleSheet) {\r\n        this.#styleSheet = getStyleSheetById(this.id);\r\n      }\r\n      return this.#styleSheet;\r\n    }\r\n    static #stateClass: IStructiveState | null = null;\r\n    static get stateClass():IStructiveState {\r\n      if (!this.#stateClass) {\r\n        this.#stateClass = getStateClassById(this.id) as IStructiveState;\r\n      }\r\n      return this.#stateClass;\r\n    }\r\n    static #inputFilters:FilterWithOptions = inputFilters;\r\n    static get inputFilters():FilterWithOptions {\r\n      return this.#inputFilters;\r\n    }\r\n    static #outputFilters:FilterWithOptions = outputFilters;\r\n    static get outputFilters():FilterWithOptions {\r\n      return this.#outputFilters;\r\n    }\r\n    static #pathManager: IPathManager | null = null;\r\n    static get pathManager(): IPathManager {\r\n      if (!this.#pathManager) {\r\n        this.#pathManager = createPathManager(this as StructiveComponentClass);\r\n      }\r\n      return this.#pathManager;\r\n    }\r\n\r\n  } as StructiveComponentClass;\r\n}\r\n","/**\r\n * getComponentConfig.ts\r\n *\r\n * ユーザー設定（IUserConfig）とグローバル設定を統合し、コンポーネントの設定（IComponentConfig）を生成するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - getGlobalConfigでグローバル設定を取得\r\n * - ユーザー設定が優先され、未指定の場合はグローバル設定値を利用\r\n * - enableShadowDomやextendsなどの設定値を一元的に返却\r\n *\r\n * 設計ポイント:\r\n * - ユーザーごとの個別設定と全体のデフォルト設定を柔軟に統合\r\n * - 設定値のデフォルト化や拡張性を考慮した設計\r\n */\r\nimport { getGlobalConfig } from \"./getGlobalConfig.js\";\r\nimport { IUserConfig, IComponentConfig } from \"./types\";\r\n\r\nexport function getComponentConfig(userConfig: IUserConfig): IComponentConfig {\r\n  const globalConfig = getGlobalConfig();\r\n  return {\r\n    enableWebComponents: typeof userConfig.enableWebComponents === \"undefined\" ? true : userConfig.enableWebComponents,\r\n    enableShadowDom    : userConfig.enableShadowDom ?? globalConfig.enableShadowDom,\r\n    extends            : userConfig.extends ?? null,\r\n  };\r\n}","/**\r\n * getBaseClass.ts\r\n *\r\n * 指定したタグ名（extendTagName）から、その要素のコンストラクタ（基底クラス）を取得するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - extendTagNameが指定されていれば、そのタグのHTMLElementコンストラクタを返す\r\n * - 指定がなければHTMLElementを返す\r\n *\r\n * 設計ポイント:\r\n * - カスタム要素の継承元クラスを動的に取得し、柔軟なWeb Components拡張に対応\r\n */\r\nimport { Constructor } from \"../types\";\r\n\r\nexport function getBaseClass(extendTagName: string | null):Constructor<HTMLElement> {\r\n  return extendTagName ? (document.createElement(extendTagName).constructor as Constructor<HTMLElement>) : HTMLElement;\r\n}","/**\r\n * createSingleFileComponent.ts\r\n *\r\n * Structive用のシングルファイルコンポーネント（SFC）をパースし、各要素（HTML, CSS, StateClass）を抽出・生成するユーティリティです。\r\n *\r\n * 主な役割:\r\n * - テキストから<template>・<script type=\"module\">・<style>を抽出し、それぞれを分離\r\n * - <script type=\"module\">はBase64エンコードして動的importし、StateClassとして利用\r\n * - {{...}}埋め込み式は一時的にコメントノード化してHTMLパース時の消失を防止し、復元\r\n * - 各要素（html, css, stateClass, text）をIUserComponentDataとして返却\r\n *\r\n * 設計ポイント:\r\n * - escapeEmbed/unescapeEmbedでMustache構文の安全なパースを実現\r\n * - scriptはdata:URL経由で安全に動的import\r\n * - テンプレート・スクリプト・スタイルを柔軟に分離・管理できる設計\r\n */\r\nimport { IStructiveState } from \"../StateClass/types\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nfunction escapeEmbed(html: string): string {\r\n  return html.replaceAll(/\\{\\{([^\\}]+)\\}\\}/g, (match, expr) => {\r\n    return `<!--{{${expr}}}-->`;\r\n  });\r\n}\r\n\r\nfunction unescapeEmbed(html:string):string {\r\n  return html.replaceAll(/<!--\\{\\{([^\\}]+)\\}\\}-->/g, (match, expr) => {\r\n    return `{{${expr}}}`;\r\n  });\r\n}\r\n\r\nexport async function createSingleFileComponent(text: string): Promise<IUserComponentData> {\r\n  const template = document.createElement(\"template\");\r\n  template.innerHTML = escapeEmbed(text);\r\n\r\n  const html = template.content.querySelector(\"template\");\r\n  html?.remove();\r\n\r\n  const script = template.content.querySelector(\"script[type=module]\") as HTMLScriptElement | null;\r\n  let scriptModule: any = {};\r\n  if (script) {\r\n    const b64 = btoa(String.fromCodePoint(...new TextEncoder().encode(script.text)));\r\n    scriptModule = await import(\"data:application/javascript;base64,\" + b64);\r\n  }\r\n//  const scriptModule = script ? await import(\"data:text/javascript;charset=utf-8,\" + script.text) : {};\r\n  script?.remove();\r\n\r\n  const style = template.content.querySelector(\"style\");\r\n  style?.remove();\r\n\r\n  const stateClass = (scriptModule.default ?? class {}) as IStructiveState;\r\n  \r\n  return {\r\n    text,\r\n    html      : unescapeEmbed(html?.innerHTML ?? \"\").trim(),\r\n    css       : style?.textContent ?? \"\",\r\n    stateClass,\r\n  }\r\n}","/**\r\n * loadSingleFileComponent.ts\r\n *\r\n * 指定パスのシングルファイルコンポーネント（SFC）をfetchし、パースしてIUserComponentDataとして返すユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - fetchで指定パスのSFCファイルを取得\r\n * - テキストとして読み込み、createSingleFileComponentでパース\r\n * - パース結果（IUserComponentData）を返却\r\n *\r\n * 設計ポイント:\r\n * - import.meta.resolveを利用し、パス解決の柔軟性を確保\r\n * - 非同期処理で動的なコンポーネントロードに対応\r\n */\r\nimport { createSingleFileComponent } from \"./createSingleFileComponent.js\";\r\nimport { IUserComponentData } from \"./types\";\r\n\r\nexport async function loadSingleFileComponent(path: string): Promise<IUserComponentData> {\r\n  // Node/Vitest 等の SSR 環境では import.meta.resolve が存在しない場合があるためフォールバック\r\n  const resolved = (import.meta as any).resolve ? (import.meta as any).resolve(path) : path;\r\n  const response = await fetch(resolved);\r\n  const text = await response.text();\r\n  return createSingleFileComponent(text);\r\n}\r\n","/**\r\n * registerComponentClass.ts\r\n *\r\n * StructiveのWeb Componentsクラスを指定したタグ名でカスタム要素として登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - registerComponentClass: 渡されたcomponentClassをtagNameでdefineメソッドを使って登録\r\n *\r\n * 設計ポイント:\r\n * - Web Componentsのカスタム要素登録を簡潔にラップし、再利用性を高める設計\r\n */\r\nimport { StructiveComponentClass } from \"./types\";\r\n\r\nexport function registerComponentClass(tagName: string, componentClass: StructiveComponentClass) {\r\n  componentClass.define(tagName);\r\n}","/**\r\n * loadImportmap.ts\r\n *\r\n * HTML内の<script type=\"importmap\">タグからimportmap情報を取得・統合するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - 複数のimportmapスクリプトタグを走査し、全てのimportsをマージしてIImportMap型で返却\r\n *\r\n * 設計ポイント:\r\n * - scriptタグのinnerHTMLをJSON.parseでパースし、importsプロパティを統合\r\n * - importmap.importsが複数存在する場合もObject.assignでマージ\r\n * - importmap仕様に準拠し、柔軟なimportエイリアス管理を実現\r\n */\r\nimport { IImportMap } from \"./types\";\r\n\r\nexport function loadImportmap():IImportMap {\r\n  const importmap: IImportMap = {};\r\n  document.querySelectorAll(\"script[type='importmap']\").forEach(script => {\r\n    const scriptImportmap = JSON.parse(script.innerHTML);\r\n    if (scriptImportmap.imports) {\r\n      importmap.imports = Object.assign(importmap.imports || {}, scriptImportmap.imports);\r\n    }\r\n  });\r\n  return importmap;\r\n}\r\n\r\n","/**\r\n * Router.ts\r\n *\r\n * シングルページアプリケーション（SPA）向けのカスタムエレメント Router の実装です。\r\n *\r\n * 主な役割:\r\n * - ルート定義（entryRoute）に基づき、URLパスに応じてカスタム要素を動的に生成・表示\r\n * - pushState/popstateイベントを利用した履歴管理とルーティング制御\r\n * - ルートパラメータの抽出とカスタム要素への受け渡し\r\n * - 404ページ（未定義ルート時）の表示\r\n *\r\n * 設計ポイント:\r\n * - entryRouteでルートパスとカスタム要素タグ名のペアを登録\r\n * - popstateイベントでURL変更時に自動で再描画\r\n * - ルートパスのパラメータ（:id等）も正規表現で抽出し、data-state属性で渡す\r\n * - getRouterでグローバルなRouterインスタンスを取得可能\r\n */\r\nimport { isLazyLoadComponent, loadLazyLoadComponent } from \"../WebComponents/loadFromImportMap\";\r\nimport { IRouter } from \"./types\";\r\n\r\nconst DEFAULT_ROUTE_PATH = '/'; // Default route path\r\nconst ROUTE_PATH_PREFIX = 'routes:'; // Prefix for route paths\r\n/**\r\n * example:\r\n * ```ts\r\n * entryRoute('my-view', '/my-view/:id');\r\n */\r\nconst routeEntries: Array<[string, string]> = [];\r\n\r\nlet globalRouter : Router | null = null;\r\n\r\nexport class Router extends HTMLElement implements IRouter {\r\n  originalPathName = window.location.pathname; // Store the original path name\r\n  originalFileName = window.location.pathname.split('/').pop() || ''; // Store the original file name\r\n  basePath = document.querySelector('base')?.href.replace(window.location.origin, \"\") || DEFAULT_ROUTE_PATH;\r\n\r\n  _popstateHandler: (event: PopStateEvent) => void;\r\n  constructor() {\r\n    super();\r\n    this._popstateHandler = this.popstateHandler.bind(this);\r\n  }\r\n\r\n  connectedCallback() {\r\n    globalRouter = this;\r\n    this.innerHTML = '<slot name=\"content\"></slot>';\r\n    window.addEventListener('popstate', this._popstateHandler);\r\n    window.dispatchEvent(new Event(\"popstate\")); // Dispatch popstate event to trigger the initial render\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    window.removeEventListener('popstate', this._popstateHandler);\r\n    globalRouter = null;\r\n  }\r\n\r\n  popstateHandler(event: PopStateEvent) {\r\n    event.preventDefault();\r\n    this.render();\r\n  }\r\n\r\n  navigate(to: string) {\r\n    const toPath = to[0] === '/' ? (this.basePath + to.slice(1)) : to; // Ensure the path starts with '/'\r\n    history.pushState({}, '', toPath);\r\n    this.render();\r\n  }\r\n\r\n  render() {\r\n    // スロットコンテントをクリア\r\n    const slotChildren = Array.from(this.childNodes).filter(\r\n      n => (n as HTMLElement).getAttribute?.('slot') === 'content'\r\n    );\r\n    slotChildren.forEach(n => this.removeChild(n));\r\n\r\n    const paths = window.location.pathname.split('/');\r\n    if (paths.at(-1) === this.originalFileName) {\r\n      paths[paths.length - 1] = ''; // Ensure the last path is empty for root\r\n    }\r\n    const pathName = paths.join('/');\r\n    const replacedPath = pathName.replace(this.basePath, ''); // Remove base path and ensure default route\r\n    const currentPath = replacedPath[0] !== '/' ? '/' + replacedPath : replacedPath; // Ensure the path starts with '/'\r\n    let tagName: string | undefined = undefined;\r\n    let params: Record<string, string> = {};\r\n    // Check if the routePath matches any of the defined routes\r\n    for (const [path, tag] of routeEntries) {\r\n      const regex = new RegExp(\"^\" + path.replace(/:[^\\s/]+/g, '([^/]+)') + \"$\");\r\n      if (regex.test(currentPath)) {\r\n        tagName = tag;\r\n        // Extract the parameters from the routePath\r\n        const matches = currentPath.match(regex);\r\n        if (matches) {\r\n          const keys = path.match(/:[^\\s/]+/g) || [];\r\n          keys.forEach((key, index) => {\r\n            params[key.substring(1)] = matches[index + 1]; // +1 to skip the full match\r\n          });\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    if (tagName) {\r\n      // If a route matches, create the custom element and set its state\r\n      // Create the custom element with the tag name\r\n      // project the custom element into the router slot\r\n      const customElement = document.createElement(tagName) as HTMLElement;\r\n      customElement.setAttribute('data-state', JSON.stringify(params));\r\n      customElement.setAttribute('slot', 'content');\r\n      this.appendChild(customElement);\r\n      if (isLazyLoadComponent(tagName)) {\r\n        loadLazyLoadComponent(tagName); // Load lazy load component if necessary\r\n      }\r\n    } else {\r\n      // If no route matches, show 404 content\r\n      const messageElement = document.createElement('h1') as HTMLElement;\r\n      messageElement.setAttribute('slot', 'content');\r\n      messageElement.textContent = '404 Not Found';\r\n      this.appendChild(messageElement);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport function entryRoute(tagName: string, routePath: string): void {\r\n  if (routePath.startsWith(ROUTE_PATH_PREFIX)) {\r\n    routePath = routePath.substring(ROUTE_PATH_PREFIX.length); // Remove 'routes:' prefix\r\n  }\r\n  routeEntries.push([routePath, tagName]);\r\n}\r\n\r\nexport function getRouter(): Router | null {\r\n  return globalRouter;\r\n}\r\n\r\n","/**\r\n * MainWrapper.ts\r\n *\r\n * アプリ全体のレイアウトやルーティングを管理するカスタムエレメント MainWrapper の実装です。\r\n *\r\n * 主な役割:\r\n * - Shadow DOMの有効化やレイアウトテンプレートの動的読み込み\r\n * - レイアウトテンプレートやスタイルの適用\r\n * - ルーター要素（routerTagName）の動的追加\r\n *\r\n * 設計ポイント:\r\n * - config.enableShadowDom でShadow DOMの有効/無効を切り替え\r\n * - config.layoutPath が指定されていればfetchでレイアウトHTMLを取得し、テンプレート・スタイルを適用\r\n * - スタイルはadoptedStyleSheetsでShadowRootまたはdocumentに適用\r\n * - レイアウトが指定されていない場合はデフォルトのslotを挿入\r\n * - config.enableRouter が有効な場合はrouter要素をslotに追加\r\n */\r\nimport { raiseError } from \"../utils\";\r\nimport { config } from \"../WebComponents/getGlobalConfig\";\r\n\r\nconst SLOT_KEY = \"router\";\r\nconst DEFAULT_LAYOUT = `<slot name=\"${SLOT_KEY}\"></slot>`;\r\n\r\nexport class MainWrapper extends HTMLElement {\r\n  constructor() {\r\n    super();\r\n    if (config.enableShadowDom) {\r\n      this.attachShadow({ mode: 'open' });\r\n    }\r\n  }\r\n\r\n  async connectedCallback() {\r\n    await this.loadLayout();\r\n    this.render();\r\n  }\r\n\r\n  get root(): ShadowRoot | HTMLElement {\r\n    return this.shadowRoot ?? this;\r\n  }\r\n\r\n  async loadLayout() {\r\n    if (config.layoutPath) {\r\n      const response = await fetch(config.layoutPath);\r\n      if (response.ok) {\r\n        const layoutText = await response.text();\r\n        const workTemplate = document.createElement(\"template\");\r\n        workTemplate.innerHTML = layoutText;\r\n      \r\n        const template = workTemplate.content.querySelector(\"template\");\r\n        const style = workTemplate.content.querySelector(\"style\") as CSSStyleSheet | null;\r\n      \r\n        this.root.appendChild(template?.content ?? document.createDocumentFragment());\r\n        if (style) {\r\n          const shadowRootOrDocument = this.shadowRoot ?? document;\r\n          const styleSheets = shadowRootOrDocument.adoptedStyleSheets;\r\n          if (!styleSheets.includes(style)) {\r\n            shadowRootOrDocument.adoptedStyleSheets = [...styleSheets, style];\r\n          }\r\n        }\r\n      } else {\r\n        raiseError({\r\n          code: 'TMP-101',\r\n          message: `Failed to load layout from ${config.layoutPath}`,\r\n          context: { layoutPath: config.layoutPath },\r\n          docsUrl: '/docs/error-codes.md#tmp',\r\n          severity: 'error',\r\n        });\r\n      }\r\n    } else {\r\n      this.root.innerHTML = DEFAULT_LAYOUT;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    // add router\r\n    if (config.enableRouter) {\r\n      const router = document.createElement(config.routerTagName);\r\n      router.setAttribute('slot', SLOT_KEY);\r\n      this.root.appendChild(router);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * exports.ts\r\n *\r\n * Structiveの主要なエントリーポイント・APIを外部公開するモジュールです。\r\n *\r\n * 主な役割:\r\n * - registerSingleFileComponents, bootstrap, config などの主要APIをエクスポート\r\n * - defineComponents: SFC群をまとめて登録し、autoInitが有効なら自動で初期化\r\n * - bootstrapStructive: 初期化処理を一度だけ実行\r\n *\r\n * 設計ポイント:\r\n * - グローバル設定(config)を外部から参照・変更可能\r\n * - 初期化処理の多重実行を防止し、安全な起動を保証\r\n */\r\nimport { registerSingleFileComponents } from \"./WebComponents/registerSingleFIleComponents.js\";\r\nimport { bootstrap } from \"./bootstrap.js\";\r\nimport { config as _config } from \"./WebComponents/getGlobalConfig.js\";\r\nimport { IConfig } from \"./WebComponents/types\";\r\n\r\nexport const config: IConfig = _config;\r\n\r\nlet initialized = false;\r\nexport async function defineComponents(singleFileComponents: Record<string, string>):Promise<void> {\r\n  await registerSingleFileComponents(singleFileComponents);\r\n  if (config.autoInit) {\r\n    await bootstrapStructive();\r\n  }\r\n}\r\n\r\nexport async function bootstrapStructive():Promise<void> {\r\n  if (!initialized) {\r\n    await bootstrap();\r\n    initialized = true;\r\n  }\r\n}\r\n\r\n","/**\r\n * registerSingleFileComponents.ts\r\n *\r\n * 複数のシングルファイルコンポーネント（SFC）をまとめてStructiveのWeb Componentsとして登録するユーティリティ関数です。\r\n *\r\n * 主な役割:\r\n * - singleFileComponents（tagNameとパスのマップ）を走査し、各SFCを非同期で取得・パース\r\n * - enableRouterが有効な場合はentryRouteでルーティング情報も登録\r\n * - createComponentClassでWeb Componentsクラスを生成し、registerComponentClassでカスタム要素として登録\r\n *\r\n * 設計ポイント:\r\n * - SFCのロードからWeb Components登録、ルーティング登録までを一括で自動化\r\n * - 非同期処理で複数コンポーネントの動的登録に対応\r\n * - ルートパス\"/root\"の正規化や、@routesプレフィックスの除去など柔軟なパス処理\r\n */\r\nimport { entryRoute } from \"../Router/Router.js\";\r\nimport { createComponentClass } from \"./createComponentClass.js\";\r\nimport { config } from \"./getGlobalConfig.js\";\r\nimport { loadSingleFileComponent } from \"./loadSingleFileComponent.js\";\r\nimport { registerComponentClass } from \"./registerComponentClass.js\";\r\nimport { IUserComponentData, SingleFileComponents } from \"./types\";\r\n\r\nexport async function registerSingleFileComponents(singleFileComponents:SingleFileComponents):Promise<void> {\r\n  for(const [ tagName, path ] of Object.entries(singleFileComponents)) {\r\n    let componentData : IUserComponentData | null = null;\r\n    if (config.enableRouter) {\r\n      const routePath = path.startsWith(\"@routes\") ? path.slice(7) : path; // remove the prefix 'routes:'\r\n      entryRoute(tagName, routePath === \"/root\" ? \"/\" : routePath); // routing\r\n    }\r\n    componentData = await loadSingleFileComponent(path);\r\n    const componentClass = createComponentClass(componentData);\r\n    registerComponentClass(tagName, componentClass);\r\n  }\r\n}","/**\r\n * bootstrap.ts\r\n *\r\n * Structiveアプリケーションの初期化処理を行うエントリーポイントです。\r\n *\r\n * 主な役割:\r\n * - グローバル設定(config)に従い、必要なコンポーネントやルーター、メインラッパーを登録・初期化\r\n * - autoLoadFromImportMapが有効な場合はimportmapからルートやコンポーネントを動的ロード\r\n * - enableRouterが有効な場合はRouterコンポーネントをカスタム要素として登録\r\n * - enableMainWrapperが有効な場合はMainWrapperをカスタム要素として登録し、autoInsertMainWrapperが有効ならbodyに自動挿入\r\n *\r\n * 設計ポイント:\r\n * - 設定値に応じて初期化処理を柔軟に制御\r\n * - importmapやカスタム要素の登録、DOMへの自動挿入など、Structiveの起動に必要な処理を一元化\r\n */\r\nimport { MainWrapper } from \"./MainWrapper/MainWrapper.js\";\r\nimport { Router } from \"./Router/Router.js\";\r\nimport { config } from \"./WebComponents/getGlobalConfig.js\";\r\nimport { loadFromImportMap } from \"./WebComponents/loadFromImportMap.js\";\r\n\r\nexport async function bootstrap(): Promise<void> {\r\n  if (config.autoLoadFromImportMap) {\r\n    await loadFromImportMap();\r\n  }\r\n\r\n  if (config.enableRouter) {\r\n    customElements.define(config.routerTagName, Router);\r\n  }\r\n\r\n  if (config.enableMainWrapper) {\r\n    customElements.define(config.mainTagName, MainWrapper);\r\n    if (config.autoInsertMainWrapper) {\r\n      const mainWrapper = document.createElement(config.mainTagName);\r\n      document.body.appendChild(mainWrapper);\r\n    }\r\n  }\r\n}"],"names":["globalConfig","debug","locale","enableShadowDom","enableMainWrapper","enableRouter","autoInsertMainWrapper","autoInit","mainTagName","routerTagName","layoutPath","autoLoadFromImportMap","optimizeList","optimizeListElements","optimizeAccessor","getGlobalConfig","config","raiseError","messageOrPayload","Error","message","code","context","hint","t","docsUrl","o","severity","i","cause","err","optionsRequired","fnName","optionMustBeNumber","valueMustBeNumber","valueMustBeDate","builtinFilters","eq","options","opt","value","optValue","Number","isNaN","ne","not","lt","le","gt","ge","inc","dec","mul","div","fix","toFixed","toLocaleString","uc","toString","toUpperCase","lc","toLowerCase","cap","v","length","charAt","slice","trim","substr","opt1","opt1Value","opt2","opt2Value","pad","padStart","rep","repeat","rev","split","reverse","join","int","parseInt","float","parseFloat","round","Math","pow","floor","ceil","percent","date","Date","toLocaleDateString","time","toLocaleTimeString","datetime","ymd","year","getFullYear","month","getMonth","day","getDate","falsy","truthy","defaults","boolean","Boolean","number","string","String","null","outputBuiltinFilters","inputBuiltinFilters","id","generateId","stateClassById","styleSheetById","registerCss","css","styleSheet","CSSStyleSheet","replaceSync","registerStyleSheet","resolveNodeFromPath","root","path","node","childNodes","textToFilter","filters","text","filter","name","where","cache","Map","createFilters","texts","result","get","push","set","BindingNode","binding","decorates","bindContents","this","subName","constructor","init","assignValue","updateElements","listIndexes","values","notifyRedraw","refs","applyChange","renderer","updatedBindings","has","filteredValue","bindingState","getFilteredValue","readonlyState","readonlyHandler","add","isSelectElement","HTMLSelectElement","isFor","isBlock","BindingNodeAttribute","super","setAttribute","BindingNodeCheckbox","Array","isArray","receivedType","element","checked","map","_val","includes","BindingNodeClassList","className","BindingNodeClassName","classList","remove","DATA_BIND_ATTRIBUTE","COMMENT_EMBED_MARK","COMMENT_TEMPLATE_MARK","RESERVED_WORD_SET","Set","_cache","StructuredPathInfo","static","sid","pattern","pathSegments","lastSegment","cumulativePaths","cumulativePathSet","cumulativeInfos","cumulativeInfoSet","wildcardPaths","wildcardPathSet","wildcardInfos","indexByWildcardPath","wildcardInfoSet","wildcardParentPaths","wildcardParentPathSet","wildcardParentInfos","wildcardParentInfoSet","lastWildcardPath","lastWildcardInfo","parentPath","parentInfo","wildcardCount","children","getPattern","_pattern","getStructuredPathInfo","currentPatternPath","prevPatternPath","structuredPath","info","NodePath","currentPath","childNodeByName","level","find","segments","segIndex","currentSegment","childNode","appendChild","childName","findPathNodeByPath","rootNode","nodeCache","cachedNode","addPathNode","parentNode","ResolvedPathInfo","elements","paths","wildcardType","wildcardIndexes","tmpPatternElements","incompleteCount","completeCount","lastPath","getResolvedPathInfo","nameInfo","StatePropertyRef","listIndexRef","listIndex","deref","key","WeakRef","createRefKey","refByInfoByListIndex","WeakMap","refByInfoByNull","getStatePropertyRef","ref","refByInfo","getContextListIndex","handler","lastRefStack","index","at","getListIndex","resolvedPath","receiver","parentListIndex","wildcardParentPattern","wildcardRef","engine","getListIndexes","wildcardParent","wildcardIndex","symbolName","GetByRefSymbol","Symbol","for","SetByRefSymbol","SetCacheableSymbol","ConnectedCallbackSymbol","DisconnectedCallbackSymbol","checkDependency","refIndex","lastInfo","pathManager","onlyGetters","addDynamicDependency","getByRefWritable","target","getters","cacheEntry","revision","updater","revisionByUpdatedPath","version","stateOutput","startsWith","intersection","size","refPath","parentValue","Reflect","refStack","setByRef","setters","enqueueRef","getByRefReadonly","resolve","prop","indexes","expected","received","hasSetValue","receiverHasSetCacheable","handlerHasCache","trackDependency","indexByIndexName","getWritable","resolveFn","wildcardPattern","infoPattern","walkWildcardPattern","wildardIndexPos","indexPos","parentIndexes","results","concat","resultIndexes","resultValues","getAllWritable","to","getRouter","navigate","owner","resolvedInfo","async","callback","call","connectedCallback","disconnectedCallback","StateHandler$1","fill","loopContext","setMethods","setApis","trapGet","trapSet","useWritableStateProxy","state","StateHandler","stateProxy","Proxy","asyncSetStatePropertyRef","setLoopContext","ListIndex","pos","position","dirty","varName","createListIndex","getReadonly","getAllReadonly","setCacheable","Renderer","processedRefs","listDiffByRef","reorderIndexesByRef","reorderList","items","listRefs","lists","refKey","listRef","newListValue","listClone","oldListValue","oldListIndexes","getListAndListIndexes","listDiff","oldIndexes","newIndexes","from","changeIndexes","overwrites","elementValue","oldIndex","indexOf","saveListAndListIndexes","renderItem","render","clear","calcListDiff","_newListValue","undefined","isNewValue","list","_oldListValue","_oldIndexes","removes","adds","indexByValue","usedOldIndexes","maybeSame","newValue","newListIndex","existingListIndex","bindings","getBindings","childInfo","diff","childRef","deps","dynamicDependencies","depPath","depInfo","depNode","infos","walk","depRef","nextInfo","nextRef","subDepRef","startRef","Updater","queue","updating","rendering","updateInfo","cacheValueByRef","oldValueAndIndexesByRef","versionUp","updatedRefs","collectMaybeUpdates","queueMicrotask","beginUpdate","getOldListAndListIndexes","saveInfo","recursiveCollectMaybeUpdates","visitedInfo","entries","childPath","revisionByUpdatePath","update","BindingNodeEvent","addEventListener","e","parentBindContent","currentLoopContext","serialize","preventDefault","stopPropagation","func","getValue","apply","createBindingNodeEvent","filterTexts","filterFns","BindingNodeBlock","textContent","BindingNodeIf","bindContent","trueBindContents","falseBindContents","blankRef","createBindContent","valueType","nodeType","mountAfter","unmount","EMPTY_SET","BindingNodeFor","bindContentByListIndex","bindContentPool","bindContentLastIndex","loopInfo","assignListIndex","loopRef","deleteBindContent","clearListIndex","poolLength","loopPath","newBindContents","removeBindContentsSet","isAllRemove","isParentNodeHasOnlyThisNode","parentChildNodes","lastContent","firstNode","Node","TEXT_NODE","nextSibling","lastNode","previousSibling","getLastNode","append","when","lastBindContent","sort","a","b","fragmentParentNode","fragmentFirstNode","firstChildNode","createBindingNodeFor","DEFAULT_PROPERTY","defaultPropertyByElementType","radio","checkbox","button","getDefaultPropertyByNodeType","HTMLElement","HTMLTextAreaElement","HTMLOptionElement","HTMLButtonElement","HTMLAnchorElement","HTMLFormElement","HTMLInputElement","type","SVGElement","Text","Template","defaultEventByName","selected","BindingNodeProperty","defaultName","getDefaultName","decoratesCount","eventName","updateStateValue","createBindingNodeProperty","BindingNodeRadio","BindingNodeStyle","style","setProperty","AssignStateSymbol","NotifyRedrawSymbol","parentStructiveComponentByStructiveComponent","BindingNodeComponent","parentComponent","component","bindingsByComponent","notifyRefs","thisAt","newRef","nodePropertyConstructorByNameByIsComment","class","if","nodePropertyConstructorByFirstName","attr","getBindingNodeCreator","propertyName","isComment","Comment","isElement","Element","fn","bindingNodeCreatorByName","nameElements","bindingNodeCreatorByFirstName","_getBindingNodeCreator","BindingState","nullRef","saveBinding","writeState","BindingStateIndex","indexNumber","loopContexts","bindingsByListIndex","ereg","RegExp","getBindingStateCreator","test","createBindingStateIndex","createBindingState","nodeTypeByNodeKey","getNodeType","nodeKey","createNodeKey","getNodeTypeByNode","s","re","decode","m","exec","decodeURIComponent","parseFilter","parseProperty","property","parseExpressions","expression","bindExpression","decoratesExpression","nodePropertyText","statePropertyText","nodeProperty","inputFilterTexts","stateProperty","outputFilterTexts","parseExpression","removeAttributeFromElement","removeAttribute","removeAttributeByNodeType","replaceTextNodeFn","textNode","document","createTextNode","replaceChild","DataBindAttributes","nodePath","bindTexts","creatorByText","getAttribute","getTemplateById","getDataBindText","removeDataBindAttribute","replaceTextNodeFromComment","routeIndexes","getAbsoluteNodePath","parseBindText","bindText","creator","createBindingNode","getNodesHavingDataBind","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","SHOW_COMMENT","acceptNode","hasAttribute","FILTER_ACCEPT","FILTER_SKIP","isCommentNode","nextNode","currentNode","listDataBindAttributesById","listPathsSetById","pathsSetById","getDataBindAttributesFromTemplate","content","createDataBindAttributes","templateById","registerTemplate","template","rootId","forEach","nodeValue","removeChild","dataBindAttributes","listPaths","attribute","j","registerDataBindAttributes","templateId","Binding","bindingNode","inputFilters","outputFilters","createBinding","LoopContext","parentLoopContext","currentBindContent","parentBinding","unshift","createContent","fragment","importNode","Object","keys","lazyLoadComponentAliasByTagName","lazyLoadElements","querySelectorAll","loadLazyLoadComponent","tagName","createBindings","attributes","getDataBindAttributesById","blockBindings","BindContent","isMounted","lastChildNode","hasBlockBinding","lastBinding","mount","mountBefore","beforeNode","insertBefore","afterNode","attachShadow","extends","createElement","mode","canHaveShadowRoot","shadowRoot","adoptedStyleSheets","shadowRootOrDocument","ShadowRoot","getParentShadowRoot","styleSheets","ComponentStateBinding","parentPaths","childPaths","childPathByParentPath","parentPathByChildPath","bindingByParentPath","bindingByChildPath","WeakSet","addBinding","existingChildPath","existingParentPath","getChildPath","getParentPath","toParentPathFromChildPath","matchPaths","matchPathArray","longestMatchPath","remainPath","matchParentPath","toChildPathFromParentPath","matchChildPath","startsWithByChildPath","childPathInfo","matches","bind","childComponent","getBindingsFromChild","ComponentStateInputHandler","componentStateBinding","assignState","object","parentPathRef","childListIndex","getPropertyValue","setPropertyValue","ComponentStateOutput","parentRef","parentPathInfo","pathInfo","EMPTY_SAVE_INFO","ComponentEngine","stateClass","componentId","baseClass","structiveChildComponents","waitForInitialize","Promise","withResolvers","waitForDisconnected","stateBinding","createComponentStateBinding","stateInput","blockPlaceholder","blockParentNode","ignoreDissconnectedCallback","currentVersion","componentClass","createComponentStateInput","setup","alls","rootRef","promise","parentStructiveComponent","dataset","json","JSON","parse","datasetState","registerChildComponent","enableWebComponents","createComment","replaceWith","funcs","unregisterChildComponent","saveInfoByStructuredPathId","saveInfoByResolvedPathInfoIdByListIndex","saveInfoByRef","listByRef","listIndexesByRef","bindingsByRef","listCloneByRef","delete","MUSTACHE_REGEXP","MUSTACHE_TYPES","SVG_NS","replaceTemplateTagWithComment","namespaceURI","newTemplate","registerHtml","html","innerHTML","stack","replaceAll","match","expr","remain","currentInfo","endTags","pop","stackDepth","got","replaceMustacheWithTemplateTag","checkSegmentRegexp","checkPathRegexp","createAccessorFunctions","len","matchPath","curPath","matchInfo","count","segment","Function","PathManager","getterSetters","optimizes","staticDependencies","createRootNode","getPathsSetById","union","getListPathsSetById","listPath","elementPath","currentProto","prototype","getOwnPropertyDescriptors","desc","hasGetter","hasSetter","getPrototypeOf","defineProperty","enumerable","configurable","dianamicDependencyKeys","source","createComponentClass","componentData","componentConfig","userConfig","Tn","getComponentConfig","$config","Is","Ss","Gn","assign","$isStructive","registerStateClass","extendTagName","getBaseClass","createComponentEngine","el","isStructive","define","customElements","styleSheetId","getStyleSheetById","stateClassId","getStateClassById","unescapeEmbed","loadSingleFileComponent","resolved","response","fetch","escapeEmbed","querySelector","script","scriptModule","b64","btoa","fromCodePoint","TextEncoder","encode","import","default","createSingleFileComponent","registerComponentClass","ROUTES_KEY","COMPONENTS_KEY","LAZY_LOAD_SUFFIX","loadFromImportMap","importmap","scriptImportmap","imports","loadImportmap","loadAliasByTagName","alias","isLazyLoad","endsWith","replace","entryRoute","console","warn","ROUTE_PATH_PREFIX","routeEntries","globalRouter","Router","originalPathName","window","location","pathname","originalFileName","basePath","href","origin","_popstateHandler","popstateHandler","dispatchEvent","Event","removeEventListener","event","toPath","history","pushState","n","replacedPath","params","tag","regex","substring","customElement","stringify","hasOwnProperty","isLazyLoadComponent","messageElement","routePath","SLOT_KEY","DEFAULT_LAYOUT","MainWrapper","loadLayout","ok","layoutText","workTemplate","createDocumentFragment","router","_config","initialized","defineComponents","singleFileComponents","registerSingleFileComponents","bootstrapStructive","mainWrapper","body","bootstrap"],"mappings":"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"}